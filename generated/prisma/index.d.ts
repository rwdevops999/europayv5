
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceAction
 * 
 */
export type ServiceAction = $Result.DefaultSelection<Prisma.$ServiceActionPayload>
/**
 * Model ServiceStatementAction
 * 
 */
export type ServiceStatementAction = $Result.DefaultSelection<Prisma.$ServiceStatementActionPayload>
/**
 * Model ServiceStatement
 * 
 */
export type ServiceStatement = $Result.DefaultSelection<Prisma.$ServiceStatementPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model Policy
 * 
 */
export type Policy = $Result.DefaultSelection<Prisma.$PolicyPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPAT
 * 
 */
export type UserPAT = $Result.DefaultSelection<Prisma.$UserPATPayload>
/**
 * Model UserSetting
 * 
 */
export type UserSetting = $Result.DefaultSelection<Prisma.$UserSettingPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model Export
 * 
 */
export type Export = $Result.DefaultSelection<Prisma.$ExportPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model AccountApply
 * 
 */
export type AccountApply = $Result.DefaultSelection<Prisma.$AccountApplyPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model OTP
 * 
 */
export type OTP = $Result.DefaultSelection<Prisma.$OTPPayload>
/**
 * Model History
 * 
 */
export type History = $Result.DefaultSelection<Prisma.$HistoryPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Permission: {
  ALLOW: 'ALLOW',
  DENY: 'DENY'
};

export type Permission = (typeof Permission)[keyof typeof Permission]


export const TemplateRole: {
  ALL: 'ALL',
  ALERT: 'ALERT',
  EMAIL: 'EMAIL',
  HISTORY: 'HISTORY',
  LOGIN: 'LOGIN',
  TASK: 'TASK',
  NOTIFICATION: 'NOTIFICATION'
};

export type TemplateRole = (typeof TemplateRole)[keyof typeof TemplateRole]


export const UserType: {
  EUROPAY: 'EUROPAY',
  GUEST: 'GUEST'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const TokenStatus: {
  ACTIVE: 'ACTIVE',
  VOID: 'VOID'
};

export type TokenStatus = (typeof TokenStatus)[keyof typeof TokenStatus]


export const AccountStatus: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  BLOCKED: 'BLOCKED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const AccountApplyStatus: {
  CREATED: 'CREATED',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED'
};

export type AccountApplyStatus = (typeof AccountApplyStatus)[keyof typeof AccountApplyStatus]


export const Gender: {
  MALE: 'MALE',
  COMPLETE: 'COMPLETE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const TaskStatus: {
  CREATED: 'CREATED',
  OPEN: 'OPEN',
  COMPLETE: 'COMPLETE'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const OTPStatus: {
  ONGOING: 'ONGOING',
  USED: 'USED',
  EXPIRED: 'EXPIRED'
};

export type OTPStatus = (typeof OTPStatus)[keyof typeof OTPStatus]


export const HistoryType: {
  ALL: 'ALL',
  INFO: 'INFO',
  ACTION: 'ACTION'
};

export type HistoryType = (typeof HistoryType)[keyof typeof HistoryType]


export const JobModel: {
  CLIENT: 'CLIENT',
  SERVER: 'SERVER'
};

export type JobModel = (typeof JobModel)[keyof typeof JobModel]


export const JobStatus: {
  CREATED: 'CREATED',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  SUSPENDED: 'SUSPENDED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const TransactionStatus: {
  PENDING: 'PENDING',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const IBANStatus: {
  VALID: 'VALID',
  INVALID: 'INVALID'
};

export type IBANStatus = (typeof IBANStatus)[keyof typeof IBANStatus]

}

export type Permission = $Enums.Permission

export const Permission: typeof $Enums.Permission

export type TemplateRole = $Enums.TemplateRole

export const TemplateRole: typeof $Enums.TemplateRole

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type TokenStatus = $Enums.TokenStatus

export const TokenStatus: typeof $Enums.TokenStatus

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type AccountApplyStatus = $Enums.AccountApplyStatus

export const AccountApplyStatus: typeof $Enums.AccountApplyStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type OTPStatus = $Enums.OTPStatus

export const OTPStatus: typeof $Enums.OTPStatus

export type HistoryType = $Enums.HistoryType

export const HistoryType: typeof $Enums.HistoryType

export type JobModel = $Enums.JobModel

export const JobModel: typeof $Enums.JobModel

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type IBANStatus = $Enums.IBANStatus

export const IBANStatus: typeof $Enums.IBANStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Services
 * const services = await prisma.service.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Services
   * const services = await prisma.service.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceAction`: Exposes CRUD operations for the **ServiceAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceActions
    * const serviceActions = await prisma.serviceAction.findMany()
    * ```
    */
  get serviceAction(): Prisma.ServiceActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceStatementAction`: Exposes CRUD operations for the **ServiceStatementAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceStatementActions
    * const serviceStatementActions = await prisma.serviceStatementAction.findMany()
    * ```
    */
  get serviceStatementAction(): Prisma.ServiceStatementActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceStatement`: Exposes CRUD operations for the **ServiceStatement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceStatements
    * const serviceStatements = await prisma.serviceStatement.findMany()
    * ```
    */
  get serviceStatement(): Prisma.ServiceStatementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPAT`: Exposes CRUD operations for the **UserPAT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPATS
    * const userPATS = await prisma.userPAT.findMany()
    * ```
    */
  get userPAT(): Prisma.UserPATDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSetting`: Exposes CRUD operations for the **UserSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSetting.findMany()
    * ```
    */
  get userSetting(): Prisma.UserSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.export`: Exposes CRUD operations for the **Export** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exports
    * const exports = await prisma.export.findMany()
    * ```
    */
  get export(): Prisma.ExportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountApply`: Exposes CRUD operations for the **AccountApply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountApplies
    * const accountApplies = await prisma.accountApply.findMany()
    * ```
    */
  get accountApply(): Prisma.AccountApplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oTP`: Exposes CRUD operations for the **OTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTPS
    * const oTPS = await prisma.oTP.findMany()
    * ```
    */
  get oTP(): Prisma.OTPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.history`: Exposes CRUD operations for the **History** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Histories
    * const histories = await prisma.history.findMany()
    * ```
    */
  get history(): Prisma.HistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Service: 'Service',
    ServiceAction: 'ServiceAction',
    ServiceStatementAction: 'ServiceStatementAction',
    ServiceStatement: 'ServiceStatement',
    Template: 'Template',
    Policy: 'Policy',
    Setting: 'Setting',
    Role: 'Role',
    Country: 'Country',
    Address: 'Address',
    User: 'User',
    UserPAT: 'UserPAT',
    UserSetting: 'UserSetting',
    Group: 'Group',
    Export: 'Export',
    Account: 'Account',
    AccountApply: 'AccountApply',
    Task: 'Task',
    OTP: 'OTP',
    History: 'History',
    Job: 'Job',
    Transaction: 'Transaction',
    BankAccount: 'BankAccount'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "service" | "serviceAction" | "serviceStatementAction" | "serviceStatement" | "template" | "policy" | "setting" | "role" | "country" | "address" | "user" | "userPAT" | "userSetting" | "group" | "export" | "account" | "accountApply" | "task" | "oTP" | "history" | "job" | "transaction" | "bankAccount"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceAction: {
        payload: Prisma.$ServiceActionPayload<ExtArgs>
        fields: Prisma.ServiceActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>
          }
          findFirst: {
            args: Prisma.ServiceActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>
          }
          findMany: {
            args: Prisma.ServiceActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>[]
          }
          create: {
            args: Prisma.ServiceActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>
          }
          createMany: {
            args: Prisma.ServiceActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>[]
          }
          delete: {
            args: Prisma.ServiceActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>
          }
          update: {
            args: Prisma.ServiceActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>
          }
          deleteMany: {
            args: Prisma.ServiceActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>[]
          }
          upsert: {
            args: Prisma.ServiceActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceActionPayload>
          }
          aggregate: {
            args: Prisma.ServiceActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceAction>
          }
          groupBy: {
            args: Prisma.ServiceActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceActionCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceActionCountAggregateOutputType> | number
          }
        }
      }
      ServiceStatementAction: {
        payload: Prisma.$ServiceStatementActionPayload<ExtArgs>
        fields: Prisma.ServiceStatementActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceStatementActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceStatementActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>
          }
          findFirst: {
            args: Prisma.ServiceStatementActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceStatementActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>
          }
          findMany: {
            args: Prisma.ServiceStatementActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>[]
          }
          create: {
            args: Prisma.ServiceStatementActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>
          }
          createMany: {
            args: Prisma.ServiceStatementActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceStatementActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>[]
          }
          delete: {
            args: Prisma.ServiceStatementActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>
          }
          update: {
            args: Prisma.ServiceStatementActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>
          }
          deleteMany: {
            args: Prisma.ServiceStatementActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceStatementActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceStatementActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>[]
          }
          upsert: {
            args: Prisma.ServiceStatementActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementActionPayload>
          }
          aggregate: {
            args: Prisma.ServiceStatementActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceStatementAction>
          }
          groupBy: {
            args: Prisma.ServiceStatementActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceStatementActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceStatementActionCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceStatementActionCountAggregateOutputType> | number
          }
        }
      }
      ServiceStatement: {
        payload: Prisma.$ServiceStatementPayload<ExtArgs>
        fields: Prisma.ServiceStatementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceStatementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceStatementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>
          }
          findFirst: {
            args: Prisma.ServiceStatementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceStatementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>
          }
          findMany: {
            args: Prisma.ServiceStatementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>[]
          }
          create: {
            args: Prisma.ServiceStatementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>
          }
          createMany: {
            args: Prisma.ServiceStatementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceStatementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>[]
          }
          delete: {
            args: Prisma.ServiceStatementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>
          }
          update: {
            args: Prisma.ServiceStatementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>
          }
          deleteMany: {
            args: Prisma.ServiceStatementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceStatementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceStatementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>[]
          }
          upsert: {
            args: Prisma.ServiceStatementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatementPayload>
          }
          aggregate: {
            args: Prisma.ServiceStatementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceStatement>
          }
          groupBy: {
            args: Prisma.ServiceStatementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceStatementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceStatementCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceStatementCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      Policy: {
        payload: Prisma.$PolicyPayload<ExtArgs>
        fields: Prisma.PolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findFirst: {
            args: Prisma.PolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findMany: {
            args: Prisma.PolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          create: {
            args: Prisma.PolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          createMany: {
            args: Prisma.PolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          delete: {
            args: Prisma.PolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          update: {
            args: Prisma.PolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          upsert: {
            args: Prisma.PolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          aggregate: {
            args: Prisma.PolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy>
          }
          groupBy: {
            args: Prisma.PolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPAT: {
        payload: Prisma.$UserPATPayload<ExtArgs>
        fields: Prisma.UserPATFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPATFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPATFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>
          }
          findFirst: {
            args: Prisma.UserPATFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPATFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>
          }
          findMany: {
            args: Prisma.UserPATFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>[]
          }
          create: {
            args: Prisma.UserPATCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>
          }
          createMany: {
            args: Prisma.UserPATCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPATCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>[]
          }
          delete: {
            args: Prisma.UserPATDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>
          }
          update: {
            args: Prisma.UserPATUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>
          }
          deleteMany: {
            args: Prisma.UserPATDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPATUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPATUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>[]
          }
          upsert: {
            args: Prisma.UserPATUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPATPayload>
          }
          aggregate: {
            args: Prisma.UserPATAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPAT>
          }
          groupBy: {
            args: Prisma.UserPATGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPATGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPATCountArgs<ExtArgs>
            result: $Utils.Optional<UserPATCountAggregateOutputType> | number
          }
        }
      }
      UserSetting: {
        payload: Prisma.$UserSettingPayload<ExtArgs>
        fields: Prisma.UserSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          findFirst: {
            args: Prisma.UserSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          findMany: {
            args: Prisma.UserSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          create: {
            args: Prisma.UserSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          createMany: {
            args: Prisma.UserSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          delete: {
            args: Prisma.UserSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          update: {
            args: Prisma.UserSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          aggregate: {
            args: Prisma.UserSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSetting>
          }
          groupBy: {
            args: Prisma.UserSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      Export: {
        payload: Prisma.$ExportPayload<ExtArgs>
        fields: Prisma.ExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          findFirst: {
            args: Prisma.ExportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          findMany: {
            args: Prisma.ExportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>[]
          }
          create: {
            args: Prisma.ExportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          createMany: {
            args: Prisma.ExportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>[]
          }
          delete: {
            args: Prisma.ExportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          update: {
            args: Prisma.ExportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          deleteMany: {
            args: Prisma.ExportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>[]
          }
          upsert: {
            args: Prisma.ExportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportPayload>
          }
          aggregate: {
            args: Prisma.ExportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExport>
          }
          groupBy: {
            args: Prisma.ExportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportCountArgs<ExtArgs>
            result: $Utils.Optional<ExportCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      AccountApply: {
        payload: Prisma.$AccountApplyPayload<ExtArgs>
        fields: Prisma.AccountApplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountApplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountApplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>
          }
          findFirst: {
            args: Prisma.AccountApplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountApplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>
          }
          findMany: {
            args: Prisma.AccountApplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>[]
          }
          create: {
            args: Prisma.AccountApplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>
          }
          createMany: {
            args: Prisma.AccountApplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountApplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>[]
          }
          delete: {
            args: Prisma.AccountApplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>
          }
          update: {
            args: Prisma.AccountApplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>
          }
          deleteMany: {
            args: Prisma.AccountApplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountApplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountApplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>[]
          }
          upsert: {
            args: Prisma.AccountApplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountApplyPayload>
          }
          aggregate: {
            args: Prisma.AccountApplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountApply>
          }
          groupBy: {
            args: Prisma.AccountApplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountApplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountApplyCountArgs<ExtArgs>
            result: $Utils.Optional<AccountApplyCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      OTP: {
        payload: Prisma.$OTPPayload<ExtArgs>
        fields: Prisma.OTPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findFirst: {
            args: Prisma.OTPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findMany: {
            args: Prisma.OTPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          create: {
            args: Prisma.OTPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          createMany: {
            args: Prisma.OTPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          delete: {
            args: Prisma.OTPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          update: {
            args: Prisma.OTPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          deleteMany: {
            args: Prisma.OTPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OTPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          upsert: {
            args: Prisma.OTPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          aggregate: {
            args: Prisma.OTPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOTP>
          }
          groupBy: {
            args: Prisma.OTPGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTPGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTPCountArgs<ExtArgs>
            result: $Utils.Optional<OTPCountAggregateOutputType> | number
          }
        }
      }
      History: {
        payload: Prisma.$HistoryPayload<ExtArgs>
        fields: Prisma.HistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          findFirst: {
            args: Prisma.HistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          findMany: {
            args: Prisma.HistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>[]
          }
          create: {
            args: Prisma.HistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          createMany: {
            args: Prisma.HistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>[]
          }
          delete: {
            args: Prisma.HistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          update: {
            args: Prisma.HistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          deleteMany: {
            args: Prisma.HistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>[]
          }
          upsert: {
            args: Prisma.HistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoryPayload>
          }
          aggregate: {
            args: Prisma.HistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistory>
          }
          groupBy: {
            args: Prisma.HistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistoryCountArgs<ExtArgs>
            result: $Utils.Optional<HistoryCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    service?: ServiceOmit
    serviceAction?: ServiceActionOmit
    serviceStatementAction?: ServiceStatementActionOmit
    serviceStatement?: ServiceStatementOmit
    template?: TemplateOmit
    policy?: PolicyOmit
    setting?: SettingOmit
    role?: RoleOmit
    country?: CountryOmit
    address?: AddressOmit
    user?: UserOmit
    userPAT?: UserPATOmit
    userSetting?: UserSettingOmit
    group?: GroupOmit
    export?: ExportOmit
    account?: AccountOmit
    accountApply?: AccountApplyOmit
    task?: TaskOmit
    oTP?: OTPOmit
    history?: HistoryOmit
    job?: JobOmit
    transaction?: TransactionOmit
    bankAccount?: BankAccountOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    serviceactions: number
    servicestatements: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceactions?: boolean | ServiceCountOutputTypeCountServiceactionsArgs
    servicestatements?: boolean | ServiceCountOutputTypeCountServicestatementsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceActionWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServicestatementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatementWhereInput
  }


  /**
   * Count Type ServiceActionCountOutputType
   */

  export type ServiceActionCountOutputType = {
    services: number
    serviceStatementActions: number
  }

  export type ServiceActionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceActionCountOutputTypeCountServicesArgs
    serviceStatementActions?: boolean | ServiceActionCountOutputTypeCountServiceStatementActionsArgs
  }

  // Custom InputTypes
  /**
   * ServiceActionCountOutputType without action
   */
  export type ServiceActionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceActionCountOutputType
     */
    select?: ServiceActionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceActionCountOutputType without action
   */
  export type ServiceActionCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * ServiceActionCountOutputType without action
   */
  export type ServiceActionCountOutputTypeCountServiceStatementActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatementActionWhereInput
  }


  /**
   * Count Type ServiceStatementCountOutputType
   */

  export type ServiceStatementCountOutputType = {
    servicestatementactions: number
    policies: number
  }

  export type ServiceStatementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicestatementactions?: boolean | ServiceStatementCountOutputTypeCountServicestatementactionsArgs
    policies?: boolean | ServiceStatementCountOutputTypeCountPoliciesArgs
  }

  // Custom InputTypes
  /**
   * ServiceStatementCountOutputType without action
   */
  export type ServiceStatementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementCountOutputType
     */
    select?: ServiceStatementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceStatementCountOutputType without action
   */
  export type ServiceStatementCountOutputTypeCountServicestatementactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatementActionWhereInput
  }

  /**
   * ServiceStatementCountOutputType without action
   */
  export type ServiceStatementCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }


  /**
   * Count Type PolicyCountOutputType
   */

  export type PolicyCountOutputType = {
    servicestatements: number
    roles: number
    users: number
    groups: number
  }

  export type PolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicestatements?: boolean | PolicyCountOutputTypeCountServicestatementsArgs
    roles?: boolean | PolicyCountOutputTypeCountRolesArgs
    users?: boolean | PolicyCountOutputTypeCountUsersArgs
    groups?: boolean | PolicyCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes
  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyCountOutputType
     */
    select?: PolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountServicestatementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatementWhereInput
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    policies: number
    users: number
    groups: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policies?: boolean | RoleCountOutputTypeCountPoliciesArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    groups?: boolean | RoleCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    addresses: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | CountryCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    policies: number
    roles: number
    groups: number
    settings: number
    pats: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policies?: boolean | UserCountOutputTypeCountPoliciesArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    groups?: boolean | UserCountOutputTypeCountGroupsArgs
    settings?: boolean | UserCountOutputTypeCountSettingsArgs
    pats?: boolean | UserCountOutputTypeCountPatsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPATWhereInput
  }


  /**
   * Count Type UserSettingCountOutputType
   */

  export type UserSettingCountOutputType = {
    users: number
  }

  export type UserSettingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserSettingCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * UserSettingCountOutputType without action
   */
  export type UserSettingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingCountOutputType
     */
    select?: UserSettingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserSettingCountOutputType without action
   */
  export type UserSettingCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    policies: number
    roles: number
    users: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policies?: boolean | GroupCountOutputTypeCountPoliciesArgs
    roles?: boolean | GroupCountOutputTypeCountRolesArgs
    users?: boolean | GroupCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    sendertransactions: number
    receivertransactions: number
    bankaccounts: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sendertransactions?: boolean | AccountCountOutputTypeCountSendertransactionsArgs
    receivertransactions?: boolean | AccountCountOutputTypeCountReceivertransactionsArgs
    bankaccounts?: boolean | AccountCountOutputTypeCountBankaccountsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSendertransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountReceivertransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountBankaccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    servicename: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    servicename: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    servicename: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    servicename?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    servicename?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    servicename?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    servicename: string
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicename?: boolean
    serviceactions?: boolean | Service$serviceactionsArgs<ExtArgs>
    servicestatements?: boolean | Service$servicestatementsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicename?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicename?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    servicename?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "servicename", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceactions?: boolean | Service$serviceactionsArgs<ExtArgs>
    servicestatements?: boolean | Service$servicestatementsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      serviceactions: Prisma.$ServiceActionPayload<ExtArgs>[]
      servicestatements: Prisma.$ServiceStatementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      servicename: string
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceactions<T extends Service$serviceactionsArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    servicestatements<T extends Service$servicestatementsArgs<ExtArgs> = {}>(args?: Subset<T, Service$servicestatementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly servicename: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.serviceactions
   */
  export type Service$serviceactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    where?: ServiceActionWhereInput
    orderBy?: ServiceActionOrderByWithRelationInput | ServiceActionOrderByWithRelationInput[]
    cursor?: ServiceActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceActionScalarFieldEnum | ServiceActionScalarFieldEnum[]
  }

  /**
   * Service.servicestatements
   */
  export type Service$servicestatementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    where?: ServiceStatementWhereInput
    orderBy?: ServiceStatementOrderByWithRelationInput | ServiceStatementOrderByWithRelationInput[]
    cursor?: ServiceStatementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceStatementScalarFieldEnum | ServiceStatementScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceAction
   */

  export type AggregateServiceAction = {
    _count: ServiceActionCountAggregateOutputType | null
    _avg: ServiceActionAvgAggregateOutputType | null
    _sum: ServiceActionSumAggregateOutputType | null
    _min: ServiceActionMinAggregateOutputType | null
    _max: ServiceActionMaxAggregateOutputType | null
  }

  export type ServiceActionAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceActionSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceActionMinAggregateOutputType = {
    id: number | null
    serviceactionname: string | null
  }

  export type ServiceActionMaxAggregateOutputType = {
    id: number | null
    serviceactionname: string | null
  }

  export type ServiceActionCountAggregateOutputType = {
    id: number
    serviceactionname: number
    _all: number
  }


  export type ServiceActionAvgAggregateInputType = {
    id?: true
  }

  export type ServiceActionSumAggregateInputType = {
    id?: true
  }

  export type ServiceActionMinAggregateInputType = {
    id?: true
    serviceactionname?: true
  }

  export type ServiceActionMaxAggregateInputType = {
    id?: true
    serviceactionname?: true
  }

  export type ServiceActionCountAggregateInputType = {
    id?: true
    serviceactionname?: true
    _all?: true
  }

  export type ServiceActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAction to aggregate.
     */
    where?: ServiceActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceActions to fetch.
     */
    orderBy?: ServiceActionOrderByWithRelationInput | ServiceActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceActions
    **/
    _count?: true | ServiceActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceActionMaxAggregateInputType
  }

  export type GetServiceActionAggregateType<T extends ServiceActionAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceAction[P]>
      : GetScalarType<T[P], AggregateServiceAction[P]>
  }




  export type ServiceActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceActionWhereInput
    orderBy?: ServiceActionOrderByWithAggregationInput | ServiceActionOrderByWithAggregationInput[]
    by: ServiceActionScalarFieldEnum[] | ServiceActionScalarFieldEnum
    having?: ServiceActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceActionCountAggregateInputType | true
    _avg?: ServiceActionAvgAggregateInputType
    _sum?: ServiceActionSumAggregateInputType
    _min?: ServiceActionMinAggregateInputType
    _max?: ServiceActionMaxAggregateInputType
  }

  export type ServiceActionGroupByOutputType = {
    id: number
    serviceactionname: string
    _count: ServiceActionCountAggregateOutputType | null
    _avg: ServiceActionAvgAggregateOutputType | null
    _sum: ServiceActionSumAggregateOutputType | null
    _min: ServiceActionMinAggregateOutputType | null
    _max: ServiceActionMaxAggregateOutputType | null
  }

  type GetServiceActionGroupByPayload<T extends ServiceActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceActionGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceActionGroupByOutputType[P]>
        }
      >
    >


  export type ServiceActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceactionname?: boolean
    services?: boolean | ServiceAction$servicesArgs<ExtArgs>
    serviceStatementActions?: boolean | ServiceAction$serviceStatementActionsArgs<ExtArgs>
    _count?: boolean | ServiceActionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAction"]>

  export type ServiceActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceactionname?: boolean
  }, ExtArgs["result"]["serviceAction"]>

  export type ServiceActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceactionname?: boolean
  }, ExtArgs["result"]["serviceAction"]>

  export type ServiceActionSelectScalar = {
    id?: boolean
    serviceactionname?: boolean
  }

  export type ServiceActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceactionname", ExtArgs["result"]["serviceAction"]>
  export type ServiceActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceAction$servicesArgs<ExtArgs>
    serviceStatementActions?: boolean | ServiceAction$serviceStatementActionsArgs<ExtArgs>
    _count?: boolean | ServiceActionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceAction"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
      serviceStatementActions: Prisma.$ServiceStatementActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceactionname: string
    }, ExtArgs["result"]["serviceAction"]>
    composites: {}
  }

  type ServiceActionGetPayload<S extends boolean | null | undefined | ServiceActionDefaultArgs> = $Result.GetResult<Prisma.$ServiceActionPayload, S>

  type ServiceActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceActionCountAggregateInputType | true
    }

  export interface ServiceActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceAction'], meta: { name: 'ServiceAction' } }
    /**
     * Find zero or one ServiceAction that matches the filter.
     * @param {ServiceActionFindUniqueArgs} args - Arguments to find a ServiceAction
     * @example
     * // Get one ServiceAction
     * const serviceAction = await prisma.serviceAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceActionFindUniqueArgs>(args: SelectSubset<T, ServiceActionFindUniqueArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceActionFindUniqueOrThrowArgs} args - Arguments to find a ServiceAction
     * @example
     * // Get one ServiceAction
     * const serviceAction = await prisma.serviceAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceActionFindFirstArgs} args - Arguments to find a ServiceAction
     * @example
     * // Get one ServiceAction
     * const serviceAction = await prisma.serviceAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceActionFindFirstArgs>(args?: SelectSubset<T, ServiceActionFindFirstArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceActionFindFirstOrThrowArgs} args - Arguments to find a ServiceAction
     * @example
     * // Get one ServiceAction
     * const serviceAction = await prisma.serviceAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceActions
     * const serviceActions = await prisma.serviceAction.findMany()
     * 
     * // Get first 10 ServiceActions
     * const serviceActions = await prisma.serviceAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceActionWithIdOnly = await prisma.serviceAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceActionFindManyArgs>(args?: SelectSubset<T, ServiceActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceAction.
     * @param {ServiceActionCreateArgs} args - Arguments to create a ServiceAction.
     * @example
     * // Create one ServiceAction
     * const ServiceAction = await prisma.serviceAction.create({
     *   data: {
     *     // ... data to create a ServiceAction
     *   }
     * })
     * 
     */
    create<T extends ServiceActionCreateArgs>(args: SelectSubset<T, ServiceActionCreateArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceActions.
     * @param {ServiceActionCreateManyArgs} args - Arguments to create many ServiceActions.
     * @example
     * // Create many ServiceActions
     * const serviceAction = await prisma.serviceAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceActionCreateManyArgs>(args?: SelectSubset<T, ServiceActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceActions and returns the data saved in the database.
     * @param {ServiceActionCreateManyAndReturnArgs} args - Arguments to create many ServiceActions.
     * @example
     * // Create many ServiceActions
     * const serviceAction = await prisma.serviceAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceActions and only return the `id`
     * const serviceActionWithIdOnly = await prisma.serviceAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceAction.
     * @param {ServiceActionDeleteArgs} args - Arguments to delete one ServiceAction.
     * @example
     * // Delete one ServiceAction
     * const ServiceAction = await prisma.serviceAction.delete({
     *   where: {
     *     // ... filter to delete one ServiceAction
     *   }
     * })
     * 
     */
    delete<T extends ServiceActionDeleteArgs>(args: SelectSubset<T, ServiceActionDeleteArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceAction.
     * @param {ServiceActionUpdateArgs} args - Arguments to update one ServiceAction.
     * @example
     * // Update one ServiceAction
     * const serviceAction = await prisma.serviceAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceActionUpdateArgs>(args: SelectSubset<T, ServiceActionUpdateArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceActions.
     * @param {ServiceActionDeleteManyArgs} args - Arguments to filter ServiceActions to delete.
     * @example
     * // Delete a few ServiceActions
     * const { count } = await prisma.serviceAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceActionDeleteManyArgs>(args?: SelectSubset<T, ServiceActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceActions
     * const serviceAction = await prisma.serviceAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceActionUpdateManyArgs>(args: SelectSubset<T, ServiceActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceActions and returns the data updated in the database.
     * @param {ServiceActionUpdateManyAndReturnArgs} args - Arguments to update many ServiceActions.
     * @example
     * // Update many ServiceActions
     * const serviceAction = await prisma.serviceAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceActions and only return the `id`
     * const serviceActionWithIdOnly = await prisma.serviceAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceAction.
     * @param {ServiceActionUpsertArgs} args - Arguments to update or create a ServiceAction.
     * @example
     * // Update or create a ServiceAction
     * const serviceAction = await prisma.serviceAction.upsert({
     *   create: {
     *     // ... data to create a ServiceAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceAction we want to update
     *   }
     * })
     */
    upsert<T extends ServiceActionUpsertArgs>(args: SelectSubset<T, ServiceActionUpsertArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceActionCountArgs} args - Arguments to filter ServiceActions to count.
     * @example
     * // Count the number of ServiceActions
     * const count = await prisma.serviceAction.count({
     *   where: {
     *     // ... the filter for the ServiceActions we want to count
     *   }
     * })
    **/
    count<T extends ServiceActionCountArgs>(
      args?: Subset<T, ServiceActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceActionAggregateArgs>(args: Subset<T, ServiceActionAggregateArgs>): Prisma.PrismaPromise<GetServiceActionAggregateType<T>>

    /**
     * Group by ServiceAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceActionGroupByArgs['orderBy'] }
        : { orderBy?: ServiceActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceAction model
   */
  readonly fields: ServiceActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceAction$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceAction$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceStatementActions<T extends ServiceAction$serviceStatementActionsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceAction$serviceStatementActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceAction model
   */
  interface ServiceActionFieldRefs {
    readonly id: FieldRef<"ServiceAction", 'Int'>
    readonly serviceactionname: FieldRef<"ServiceAction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceAction findUnique
   */
  export type ServiceActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAction to fetch.
     */
    where: ServiceActionWhereUniqueInput
  }

  /**
   * ServiceAction findUniqueOrThrow
   */
  export type ServiceActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAction to fetch.
     */
    where: ServiceActionWhereUniqueInput
  }

  /**
   * ServiceAction findFirst
   */
  export type ServiceActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAction to fetch.
     */
    where?: ServiceActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceActions to fetch.
     */
    orderBy?: ServiceActionOrderByWithRelationInput | ServiceActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceActions.
     */
    cursor?: ServiceActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceActions.
     */
    distinct?: ServiceActionScalarFieldEnum | ServiceActionScalarFieldEnum[]
  }

  /**
   * ServiceAction findFirstOrThrow
   */
  export type ServiceActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAction to fetch.
     */
    where?: ServiceActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceActions to fetch.
     */
    orderBy?: ServiceActionOrderByWithRelationInput | ServiceActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceActions.
     */
    cursor?: ServiceActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceActions.
     */
    distinct?: ServiceActionScalarFieldEnum | ServiceActionScalarFieldEnum[]
  }

  /**
   * ServiceAction findMany
   */
  export type ServiceActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceActions to fetch.
     */
    where?: ServiceActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceActions to fetch.
     */
    orderBy?: ServiceActionOrderByWithRelationInput | ServiceActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceActions.
     */
    cursor?: ServiceActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceActions.
     */
    skip?: number
    distinct?: ServiceActionScalarFieldEnum | ServiceActionScalarFieldEnum[]
  }

  /**
   * ServiceAction create
   */
  export type ServiceActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceAction.
     */
    data: XOR<ServiceActionCreateInput, ServiceActionUncheckedCreateInput>
  }

  /**
   * ServiceAction createMany
   */
  export type ServiceActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceActions.
     */
    data: ServiceActionCreateManyInput | ServiceActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceAction createManyAndReturn
   */
  export type ServiceActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceActions.
     */
    data: ServiceActionCreateManyInput | ServiceActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceAction update
   */
  export type ServiceActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceAction.
     */
    data: XOR<ServiceActionUpdateInput, ServiceActionUncheckedUpdateInput>
    /**
     * Choose, which ServiceAction to update.
     */
    where: ServiceActionWhereUniqueInput
  }

  /**
   * ServiceAction updateMany
   */
  export type ServiceActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceActions.
     */
    data: XOR<ServiceActionUpdateManyMutationInput, ServiceActionUncheckedUpdateManyInput>
    /**
     * Filter which ServiceActions to update
     */
    where?: ServiceActionWhereInput
    /**
     * Limit how many ServiceActions to update.
     */
    limit?: number
  }

  /**
   * ServiceAction updateManyAndReturn
   */
  export type ServiceActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * The data used to update ServiceActions.
     */
    data: XOR<ServiceActionUpdateManyMutationInput, ServiceActionUncheckedUpdateManyInput>
    /**
     * Filter which ServiceActions to update
     */
    where?: ServiceActionWhereInput
    /**
     * Limit how many ServiceActions to update.
     */
    limit?: number
  }

  /**
   * ServiceAction upsert
   */
  export type ServiceActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceAction to update in case it exists.
     */
    where: ServiceActionWhereUniqueInput
    /**
     * In case the ServiceAction found by the `where` argument doesn't exist, create a new ServiceAction with this data.
     */
    create: XOR<ServiceActionCreateInput, ServiceActionUncheckedCreateInput>
    /**
     * In case the ServiceAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceActionUpdateInput, ServiceActionUncheckedUpdateInput>
  }

  /**
   * ServiceAction delete
   */
  export type ServiceActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
    /**
     * Filter which ServiceAction to delete.
     */
    where: ServiceActionWhereUniqueInput
  }

  /**
   * ServiceAction deleteMany
   */
  export type ServiceActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceActions to delete
     */
    where?: ServiceActionWhereInput
    /**
     * Limit how many ServiceActions to delete.
     */
    limit?: number
  }

  /**
   * ServiceAction.services
   */
  export type ServiceAction$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceAction.serviceStatementActions
   */
  export type ServiceAction$serviceStatementActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    where?: ServiceStatementActionWhereInput
    orderBy?: ServiceStatementActionOrderByWithRelationInput | ServiceStatementActionOrderByWithRelationInput[]
    cursor?: ServiceStatementActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceStatementActionScalarFieldEnum | ServiceStatementActionScalarFieldEnum[]
  }

  /**
   * ServiceAction without action
   */
  export type ServiceActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAction
     */
    select?: ServiceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAction
     */
    omit?: ServiceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceActionInclude<ExtArgs> | null
  }


  /**
   * Model ServiceStatementAction
   */

  export type AggregateServiceStatementAction = {
    _count: ServiceStatementActionCountAggregateOutputType | null
    _avg: ServiceStatementActionAvgAggregateOutputType | null
    _sum: ServiceStatementActionSumAggregateOutputType | null
    _min: ServiceStatementActionMinAggregateOutputType | null
    _max: ServiceStatementActionMaxAggregateOutputType | null
  }

  export type ServiceStatementActionAvgAggregateOutputType = {
    id: number | null
    statementid: number | null
    serviceactionid: number | null
  }

  export type ServiceStatementActionSumAggregateOutputType = {
    id: number | null
    statementid: number | null
    serviceactionid: number | null
  }

  export type ServiceStatementActionMinAggregateOutputType = {
    id: number | null
    ssactionname: string | null
    createDate: Date | null
    updateDate: Date | null
    statementid: number | null
    serviceactionid: number | null
  }

  export type ServiceStatementActionMaxAggregateOutputType = {
    id: number | null
    ssactionname: string | null
    createDate: Date | null
    updateDate: Date | null
    statementid: number | null
    serviceactionid: number | null
  }

  export type ServiceStatementActionCountAggregateOutputType = {
    id: number
    ssactionname: number
    createDate: number
    updateDate: number
    statementid: number
    serviceactionid: number
    _all: number
  }


  export type ServiceStatementActionAvgAggregateInputType = {
    id?: true
    statementid?: true
    serviceactionid?: true
  }

  export type ServiceStatementActionSumAggregateInputType = {
    id?: true
    statementid?: true
    serviceactionid?: true
  }

  export type ServiceStatementActionMinAggregateInputType = {
    id?: true
    ssactionname?: true
    createDate?: true
    updateDate?: true
    statementid?: true
    serviceactionid?: true
  }

  export type ServiceStatementActionMaxAggregateInputType = {
    id?: true
    ssactionname?: true
    createDate?: true
    updateDate?: true
    statementid?: true
    serviceactionid?: true
  }

  export type ServiceStatementActionCountAggregateInputType = {
    id?: true
    ssactionname?: true
    createDate?: true
    updateDate?: true
    statementid?: true
    serviceactionid?: true
    _all?: true
  }

  export type ServiceStatementActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceStatementAction to aggregate.
     */
    where?: ServiceStatementActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatementActions to fetch.
     */
    orderBy?: ServiceStatementActionOrderByWithRelationInput | ServiceStatementActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceStatementActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatementActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatementActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceStatementActions
    **/
    _count?: true | ServiceStatementActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceStatementActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceStatementActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceStatementActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceStatementActionMaxAggregateInputType
  }

  export type GetServiceStatementActionAggregateType<T extends ServiceStatementActionAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceStatementAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceStatementAction[P]>
      : GetScalarType<T[P], AggregateServiceStatementAction[P]>
  }




  export type ServiceStatementActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatementActionWhereInput
    orderBy?: ServiceStatementActionOrderByWithAggregationInput | ServiceStatementActionOrderByWithAggregationInput[]
    by: ServiceStatementActionScalarFieldEnum[] | ServiceStatementActionScalarFieldEnum
    having?: ServiceStatementActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceStatementActionCountAggregateInputType | true
    _avg?: ServiceStatementActionAvgAggregateInputType
    _sum?: ServiceStatementActionSumAggregateInputType
    _min?: ServiceStatementActionMinAggregateInputType
    _max?: ServiceStatementActionMaxAggregateInputType
  }

  export type ServiceStatementActionGroupByOutputType = {
    id: number
    ssactionname: string
    createDate: Date | null
    updateDate: Date | null
    statementid: number
    serviceactionid: number
    _count: ServiceStatementActionCountAggregateOutputType | null
    _avg: ServiceStatementActionAvgAggregateOutputType | null
    _sum: ServiceStatementActionSumAggregateOutputType | null
    _min: ServiceStatementActionMinAggregateOutputType | null
    _max: ServiceStatementActionMaxAggregateOutputType | null
  }

  type GetServiceStatementActionGroupByPayload<T extends ServiceStatementActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceStatementActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceStatementActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceStatementActionGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceStatementActionGroupByOutputType[P]>
        }
      >
    >


  export type ServiceStatementActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ssactionname?: boolean
    createDate?: boolean
    updateDate?: boolean
    statementid?: boolean
    serviceactionid?: boolean
    servicestatement?: boolean | ServiceStatementDefaultArgs<ExtArgs>
    serviceaction?: boolean | ServiceActionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatementAction"]>

  export type ServiceStatementActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ssactionname?: boolean
    createDate?: boolean
    updateDate?: boolean
    statementid?: boolean
    serviceactionid?: boolean
    servicestatement?: boolean | ServiceStatementDefaultArgs<ExtArgs>
    serviceaction?: boolean | ServiceActionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatementAction"]>

  export type ServiceStatementActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ssactionname?: boolean
    createDate?: boolean
    updateDate?: boolean
    statementid?: boolean
    serviceactionid?: boolean
    servicestatement?: boolean | ServiceStatementDefaultArgs<ExtArgs>
    serviceaction?: boolean | ServiceActionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatementAction"]>

  export type ServiceStatementActionSelectScalar = {
    id?: boolean
    ssactionname?: boolean
    createDate?: boolean
    updateDate?: boolean
    statementid?: boolean
    serviceactionid?: boolean
  }

  export type ServiceStatementActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ssactionname" | "createDate" | "updateDate" | "statementid" | "serviceactionid", ExtArgs["result"]["serviceStatementAction"]>
  export type ServiceStatementActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicestatement?: boolean | ServiceStatementDefaultArgs<ExtArgs>
    serviceaction?: boolean | ServiceActionDefaultArgs<ExtArgs>
  }
  export type ServiceStatementActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicestatement?: boolean | ServiceStatementDefaultArgs<ExtArgs>
    serviceaction?: boolean | ServiceActionDefaultArgs<ExtArgs>
  }
  export type ServiceStatementActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicestatement?: boolean | ServiceStatementDefaultArgs<ExtArgs>
    serviceaction?: boolean | ServiceActionDefaultArgs<ExtArgs>
  }

  export type $ServiceStatementActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceStatementAction"
    objects: {
      servicestatement: Prisma.$ServiceStatementPayload<ExtArgs>
      serviceaction: Prisma.$ServiceActionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ssactionname: string
      createDate: Date | null
      updateDate: Date | null
      statementid: number
      serviceactionid: number
    }, ExtArgs["result"]["serviceStatementAction"]>
    composites: {}
  }

  type ServiceStatementActionGetPayload<S extends boolean | null | undefined | ServiceStatementActionDefaultArgs> = $Result.GetResult<Prisma.$ServiceStatementActionPayload, S>

  type ServiceStatementActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceStatementActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceStatementActionCountAggregateInputType | true
    }

  export interface ServiceStatementActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceStatementAction'], meta: { name: 'ServiceStatementAction' } }
    /**
     * Find zero or one ServiceStatementAction that matches the filter.
     * @param {ServiceStatementActionFindUniqueArgs} args - Arguments to find a ServiceStatementAction
     * @example
     * // Get one ServiceStatementAction
     * const serviceStatementAction = await prisma.serviceStatementAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceStatementActionFindUniqueArgs>(args: SelectSubset<T, ServiceStatementActionFindUniqueArgs<ExtArgs>>): Prisma__ServiceStatementActionClient<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceStatementAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceStatementActionFindUniqueOrThrowArgs} args - Arguments to find a ServiceStatementAction
     * @example
     * // Get one ServiceStatementAction
     * const serviceStatementAction = await prisma.serviceStatementAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceStatementActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceStatementActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceStatementActionClient<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceStatementAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementActionFindFirstArgs} args - Arguments to find a ServiceStatementAction
     * @example
     * // Get one ServiceStatementAction
     * const serviceStatementAction = await prisma.serviceStatementAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceStatementActionFindFirstArgs>(args?: SelectSubset<T, ServiceStatementActionFindFirstArgs<ExtArgs>>): Prisma__ServiceStatementActionClient<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceStatementAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementActionFindFirstOrThrowArgs} args - Arguments to find a ServiceStatementAction
     * @example
     * // Get one ServiceStatementAction
     * const serviceStatementAction = await prisma.serviceStatementAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceStatementActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceStatementActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceStatementActionClient<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceStatementActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceStatementActions
     * const serviceStatementActions = await prisma.serviceStatementAction.findMany()
     * 
     * // Get first 10 ServiceStatementActions
     * const serviceStatementActions = await prisma.serviceStatementAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceStatementActionWithIdOnly = await prisma.serviceStatementAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceStatementActionFindManyArgs>(args?: SelectSubset<T, ServiceStatementActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceStatementAction.
     * @param {ServiceStatementActionCreateArgs} args - Arguments to create a ServiceStatementAction.
     * @example
     * // Create one ServiceStatementAction
     * const ServiceStatementAction = await prisma.serviceStatementAction.create({
     *   data: {
     *     // ... data to create a ServiceStatementAction
     *   }
     * })
     * 
     */
    create<T extends ServiceStatementActionCreateArgs>(args: SelectSubset<T, ServiceStatementActionCreateArgs<ExtArgs>>): Prisma__ServiceStatementActionClient<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceStatementActions.
     * @param {ServiceStatementActionCreateManyArgs} args - Arguments to create many ServiceStatementActions.
     * @example
     * // Create many ServiceStatementActions
     * const serviceStatementAction = await prisma.serviceStatementAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceStatementActionCreateManyArgs>(args?: SelectSubset<T, ServiceStatementActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceStatementActions and returns the data saved in the database.
     * @param {ServiceStatementActionCreateManyAndReturnArgs} args - Arguments to create many ServiceStatementActions.
     * @example
     * // Create many ServiceStatementActions
     * const serviceStatementAction = await prisma.serviceStatementAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceStatementActions and only return the `id`
     * const serviceStatementActionWithIdOnly = await prisma.serviceStatementAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceStatementActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceStatementActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceStatementAction.
     * @param {ServiceStatementActionDeleteArgs} args - Arguments to delete one ServiceStatementAction.
     * @example
     * // Delete one ServiceStatementAction
     * const ServiceStatementAction = await prisma.serviceStatementAction.delete({
     *   where: {
     *     // ... filter to delete one ServiceStatementAction
     *   }
     * })
     * 
     */
    delete<T extends ServiceStatementActionDeleteArgs>(args: SelectSubset<T, ServiceStatementActionDeleteArgs<ExtArgs>>): Prisma__ServiceStatementActionClient<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceStatementAction.
     * @param {ServiceStatementActionUpdateArgs} args - Arguments to update one ServiceStatementAction.
     * @example
     * // Update one ServiceStatementAction
     * const serviceStatementAction = await prisma.serviceStatementAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceStatementActionUpdateArgs>(args: SelectSubset<T, ServiceStatementActionUpdateArgs<ExtArgs>>): Prisma__ServiceStatementActionClient<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceStatementActions.
     * @param {ServiceStatementActionDeleteManyArgs} args - Arguments to filter ServiceStatementActions to delete.
     * @example
     * // Delete a few ServiceStatementActions
     * const { count } = await prisma.serviceStatementAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceStatementActionDeleteManyArgs>(args?: SelectSubset<T, ServiceStatementActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceStatementActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceStatementActions
     * const serviceStatementAction = await prisma.serviceStatementAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceStatementActionUpdateManyArgs>(args: SelectSubset<T, ServiceStatementActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceStatementActions and returns the data updated in the database.
     * @param {ServiceStatementActionUpdateManyAndReturnArgs} args - Arguments to update many ServiceStatementActions.
     * @example
     * // Update many ServiceStatementActions
     * const serviceStatementAction = await prisma.serviceStatementAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceStatementActions and only return the `id`
     * const serviceStatementActionWithIdOnly = await prisma.serviceStatementAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceStatementActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceStatementActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceStatementAction.
     * @param {ServiceStatementActionUpsertArgs} args - Arguments to update or create a ServiceStatementAction.
     * @example
     * // Update or create a ServiceStatementAction
     * const serviceStatementAction = await prisma.serviceStatementAction.upsert({
     *   create: {
     *     // ... data to create a ServiceStatementAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceStatementAction we want to update
     *   }
     * })
     */
    upsert<T extends ServiceStatementActionUpsertArgs>(args: SelectSubset<T, ServiceStatementActionUpsertArgs<ExtArgs>>): Prisma__ServiceStatementActionClient<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceStatementActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementActionCountArgs} args - Arguments to filter ServiceStatementActions to count.
     * @example
     * // Count the number of ServiceStatementActions
     * const count = await prisma.serviceStatementAction.count({
     *   where: {
     *     // ... the filter for the ServiceStatementActions we want to count
     *   }
     * })
    **/
    count<T extends ServiceStatementActionCountArgs>(
      args?: Subset<T, ServiceStatementActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceStatementActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceStatementAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceStatementActionAggregateArgs>(args: Subset<T, ServiceStatementActionAggregateArgs>): Prisma.PrismaPromise<GetServiceStatementActionAggregateType<T>>

    /**
     * Group by ServiceStatementAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceStatementActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceStatementActionGroupByArgs['orderBy'] }
        : { orderBy?: ServiceStatementActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceStatementActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceStatementActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceStatementAction model
   */
  readonly fields: ServiceStatementActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceStatementAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceStatementActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicestatement<T extends ServiceStatementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceStatementDefaultArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceaction<T extends ServiceActionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceActionDefaultArgs<ExtArgs>>): Prisma__ServiceActionClient<$Result.GetResult<Prisma.$ServiceActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceStatementAction model
   */
  interface ServiceStatementActionFieldRefs {
    readonly id: FieldRef<"ServiceStatementAction", 'Int'>
    readonly ssactionname: FieldRef<"ServiceStatementAction", 'String'>
    readonly createDate: FieldRef<"ServiceStatementAction", 'DateTime'>
    readonly updateDate: FieldRef<"ServiceStatementAction", 'DateTime'>
    readonly statementid: FieldRef<"ServiceStatementAction", 'Int'>
    readonly serviceactionid: FieldRef<"ServiceStatementAction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceStatementAction findUnique
   */
  export type ServiceStatementActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatementAction to fetch.
     */
    where: ServiceStatementActionWhereUniqueInput
  }

  /**
   * ServiceStatementAction findUniqueOrThrow
   */
  export type ServiceStatementActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatementAction to fetch.
     */
    where: ServiceStatementActionWhereUniqueInput
  }

  /**
   * ServiceStatementAction findFirst
   */
  export type ServiceStatementActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatementAction to fetch.
     */
    where?: ServiceStatementActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatementActions to fetch.
     */
    orderBy?: ServiceStatementActionOrderByWithRelationInput | ServiceStatementActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceStatementActions.
     */
    cursor?: ServiceStatementActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatementActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatementActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceStatementActions.
     */
    distinct?: ServiceStatementActionScalarFieldEnum | ServiceStatementActionScalarFieldEnum[]
  }

  /**
   * ServiceStatementAction findFirstOrThrow
   */
  export type ServiceStatementActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatementAction to fetch.
     */
    where?: ServiceStatementActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatementActions to fetch.
     */
    orderBy?: ServiceStatementActionOrderByWithRelationInput | ServiceStatementActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceStatementActions.
     */
    cursor?: ServiceStatementActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatementActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatementActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceStatementActions.
     */
    distinct?: ServiceStatementActionScalarFieldEnum | ServiceStatementActionScalarFieldEnum[]
  }

  /**
   * ServiceStatementAction findMany
   */
  export type ServiceStatementActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatementActions to fetch.
     */
    where?: ServiceStatementActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatementActions to fetch.
     */
    orderBy?: ServiceStatementActionOrderByWithRelationInput | ServiceStatementActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceStatementActions.
     */
    cursor?: ServiceStatementActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatementActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatementActions.
     */
    skip?: number
    distinct?: ServiceStatementActionScalarFieldEnum | ServiceStatementActionScalarFieldEnum[]
  }

  /**
   * ServiceStatementAction create
   */
  export type ServiceStatementActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceStatementAction.
     */
    data: XOR<ServiceStatementActionCreateInput, ServiceStatementActionUncheckedCreateInput>
  }

  /**
   * ServiceStatementAction createMany
   */
  export type ServiceStatementActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceStatementActions.
     */
    data: ServiceStatementActionCreateManyInput | ServiceStatementActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceStatementAction createManyAndReturn
   */
  export type ServiceStatementActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceStatementActions.
     */
    data: ServiceStatementActionCreateManyInput | ServiceStatementActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceStatementAction update
   */
  export type ServiceStatementActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceStatementAction.
     */
    data: XOR<ServiceStatementActionUpdateInput, ServiceStatementActionUncheckedUpdateInput>
    /**
     * Choose, which ServiceStatementAction to update.
     */
    where: ServiceStatementActionWhereUniqueInput
  }

  /**
   * ServiceStatementAction updateMany
   */
  export type ServiceStatementActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceStatementActions.
     */
    data: XOR<ServiceStatementActionUpdateManyMutationInput, ServiceStatementActionUncheckedUpdateManyInput>
    /**
     * Filter which ServiceStatementActions to update
     */
    where?: ServiceStatementActionWhereInput
    /**
     * Limit how many ServiceStatementActions to update.
     */
    limit?: number
  }

  /**
   * ServiceStatementAction updateManyAndReturn
   */
  export type ServiceStatementActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * The data used to update ServiceStatementActions.
     */
    data: XOR<ServiceStatementActionUpdateManyMutationInput, ServiceStatementActionUncheckedUpdateManyInput>
    /**
     * Filter which ServiceStatementActions to update
     */
    where?: ServiceStatementActionWhereInput
    /**
     * Limit how many ServiceStatementActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceStatementAction upsert
   */
  export type ServiceStatementActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceStatementAction to update in case it exists.
     */
    where: ServiceStatementActionWhereUniqueInput
    /**
     * In case the ServiceStatementAction found by the `where` argument doesn't exist, create a new ServiceStatementAction with this data.
     */
    create: XOR<ServiceStatementActionCreateInput, ServiceStatementActionUncheckedCreateInput>
    /**
     * In case the ServiceStatementAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceStatementActionUpdateInput, ServiceStatementActionUncheckedUpdateInput>
  }

  /**
   * ServiceStatementAction delete
   */
  export type ServiceStatementActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    /**
     * Filter which ServiceStatementAction to delete.
     */
    where: ServiceStatementActionWhereUniqueInput
  }

  /**
   * ServiceStatementAction deleteMany
   */
  export type ServiceStatementActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceStatementActions to delete
     */
    where?: ServiceStatementActionWhereInput
    /**
     * Limit how many ServiceStatementActions to delete.
     */
    limit?: number
  }

  /**
   * ServiceStatementAction without action
   */
  export type ServiceStatementActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
  }


  /**
   * Model ServiceStatement
   */

  export type AggregateServiceStatement = {
    _count: ServiceStatementCountAggregateOutputType | null
    _avg: ServiceStatementAvgAggregateOutputType | null
    _sum: ServiceStatementSumAggregateOutputType | null
    _min: ServiceStatementMinAggregateOutputType | null
    _max: ServiceStatementMaxAggregateOutputType | null
  }

  export type ServiceStatementAvgAggregateOutputType = {
    id: number | null
    serviceid: number | null
  }

  export type ServiceStatementSumAggregateOutputType = {
    id: number | null
    serviceid: number | null
  }

  export type ServiceStatementMinAggregateOutputType = {
    id: number | null
    ssname: string | null
    description: string | null
    permission: $Enums.Permission | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
    serviceid: number | null
  }

  export type ServiceStatementMaxAggregateOutputType = {
    id: number | null
    ssname: string | null
    description: string | null
    permission: $Enums.Permission | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
    serviceid: number | null
  }

  export type ServiceStatementCountAggregateOutputType = {
    id: number
    ssname: number
    description: number
    permission: number
    managed: number
    system: number
    createDate: number
    updateDate: number
    serviceid: number
    _all: number
  }


  export type ServiceStatementAvgAggregateInputType = {
    id?: true
    serviceid?: true
  }

  export type ServiceStatementSumAggregateInputType = {
    id?: true
    serviceid?: true
  }

  export type ServiceStatementMinAggregateInputType = {
    id?: true
    ssname?: true
    description?: true
    permission?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
    serviceid?: true
  }

  export type ServiceStatementMaxAggregateInputType = {
    id?: true
    ssname?: true
    description?: true
    permission?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
    serviceid?: true
  }

  export type ServiceStatementCountAggregateInputType = {
    id?: true
    ssname?: true
    description?: true
    permission?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
    serviceid?: true
    _all?: true
  }

  export type ServiceStatementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceStatement to aggregate.
     */
    where?: ServiceStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatements to fetch.
     */
    orderBy?: ServiceStatementOrderByWithRelationInput | ServiceStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceStatements
    **/
    _count?: true | ServiceStatementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceStatementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceStatementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceStatementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceStatementMaxAggregateInputType
  }

  export type GetServiceStatementAggregateType<T extends ServiceStatementAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceStatement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceStatement[P]>
      : GetScalarType<T[P], AggregateServiceStatement[P]>
  }




  export type ServiceStatementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatementWhereInput
    orderBy?: ServiceStatementOrderByWithAggregationInput | ServiceStatementOrderByWithAggregationInput[]
    by: ServiceStatementScalarFieldEnum[] | ServiceStatementScalarFieldEnum
    having?: ServiceStatementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceStatementCountAggregateInputType | true
    _avg?: ServiceStatementAvgAggregateInputType
    _sum?: ServiceStatementSumAggregateInputType
    _min?: ServiceStatementMinAggregateInputType
    _max?: ServiceStatementMaxAggregateInputType
  }

  export type ServiceStatementGroupByOutputType = {
    id: number
    ssname: string
    description: string | null
    permission: $Enums.Permission | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
    serviceid: number
    _count: ServiceStatementCountAggregateOutputType | null
    _avg: ServiceStatementAvgAggregateOutputType | null
    _sum: ServiceStatementSumAggregateOutputType | null
    _min: ServiceStatementMinAggregateOutputType | null
    _max: ServiceStatementMaxAggregateOutputType | null
  }

  type GetServiceStatementGroupByPayload<T extends ServiceStatementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceStatementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceStatementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceStatementGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceStatementGroupByOutputType[P]>
        }
      >
    >


  export type ServiceStatementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ssname?: boolean
    description?: boolean
    permission?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
    serviceid?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    servicestatementactions?: boolean | ServiceStatement$servicestatementactionsArgs<ExtArgs>
    policies?: boolean | ServiceStatement$policiesArgs<ExtArgs>
    _count?: boolean | ServiceStatementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatement"]>

  export type ServiceStatementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ssname?: boolean
    description?: boolean
    permission?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
    serviceid?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatement"]>

  export type ServiceStatementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ssname?: boolean
    description?: boolean
    permission?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
    serviceid?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatement"]>

  export type ServiceStatementSelectScalar = {
    id?: boolean
    ssname?: boolean
    description?: boolean
    permission?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
    serviceid?: boolean
  }

  export type ServiceStatementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ssname" | "description" | "permission" | "managed" | "system" | "createDate" | "updateDate" | "serviceid", ExtArgs["result"]["serviceStatement"]>
  export type ServiceStatementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    servicestatementactions?: boolean | ServiceStatement$servicestatementactionsArgs<ExtArgs>
    policies?: boolean | ServiceStatement$policiesArgs<ExtArgs>
    _count?: boolean | ServiceStatementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceStatementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServiceStatementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServiceStatementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceStatement"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      servicestatementactions: Prisma.$ServiceStatementActionPayload<ExtArgs>[]
      policies: Prisma.$PolicyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ssname: string
      description: string | null
      permission: $Enums.Permission | null
      managed: boolean | null
      system: boolean | null
      createDate: Date | null
      updateDate: Date | null
      serviceid: number
    }, ExtArgs["result"]["serviceStatement"]>
    composites: {}
  }

  type ServiceStatementGetPayload<S extends boolean | null | undefined | ServiceStatementDefaultArgs> = $Result.GetResult<Prisma.$ServiceStatementPayload, S>

  type ServiceStatementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceStatementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceStatementCountAggregateInputType | true
    }

  export interface ServiceStatementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceStatement'], meta: { name: 'ServiceStatement' } }
    /**
     * Find zero or one ServiceStatement that matches the filter.
     * @param {ServiceStatementFindUniqueArgs} args - Arguments to find a ServiceStatement
     * @example
     * // Get one ServiceStatement
     * const serviceStatement = await prisma.serviceStatement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceStatementFindUniqueArgs>(args: SelectSubset<T, ServiceStatementFindUniqueArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceStatement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceStatementFindUniqueOrThrowArgs} args - Arguments to find a ServiceStatement
     * @example
     * // Get one ServiceStatement
     * const serviceStatement = await prisma.serviceStatement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceStatementFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceStatementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceStatement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementFindFirstArgs} args - Arguments to find a ServiceStatement
     * @example
     * // Get one ServiceStatement
     * const serviceStatement = await prisma.serviceStatement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceStatementFindFirstArgs>(args?: SelectSubset<T, ServiceStatementFindFirstArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceStatement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementFindFirstOrThrowArgs} args - Arguments to find a ServiceStatement
     * @example
     * // Get one ServiceStatement
     * const serviceStatement = await prisma.serviceStatement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceStatementFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceStatementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceStatements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceStatements
     * const serviceStatements = await prisma.serviceStatement.findMany()
     * 
     * // Get first 10 ServiceStatements
     * const serviceStatements = await prisma.serviceStatement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceStatementWithIdOnly = await prisma.serviceStatement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceStatementFindManyArgs>(args?: SelectSubset<T, ServiceStatementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceStatement.
     * @param {ServiceStatementCreateArgs} args - Arguments to create a ServiceStatement.
     * @example
     * // Create one ServiceStatement
     * const ServiceStatement = await prisma.serviceStatement.create({
     *   data: {
     *     // ... data to create a ServiceStatement
     *   }
     * })
     * 
     */
    create<T extends ServiceStatementCreateArgs>(args: SelectSubset<T, ServiceStatementCreateArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceStatements.
     * @param {ServiceStatementCreateManyArgs} args - Arguments to create many ServiceStatements.
     * @example
     * // Create many ServiceStatements
     * const serviceStatement = await prisma.serviceStatement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceStatementCreateManyArgs>(args?: SelectSubset<T, ServiceStatementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceStatements and returns the data saved in the database.
     * @param {ServiceStatementCreateManyAndReturnArgs} args - Arguments to create many ServiceStatements.
     * @example
     * // Create many ServiceStatements
     * const serviceStatement = await prisma.serviceStatement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceStatements and only return the `id`
     * const serviceStatementWithIdOnly = await prisma.serviceStatement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceStatementCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceStatementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceStatement.
     * @param {ServiceStatementDeleteArgs} args - Arguments to delete one ServiceStatement.
     * @example
     * // Delete one ServiceStatement
     * const ServiceStatement = await prisma.serviceStatement.delete({
     *   where: {
     *     // ... filter to delete one ServiceStatement
     *   }
     * })
     * 
     */
    delete<T extends ServiceStatementDeleteArgs>(args: SelectSubset<T, ServiceStatementDeleteArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceStatement.
     * @param {ServiceStatementUpdateArgs} args - Arguments to update one ServiceStatement.
     * @example
     * // Update one ServiceStatement
     * const serviceStatement = await prisma.serviceStatement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceStatementUpdateArgs>(args: SelectSubset<T, ServiceStatementUpdateArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceStatements.
     * @param {ServiceStatementDeleteManyArgs} args - Arguments to filter ServiceStatements to delete.
     * @example
     * // Delete a few ServiceStatements
     * const { count } = await prisma.serviceStatement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceStatementDeleteManyArgs>(args?: SelectSubset<T, ServiceStatementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceStatements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceStatements
     * const serviceStatement = await prisma.serviceStatement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceStatementUpdateManyArgs>(args: SelectSubset<T, ServiceStatementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceStatements and returns the data updated in the database.
     * @param {ServiceStatementUpdateManyAndReturnArgs} args - Arguments to update many ServiceStatements.
     * @example
     * // Update many ServiceStatements
     * const serviceStatement = await prisma.serviceStatement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceStatements and only return the `id`
     * const serviceStatementWithIdOnly = await prisma.serviceStatement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceStatementUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceStatementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceStatement.
     * @param {ServiceStatementUpsertArgs} args - Arguments to update or create a ServiceStatement.
     * @example
     * // Update or create a ServiceStatement
     * const serviceStatement = await prisma.serviceStatement.upsert({
     *   create: {
     *     // ... data to create a ServiceStatement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceStatement we want to update
     *   }
     * })
     */
    upsert<T extends ServiceStatementUpsertArgs>(args: SelectSubset<T, ServiceStatementUpsertArgs<ExtArgs>>): Prisma__ServiceStatementClient<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceStatements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementCountArgs} args - Arguments to filter ServiceStatements to count.
     * @example
     * // Count the number of ServiceStatements
     * const count = await prisma.serviceStatement.count({
     *   where: {
     *     // ... the filter for the ServiceStatements we want to count
     *   }
     * })
    **/
    count<T extends ServiceStatementCountArgs>(
      args?: Subset<T, ServiceStatementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceStatementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceStatement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceStatementAggregateArgs>(args: Subset<T, ServiceStatementAggregateArgs>): Prisma.PrismaPromise<GetServiceStatementAggregateType<T>>

    /**
     * Group by ServiceStatement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceStatementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceStatementGroupByArgs['orderBy'] }
        : { orderBy?: ServiceStatementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceStatementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceStatementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceStatement model
   */
  readonly fields: ServiceStatementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceStatement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceStatementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    servicestatementactions<T extends ServiceStatement$servicestatementactionsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceStatement$servicestatementactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    policies<T extends ServiceStatement$policiesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceStatement$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceStatement model
   */
  interface ServiceStatementFieldRefs {
    readonly id: FieldRef<"ServiceStatement", 'Int'>
    readonly ssname: FieldRef<"ServiceStatement", 'String'>
    readonly description: FieldRef<"ServiceStatement", 'String'>
    readonly permission: FieldRef<"ServiceStatement", 'Permission'>
    readonly managed: FieldRef<"ServiceStatement", 'Boolean'>
    readonly system: FieldRef<"ServiceStatement", 'Boolean'>
    readonly createDate: FieldRef<"ServiceStatement", 'DateTime'>
    readonly updateDate: FieldRef<"ServiceStatement", 'DateTime'>
    readonly serviceid: FieldRef<"ServiceStatement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceStatement findUnique
   */
  export type ServiceStatementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatement to fetch.
     */
    where: ServiceStatementWhereUniqueInput
  }

  /**
   * ServiceStatement findUniqueOrThrow
   */
  export type ServiceStatementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatement to fetch.
     */
    where: ServiceStatementWhereUniqueInput
  }

  /**
   * ServiceStatement findFirst
   */
  export type ServiceStatementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatement to fetch.
     */
    where?: ServiceStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatements to fetch.
     */
    orderBy?: ServiceStatementOrderByWithRelationInput | ServiceStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceStatements.
     */
    cursor?: ServiceStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceStatements.
     */
    distinct?: ServiceStatementScalarFieldEnum | ServiceStatementScalarFieldEnum[]
  }

  /**
   * ServiceStatement findFirstOrThrow
   */
  export type ServiceStatementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatement to fetch.
     */
    where?: ServiceStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatements to fetch.
     */
    orderBy?: ServiceStatementOrderByWithRelationInput | ServiceStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceStatements.
     */
    cursor?: ServiceStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceStatements.
     */
    distinct?: ServiceStatementScalarFieldEnum | ServiceStatementScalarFieldEnum[]
  }

  /**
   * ServiceStatement findMany
   */
  export type ServiceStatementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatements to fetch.
     */
    where?: ServiceStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatements to fetch.
     */
    orderBy?: ServiceStatementOrderByWithRelationInput | ServiceStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceStatements.
     */
    cursor?: ServiceStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatements.
     */
    skip?: number
    distinct?: ServiceStatementScalarFieldEnum | ServiceStatementScalarFieldEnum[]
  }

  /**
   * ServiceStatement create
   */
  export type ServiceStatementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceStatement.
     */
    data: XOR<ServiceStatementCreateInput, ServiceStatementUncheckedCreateInput>
  }

  /**
   * ServiceStatement createMany
   */
  export type ServiceStatementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceStatements.
     */
    data: ServiceStatementCreateManyInput | ServiceStatementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceStatement createManyAndReturn
   */
  export type ServiceStatementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceStatements.
     */
    data: ServiceStatementCreateManyInput | ServiceStatementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceStatement update
   */
  export type ServiceStatementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceStatement.
     */
    data: XOR<ServiceStatementUpdateInput, ServiceStatementUncheckedUpdateInput>
    /**
     * Choose, which ServiceStatement to update.
     */
    where: ServiceStatementWhereUniqueInput
  }

  /**
   * ServiceStatement updateMany
   */
  export type ServiceStatementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceStatements.
     */
    data: XOR<ServiceStatementUpdateManyMutationInput, ServiceStatementUncheckedUpdateManyInput>
    /**
     * Filter which ServiceStatements to update
     */
    where?: ServiceStatementWhereInput
    /**
     * Limit how many ServiceStatements to update.
     */
    limit?: number
  }

  /**
   * ServiceStatement updateManyAndReturn
   */
  export type ServiceStatementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * The data used to update ServiceStatements.
     */
    data: XOR<ServiceStatementUpdateManyMutationInput, ServiceStatementUncheckedUpdateManyInput>
    /**
     * Filter which ServiceStatements to update
     */
    where?: ServiceStatementWhereInput
    /**
     * Limit how many ServiceStatements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceStatement upsert
   */
  export type ServiceStatementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceStatement to update in case it exists.
     */
    where: ServiceStatementWhereUniqueInput
    /**
     * In case the ServiceStatement found by the `where` argument doesn't exist, create a new ServiceStatement with this data.
     */
    create: XOR<ServiceStatementCreateInput, ServiceStatementUncheckedCreateInput>
    /**
     * In case the ServiceStatement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceStatementUpdateInput, ServiceStatementUncheckedUpdateInput>
  }

  /**
   * ServiceStatement delete
   */
  export type ServiceStatementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    /**
     * Filter which ServiceStatement to delete.
     */
    where: ServiceStatementWhereUniqueInput
  }

  /**
   * ServiceStatement deleteMany
   */
  export type ServiceStatementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceStatements to delete
     */
    where?: ServiceStatementWhereInput
    /**
     * Limit how many ServiceStatements to delete.
     */
    limit?: number
  }

  /**
   * ServiceStatement.servicestatementactions
   */
  export type ServiceStatement$servicestatementactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatementAction
     */
    select?: ServiceStatementActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatementAction
     */
    omit?: ServiceStatementActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementActionInclude<ExtArgs> | null
    where?: ServiceStatementActionWhereInput
    orderBy?: ServiceStatementActionOrderByWithRelationInput | ServiceStatementActionOrderByWithRelationInput[]
    cursor?: ServiceStatementActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceStatementActionScalarFieldEnum | ServiceStatementActionScalarFieldEnum[]
  }

  /**
   * ServiceStatement.policies
   */
  export type ServiceStatement$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * ServiceStatement without action
   */
  export type ServiceStatementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateAvgAggregateOutputType = {
    id: number | null
  }

  export type TemplateSumAggregateOutputType = {
    id: number | null
  }

  export type TemplateMinAggregateOutputType = {
    id: number | null
    role: $Enums.TemplateRole | null
    name: string | null
    description: string | null
    content: string | null
    asHtml: boolean | null
    fromFile: boolean | null
    parameters: string | null
    managed: boolean | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: number | null
    role: $Enums.TemplateRole | null
    name: string | null
    description: string | null
    content: string | null
    asHtml: boolean | null
    fromFile: boolean | null
    parameters: string | null
    managed: boolean | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    role: number
    name: number
    description: number
    content: number
    asHtml: number
    fromFile: number
    parameters: number
    managed: number
    _all: number
  }


  export type TemplateAvgAggregateInputType = {
    id?: true
  }

  export type TemplateSumAggregateInputType = {
    id?: true
  }

  export type TemplateMinAggregateInputType = {
    id?: true
    role?: true
    name?: true
    description?: true
    content?: true
    asHtml?: true
    fromFile?: true
    parameters?: true
    managed?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    role?: true
    name?: true
    description?: true
    content?: true
    asHtml?: true
    fromFile?: true
    parameters?: true
    managed?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    role?: true
    name?: true
    description?: true
    content?: true
    asHtml?: true
    fromFile?: true
    parameters?: true
    managed?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _avg?: TemplateAvgAggregateInputType
    _sum?: TemplateSumAggregateInputType
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: number
    role: $Enums.TemplateRole | null
    name: string
    description: string | null
    content: string
    asHtml: boolean | null
    fromFile: boolean | null
    parameters: string | null
    managed: boolean | null
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    asHtml?: boolean
    fromFile?: boolean
    parameters?: boolean
    managed?: boolean
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    asHtml?: boolean
    fromFile?: boolean
    parameters?: boolean
    managed?: boolean
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    asHtml?: boolean
    fromFile?: boolean
    parameters?: boolean
    managed?: boolean
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    role?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    asHtml?: boolean
    fromFile?: boolean
    parameters?: boolean
    managed?: boolean
  }

  export type TemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "name" | "description" | "content" | "asHtml" | "fromFile" | "parameters" | "managed", ExtArgs["result"]["template"]>

  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role: $Enums.TemplateRole | null
      name: string
      description: string | null
      content: string
      asHtml: boolean | null
      fromFile: boolean | null
      parameters: string | null
      managed: boolean | null
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Templates and returns the data saved in the database.
     * @param {TemplateCreateManyAndReturnArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates and returns the data updated in the database.
     * @param {TemplateUpdateManyAndReturnArgs} args - Arguments to update many Templates.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'Int'>
    readonly role: FieldRef<"Template", 'TemplateRole'>
    readonly name: FieldRef<"Template", 'String'>
    readonly description: FieldRef<"Template", 'String'>
    readonly content: FieldRef<"Template", 'String'>
    readonly asHtml: FieldRef<"Template", 'Boolean'>
    readonly fromFile: FieldRef<"Template", 'Boolean'>
    readonly parameters: FieldRef<"Template", 'String'>
    readonly managed: FieldRef<"Template", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template createManyAndReturn
   */
  export type TemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
  }

  /**
   * Template updateManyAndReturn
   */
  export type TemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to delete.
     */
    limit?: number
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
  }


  /**
   * Model Policy
   */

  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    id: number | null
  }

  export type PolicySumAggregateOutputType = {
    id: number | null
  }

  export type PolicyMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    managed: number
    system: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    id?: true
  }

  export type PolicySumAggregateInputType = {
    id?: true
  }

  export type PolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type PolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policy to aggregate.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithAggregationInput | PolicyOrderByWithAggregationInput[]
    by: PolicyScalarFieldEnum[] | PolicyScalarFieldEnum
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }

  export type PolicyGroupByOutputType = {
    id: number
    name: string
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
    servicestatements?: boolean | Policy$servicestatementsArgs<ExtArgs>
    roles?: boolean | Policy$rolesArgs<ExtArgs>
    users?: boolean | Policy$usersArgs<ExtArgs>
    groups?: boolean | Policy$groupsArgs<ExtArgs>
    _count?: boolean | PolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type PolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "managed" | "system" | "createDate" | "updateDate", ExtArgs["result"]["policy"]>
  export type PolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicestatements?: boolean | Policy$servicestatementsArgs<ExtArgs>
    roles?: boolean | Policy$rolesArgs<ExtArgs>
    users?: boolean | Policy$usersArgs<ExtArgs>
    groups?: boolean | Policy$groupsArgs<ExtArgs>
    _count?: boolean | PolicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Policy"
    objects: {
      servicestatements: Prisma.$ServiceStatementPayload<ExtArgs>[]
      roles: Prisma.$RolePayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      groups: Prisma.$GroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      managed: boolean | null
      system: boolean | null
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["policy"]>
    composites: {}
  }

  type PolicyGetPayload<S extends boolean | null | undefined | PolicyDefaultArgs> = $Result.GetResult<Prisma.$PolicyPayload, S>

  type PolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PolicyCountAggregateInputType | true
    }

  export interface PolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Policy'], meta: { name: 'Policy' } }
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyFindUniqueArgs>(args: SelectSubset<T, PolicyFindUniqueArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Policy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PolicyFindUniqueOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyFindFirstArgs>(args?: SelectSubset<T, PolicyFindFirstArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyFindManyArgs>(args?: SelectSubset<T, PolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
     */
    create<T extends PolicyCreateArgs>(args: SelectSubset<T, PolicyCreateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Policies.
     * @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyCreateManyArgs>(args?: SelectSubset<T, PolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Policies and returns the data saved in the database.
     * @param {PolicyCreateManyAndReturnArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Policies and only return the `id`
     * const policyWithIdOnly = await prisma.policy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
     */
    delete<T extends PolicyDeleteArgs>(args: SelectSubset<T, PolicyDeleteArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyUpdateArgs>(args: SelectSubset<T, PolicyUpdateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDeleteManyArgs>(args?: SelectSubset<T, PolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyUpdateManyArgs>(args: SelectSubset<T, PolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies and returns the data updated in the database.
     * @param {PolicyUpdateManyAndReturnArgs} args - Arguments to update many Policies.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Policies and only return the `id`
     * const policyWithIdOnly = await prisma.policy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, PolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
     */
    upsert<T extends PolicyUpsertArgs>(args: SelectSubset<T, PolicyUpsertArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): Prisma.PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Policy model
   */
  readonly fields: PolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicestatements<T extends Policy$servicestatementsArgs<ExtArgs> = {}>(args?: Subset<T, Policy$servicestatementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends Policy$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Policy$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Policy$usersArgs<ExtArgs> = {}>(args?: Subset<T, Policy$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends Policy$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Policy$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Policy model
   */
  interface PolicyFieldRefs {
    readonly id: FieldRef<"Policy", 'Int'>
    readonly name: FieldRef<"Policy", 'String'>
    readonly description: FieldRef<"Policy", 'String'>
    readonly managed: FieldRef<"Policy", 'Boolean'>
    readonly system: FieldRef<"Policy", 'Boolean'>
    readonly createDate: FieldRef<"Policy", 'DateTime'>
    readonly updateDate: FieldRef<"Policy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findUniqueOrThrow
   */
  export type PolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findFirstOrThrow
   */
  export type PolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policies to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy create
   */
  export type PolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a Policy.
     */
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }

  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy createManyAndReturn
   */
  export type PolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy update
   */
  export type PolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a Policy.
     */
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to update.
     */
    limit?: number
  }

  /**
   * Policy updateManyAndReturn
   */
  export type PolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to update.
     */
    limit?: number
  }

  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the Policy to update in case it exists.
     */
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     */
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }

  /**
   * Policy delete
   */
  export type PolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter which Policy to delete.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policies to delete
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to delete.
     */
    limit?: number
  }

  /**
   * Policy.servicestatements
   */
  export type Policy$servicestatementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatement
     */
    select?: ServiceStatementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatement
     */
    omit?: ServiceStatementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatementInclude<ExtArgs> | null
    where?: ServiceStatementWhereInput
    orderBy?: ServiceStatementOrderByWithRelationInput | ServiceStatementOrderByWithRelationInput[]
    cursor?: ServiceStatementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceStatementScalarFieldEnum | ServiceStatementScalarFieldEnum[]
  }

  /**
   * Policy.roles
   */
  export type Policy$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Policy.users
   */
  export type Policy$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Policy.groups
   */
  export type Policy$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Policy without action
   */
  export type PolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingSumAggregateOutputType = {
    id: number | null
  }

  export type SettingMinAggregateOutputType = {
    id: number | null
    type: string | null
    subtype: string | null
    key: string | null
    value: string | null
  }

  export type SettingMaxAggregateOutputType = {
    id: number | null
    type: string | null
    subtype: string | null
    key: string | null
    value: string | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    type: number
    subtype: number
    key: number
    value: number
    _all: number
  }


  export type SettingAvgAggregateInputType = {
    id?: true
  }

  export type SettingSumAggregateInputType = {
    id?: true
  }

  export type SettingMinAggregateInputType = {
    id?: true
    type?: true
    subtype?: true
    key?: true
    value?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    type?: true
    subtype?: true
    key?: true
    value?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    type?: true
    subtype?: true
    key?: true
    value?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _avg?: SettingAvgAggregateInputType
    _sum?: SettingSumAggregateInputType
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: number
    type: string
    subtype: string
    key: string
    value: string
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subtype?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subtype?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subtype?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    type?: boolean
    subtype?: boolean
    key?: boolean
    value?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "subtype" | "key" | "value", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      subtype: string
      key: string
      value: string
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'Int'>
    readonly type: FieldRef<"Setting", 'String'>
    readonly subtype: FieldRef<"Setting", 'String'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    managed: number
    system: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
    policies?: boolean | Role$policiesArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    groups?: boolean | Role$groupsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "managed" | "system" | "createDate" | "updateDate", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policies?: boolean | Role$policiesArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    groups?: boolean | Role$groupsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      policies: Prisma.$PolicyPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      groups: Prisma.$GroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      managed: boolean | null
      system: boolean | null
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    policies<T extends Role$policiesArgs<ExtArgs> = {}>(args?: Subset<T, Role$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends Role$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Role$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly managed: FieldRef<"Role", 'Boolean'>
    readonly system: FieldRef<"Role", 'Boolean'>
    readonly createDate: FieldRef<"Role", 'DateTime'>
    readonly updateDate: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.policies
   */
  export type Role$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role.groups
   */
  export type Role$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    dialCode: string | null
    code: string | null
    currency: string | null
    currencycode: string | null
    symbol: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    dialCode: string | null
    code: string | null
    currency: string | null
    currencycode: string | null
    symbol: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    dialCode: number
    code: number
    currency: number
    currencycode: number
    symbol: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    dialCode?: true
    code?: true
    currency?: true
    currencycode?: true
    symbol?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    dialCode?: true
    code?: true
    currency?: true
    currencycode?: true
    symbol?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    dialCode?: true
    code?: true
    currency?: true
    currencycode?: true
    symbol?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    name: string
    dialCode: string | null
    code: string | null
    currency: string | null
    currencycode: string | null
    symbol: string | null
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dialCode?: boolean
    code?: boolean
    currency?: boolean
    currencycode?: boolean
    symbol?: boolean
    addresses?: boolean | Country$addressesArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dialCode?: boolean
    code?: boolean
    currency?: boolean
    currencycode?: boolean
    symbol?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dialCode?: boolean
    code?: boolean
    currency?: boolean
    currencycode?: boolean
    symbol?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    dialCode?: boolean
    code?: boolean
    currency?: boolean
    currencycode?: boolean
    symbol?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "dialCode" | "code" | "currency" | "currencycode" | "symbol", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | Country$addressesArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      addresses: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      dialCode: string | null
      code: string | null
      currency: string | null
      currencycode: string | null
      symbol: string | null
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addresses<T extends Country$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Country$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly name: FieldRef<"Country", 'String'>
    readonly dialCode: FieldRef<"Country", 'String'>
    readonly code: FieldRef<"Country", 'String'>
    readonly currency: FieldRef<"Country", 'String'>
    readonly currencycode: FieldRef<"Country", 'String'>
    readonly symbol: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.addresses
   */
  export type Country$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
    userId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    countryId: number | null
    userId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    street: string | null
    number: string | null
    box: string | null
    city: string | null
    postalcode: string | null
    createDate: Date | null
    updateDate: Date | null
    county: string | null
    countryId: number | null
    userId: number | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    street: string | null
    number: string | null
    box: string | null
    city: string | null
    postalcode: string | null
    createDate: Date | null
    updateDate: Date | null
    county: string | null
    countryId: number | null
    userId: number | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    street: number
    number: number
    box: number
    city: number
    postalcode: number
    createDate: number
    updateDate: number
    county: number
    countryId: number
    userId: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    countryId?: true
    userId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    countryId?: true
    userId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    street?: true
    number?: true
    box?: true
    city?: true
    postalcode?: true
    createDate?: true
    updateDate?: true
    county?: true
    countryId?: true
    userId?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street?: true
    number?: true
    box?: true
    city?: true
    postalcode?: true
    createDate?: true
    updateDate?: true
    county?: true
    countryId?: true
    userId?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street?: true
    number?: true
    box?: true
    city?: true
    postalcode?: true
    createDate?: true
    updateDate?: true
    county?: true
    countryId?: true
    userId?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    street: string | null
    number: string | null
    box: string | null
    city: string | null
    postalcode: string
    createDate: Date | null
    updateDate: Date | null
    county: string | null
    countryId: number | null
    userId: number | null
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    number?: boolean
    box?: boolean
    city?: boolean
    postalcode?: boolean
    createDate?: boolean
    updateDate?: boolean
    county?: boolean
    countryId?: boolean
    userId?: boolean
    country?: boolean | Address$countryArgs<ExtArgs>
    user?: boolean | Address$userArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    number?: boolean
    box?: boolean
    city?: boolean
    postalcode?: boolean
    createDate?: boolean
    updateDate?: boolean
    county?: boolean
    countryId?: boolean
    userId?: boolean
    country?: boolean | Address$countryArgs<ExtArgs>
    user?: boolean | Address$userArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    number?: boolean
    box?: boolean
    city?: boolean
    postalcode?: boolean
    createDate?: boolean
    updateDate?: boolean
    county?: boolean
    countryId?: boolean
    userId?: boolean
    country?: boolean | Address$countryArgs<ExtArgs>
    user?: boolean | Address$userArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    street?: boolean
    number?: boolean
    box?: boolean
    city?: boolean
    postalcode?: boolean
    createDate?: boolean
    updateDate?: boolean
    county?: boolean
    countryId?: boolean
    userId?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "street" | "number" | "box" | "city" | "postalcode" | "createDate" | "updateDate" | "county" | "countryId" | "userId", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | Address$countryArgs<ExtArgs>
    user?: boolean | Address$userArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | Address$countryArgs<ExtArgs>
    user?: boolean | Address$userArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | Address$countryArgs<ExtArgs>
    user?: boolean | Address$userArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      street: string | null
      number: string | null
      box: string | null
      city: string | null
      postalcode: string
      createDate: Date | null
      updateDate: Date | null
      county: string | null
      countryId: number | null
      userId: number | null
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends Address$countryArgs<ExtArgs> = {}>(args?: Subset<T, Address$countryArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Address$userArgs<ExtArgs> = {}>(args?: Subset<T, Address$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly street: FieldRef<"Address", 'String'>
    readonly number: FieldRef<"Address", 'String'>
    readonly box: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly postalcode: FieldRef<"Address", 'String'>
    readonly createDate: FieldRef<"Address", 'DateTime'>
    readonly updateDate: FieldRef<"Address", 'DateTime'>
    readonly county: FieldRef<"Address", 'String'>
    readonly countryId: FieldRef<"Address", 'Int'>
    readonly userId: FieldRef<"Address", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data?: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.country
   */
  export type Address$countryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    where?: CountryWhereInput
  }

  /**
   * Address.user
   */
  export type Address$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    attemps: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    attemps: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    lastname: string | null
    firstname: string | null
    avatar: string | null
    phone: string | null
    email: string | null
    password: string | null
    passwordless: boolean | null
    attemps: number | null
    blocked: boolean | null
    managed: boolean | null
    system: boolean | null
    loggedinDate: Date | null
    type: $Enums.UserType | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    lastname: string | null
    firstname: string | null
    avatar: string | null
    phone: string | null
    email: string | null
    password: string | null
    passwordless: boolean | null
    attemps: number | null
    blocked: boolean | null
    managed: boolean | null
    system: boolean | null
    loggedinDate: Date | null
    type: $Enums.UserType | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    lastname: number
    firstname: number
    avatar: number
    phone: number
    email: number
    password: number
    passwordless: number
    attemps: number
    blocked: number
    managed: number
    system: number
    loggedinDate: number
    type: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    attemps?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    attemps?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    firstname?: true
    avatar?: true
    phone?: true
    email?: true
    password?: true
    passwordless?: true
    attemps?: true
    blocked?: true
    managed?: true
    system?: true
    loggedinDate?: true
    type?: true
    createDate?: true
    updateDate?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    firstname?: true
    avatar?: true
    phone?: true
    email?: true
    password?: true
    passwordless?: true
    attemps?: true
    blocked?: true
    managed?: true
    system?: true
    loggedinDate?: true
    type?: true
    createDate?: true
    updateDate?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    lastname?: true
    firstname?: true
    avatar?: true
    phone?: true
    email?: true
    password?: true
    passwordless?: true
    attemps?: true
    blocked?: true
    managed?: true
    system?: true
    loggedinDate?: true
    type?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string | null
    lastname: string
    firstname: string
    avatar: string | null
    phone: string | null
    email: string
    password: string
    passwordless: boolean | null
    attemps: number | null
    blocked: boolean | null
    managed: boolean | null
    system: boolean | null
    loggedinDate: Date | null
    type: $Enums.UserType
    createDate: Date | null
    updateDate: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    lastname?: boolean
    firstname?: boolean
    avatar?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    passwordless?: boolean
    attemps?: boolean
    blocked?: boolean
    managed?: boolean
    system?: boolean
    loggedinDate?: boolean
    type?: boolean
    createDate?: boolean
    updateDate?: boolean
    address?: boolean | User$addressArgs<ExtArgs>
    policies?: boolean | User$policiesArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    account?: boolean | User$accountArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    pats?: boolean | User$patsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    lastname?: boolean
    firstname?: boolean
    avatar?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    passwordless?: boolean
    attemps?: boolean
    blocked?: boolean
    managed?: boolean
    system?: boolean
    loggedinDate?: boolean
    type?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    lastname?: boolean
    firstname?: boolean
    avatar?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    passwordless?: boolean
    attemps?: boolean
    blocked?: boolean
    managed?: boolean
    system?: boolean
    loggedinDate?: boolean
    type?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    lastname?: boolean
    firstname?: boolean
    avatar?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    passwordless?: boolean
    attemps?: boolean
    blocked?: boolean
    managed?: boolean
    system?: boolean
    loggedinDate?: boolean
    type?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "lastname" | "firstname" | "avatar" | "phone" | "email" | "password" | "passwordless" | "attemps" | "blocked" | "managed" | "system" | "loggedinDate" | "type" | "createDate" | "updateDate", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | User$addressArgs<ExtArgs>
    policies?: boolean | User$policiesArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    account?: boolean | User$accountArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    pats?: boolean | User$patsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs> | null
      policies: Prisma.$PolicyPayload<ExtArgs>[]
      roles: Prisma.$RolePayload<ExtArgs>[]
      groups: Prisma.$GroupPayload<ExtArgs>[]
      account: Prisma.$AccountPayload<ExtArgs> | null
      settings: Prisma.$UserSettingPayload<ExtArgs>[]
      pats: Prisma.$UserPATPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      lastname: string
      firstname: string
      avatar: string | null
      phone: string | null
      email: string
      password: string
      passwordless: boolean | null
      attemps: number | null
      blocked: boolean | null
      managed: boolean | null
      system: boolean | null
      loggedinDate: Date | null
      type: $Enums.UserType
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends User$addressArgs<ExtArgs> = {}>(args?: Subset<T, User$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    policies<T extends User$policiesArgs<ExtArgs> = {}>(args?: Subset<T, User$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends User$groupsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    account<T extends User$accountArgs<ExtArgs> = {}>(args?: Subset<T, User$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pats<T extends User$patsArgs<ExtArgs> = {}>(args?: Subset<T, User$patsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly lastname: FieldRef<"User", 'String'>
    readonly firstname: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly passwordless: FieldRef<"User", 'Boolean'>
    readonly attemps: FieldRef<"User", 'Int'>
    readonly blocked: FieldRef<"User", 'Boolean'>
    readonly managed: FieldRef<"User", 'Boolean'>
    readonly system: FieldRef<"User", 'Boolean'>
    readonly loggedinDate: FieldRef<"User", 'DateTime'>
    readonly type: FieldRef<"User", 'UserType'>
    readonly createDate: FieldRef<"User", 'DateTime'>
    readonly updateDate: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.address
   */
  export type User$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * User.policies
   */
  export type User$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * User.groups
   */
  export type User$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User.account
   */
  export type User$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    where?: UserSettingWhereInput
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    cursor?: UserSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * User.pats
   */
  export type User$patsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    where?: UserPATWhereInput
    orderBy?: UserPATOrderByWithRelationInput | UserPATOrderByWithRelationInput[]
    cursor?: UserPATWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPATScalarFieldEnum | UserPATScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPAT
   */

  export type AggregateUserPAT = {
    _count: UserPATCountAggregateOutputType | null
    _avg: UserPATAvgAggregateOutputType | null
    _sum: UserPATSumAggregateOutputType | null
    _min: UserPATMinAggregateOutputType | null
    _max: UserPATMaxAggregateOutputType | null
  }

  export type UserPATAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPATSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPATMinAggregateOutputType = {
    id: number | null
    tokenName: string | null
    token: string | null
    createDate: Date | null
    expirationDate: Date | null
    tokenStatus: $Enums.TokenStatus | null
    userId: number | null
  }

  export type UserPATMaxAggregateOutputType = {
    id: number | null
    tokenName: string | null
    token: string | null
    createDate: Date | null
    expirationDate: Date | null
    tokenStatus: $Enums.TokenStatus | null
    userId: number | null
  }

  export type UserPATCountAggregateOutputType = {
    id: number
    tokenName: number
    token: number
    createDate: number
    expirationDate: number
    tokenStatus: number
    userId: number
    _all: number
  }


  export type UserPATAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPATSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPATMinAggregateInputType = {
    id?: true
    tokenName?: true
    token?: true
    createDate?: true
    expirationDate?: true
    tokenStatus?: true
    userId?: true
  }

  export type UserPATMaxAggregateInputType = {
    id?: true
    tokenName?: true
    token?: true
    createDate?: true
    expirationDate?: true
    tokenStatus?: true
    userId?: true
  }

  export type UserPATCountAggregateInputType = {
    id?: true
    tokenName?: true
    token?: true
    createDate?: true
    expirationDate?: true
    tokenStatus?: true
    userId?: true
    _all?: true
  }

  export type UserPATAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPAT to aggregate.
     */
    where?: UserPATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPATS to fetch.
     */
    orderBy?: UserPATOrderByWithRelationInput | UserPATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPATS
    **/
    _count?: true | UserPATCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPATAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPATSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPATMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPATMaxAggregateInputType
  }

  export type GetUserPATAggregateType<T extends UserPATAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPAT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPAT[P]>
      : GetScalarType<T[P], AggregateUserPAT[P]>
  }




  export type UserPATGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPATWhereInput
    orderBy?: UserPATOrderByWithAggregationInput | UserPATOrderByWithAggregationInput[]
    by: UserPATScalarFieldEnum[] | UserPATScalarFieldEnum
    having?: UserPATScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPATCountAggregateInputType | true
    _avg?: UserPATAvgAggregateInputType
    _sum?: UserPATSumAggregateInputType
    _min?: UserPATMinAggregateInputType
    _max?: UserPATMaxAggregateInputType
  }

  export type UserPATGroupByOutputType = {
    id: number
    tokenName: string
    token: string
    createDate: Date | null
    expirationDate: Date
    tokenStatus: $Enums.TokenStatus
    userId: number
    _count: UserPATCountAggregateOutputType | null
    _avg: UserPATAvgAggregateOutputType | null
    _sum: UserPATSumAggregateOutputType | null
    _min: UserPATMinAggregateOutputType | null
    _max: UserPATMaxAggregateOutputType | null
  }

  type GetUserPATGroupByPayload<T extends UserPATGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPATGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPATGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPATGroupByOutputType[P]>
            : GetScalarType<T[P], UserPATGroupByOutputType[P]>
        }
      >
    >


  export type UserPATSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenName?: boolean
    token?: boolean
    createDate?: boolean
    expirationDate?: boolean
    tokenStatus?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPAT"]>

  export type UserPATSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenName?: boolean
    token?: boolean
    createDate?: boolean
    expirationDate?: boolean
    tokenStatus?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPAT"]>

  export type UserPATSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenName?: boolean
    token?: boolean
    createDate?: boolean
    expirationDate?: boolean
    tokenStatus?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPAT"]>

  export type UserPATSelectScalar = {
    id?: boolean
    tokenName?: boolean
    token?: boolean
    createDate?: boolean
    expirationDate?: boolean
    tokenStatus?: boolean
    userId?: boolean
  }

  export type UserPATOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenName" | "token" | "createDate" | "expirationDate" | "tokenStatus" | "userId", ExtArgs["result"]["userPAT"]>
  export type UserPATInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPATIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPATIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPATPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPAT"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tokenName: string
      token: string
      createDate: Date | null
      expirationDate: Date
      tokenStatus: $Enums.TokenStatus
      userId: number
    }, ExtArgs["result"]["userPAT"]>
    composites: {}
  }

  type UserPATGetPayload<S extends boolean | null | undefined | UserPATDefaultArgs> = $Result.GetResult<Prisma.$UserPATPayload, S>

  type UserPATCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPATFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPATCountAggregateInputType | true
    }

  export interface UserPATDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPAT'], meta: { name: 'UserPAT' } }
    /**
     * Find zero or one UserPAT that matches the filter.
     * @param {UserPATFindUniqueArgs} args - Arguments to find a UserPAT
     * @example
     * // Get one UserPAT
     * const userPAT = await prisma.userPAT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPATFindUniqueArgs>(args: SelectSubset<T, UserPATFindUniqueArgs<ExtArgs>>): Prisma__UserPATClient<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPAT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPATFindUniqueOrThrowArgs} args - Arguments to find a UserPAT
     * @example
     * // Get one UserPAT
     * const userPAT = await prisma.userPAT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPATFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPATFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPATClient<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPAT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPATFindFirstArgs} args - Arguments to find a UserPAT
     * @example
     * // Get one UserPAT
     * const userPAT = await prisma.userPAT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPATFindFirstArgs>(args?: SelectSubset<T, UserPATFindFirstArgs<ExtArgs>>): Prisma__UserPATClient<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPAT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPATFindFirstOrThrowArgs} args - Arguments to find a UserPAT
     * @example
     * // Get one UserPAT
     * const userPAT = await prisma.userPAT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPATFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPATFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPATClient<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPATS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPATFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPATS
     * const userPATS = await prisma.userPAT.findMany()
     * 
     * // Get first 10 UserPATS
     * const userPATS = await prisma.userPAT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPATWithIdOnly = await prisma.userPAT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPATFindManyArgs>(args?: SelectSubset<T, UserPATFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPAT.
     * @param {UserPATCreateArgs} args - Arguments to create a UserPAT.
     * @example
     * // Create one UserPAT
     * const UserPAT = await prisma.userPAT.create({
     *   data: {
     *     // ... data to create a UserPAT
     *   }
     * })
     * 
     */
    create<T extends UserPATCreateArgs>(args: SelectSubset<T, UserPATCreateArgs<ExtArgs>>): Prisma__UserPATClient<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPATS.
     * @param {UserPATCreateManyArgs} args - Arguments to create many UserPATS.
     * @example
     * // Create many UserPATS
     * const userPAT = await prisma.userPAT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPATCreateManyArgs>(args?: SelectSubset<T, UserPATCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPATS and returns the data saved in the database.
     * @param {UserPATCreateManyAndReturnArgs} args - Arguments to create many UserPATS.
     * @example
     * // Create many UserPATS
     * const userPAT = await prisma.userPAT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPATS and only return the `id`
     * const userPATWithIdOnly = await prisma.userPAT.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPATCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPATCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPAT.
     * @param {UserPATDeleteArgs} args - Arguments to delete one UserPAT.
     * @example
     * // Delete one UserPAT
     * const UserPAT = await prisma.userPAT.delete({
     *   where: {
     *     // ... filter to delete one UserPAT
     *   }
     * })
     * 
     */
    delete<T extends UserPATDeleteArgs>(args: SelectSubset<T, UserPATDeleteArgs<ExtArgs>>): Prisma__UserPATClient<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPAT.
     * @param {UserPATUpdateArgs} args - Arguments to update one UserPAT.
     * @example
     * // Update one UserPAT
     * const userPAT = await prisma.userPAT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPATUpdateArgs>(args: SelectSubset<T, UserPATUpdateArgs<ExtArgs>>): Prisma__UserPATClient<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPATS.
     * @param {UserPATDeleteManyArgs} args - Arguments to filter UserPATS to delete.
     * @example
     * // Delete a few UserPATS
     * const { count } = await prisma.userPAT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPATDeleteManyArgs>(args?: SelectSubset<T, UserPATDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPATS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPATUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPATS
     * const userPAT = await prisma.userPAT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPATUpdateManyArgs>(args: SelectSubset<T, UserPATUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPATS and returns the data updated in the database.
     * @param {UserPATUpdateManyAndReturnArgs} args - Arguments to update many UserPATS.
     * @example
     * // Update many UserPATS
     * const userPAT = await prisma.userPAT.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPATS and only return the `id`
     * const userPATWithIdOnly = await prisma.userPAT.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPATUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPATUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPAT.
     * @param {UserPATUpsertArgs} args - Arguments to update or create a UserPAT.
     * @example
     * // Update or create a UserPAT
     * const userPAT = await prisma.userPAT.upsert({
     *   create: {
     *     // ... data to create a UserPAT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPAT we want to update
     *   }
     * })
     */
    upsert<T extends UserPATUpsertArgs>(args: SelectSubset<T, UserPATUpsertArgs<ExtArgs>>): Prisma__UserPATClient<$Result.GetResult<Prisma.$UserPATPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPATS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPATCountArgs} args - Arguments to filter UserPATS to count.
     * @example
     * // Count the number of UserPATS
     * const count = await prisma.userPAT.count({
     *   where: {
     *     // ... the filter for the UserPATS we want to count
     *   }
     * })
    **/
    count<T extends UserPATCountArgs>(
      args?: Subset<T, UserPATCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPATCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPAT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPATAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPATAggregateArgs>(args: Subset<T, UserPATAggregateArgs>): Prisma.PrismaPromise<GetUserPATAggregateType<T>>

    /**
     * Group by UserPAT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPATGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPATGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPATGroupByArgs['orderBy'] }
        : { orderBy?: UserPATGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPATGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPATGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPAT model
   */
  readonly fields: UserPATFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPAT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPATClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPAT model
   */
  interface UserPATFieldRefs {
    readonly id: FieldRef<"UserPAT", 'Int'>
    readonly tokenName: FieldRef<"UserPAT", 'String'>
    readonly token: FieldRef<"UserPAT", 'String'>
    readonly createDate: FieldRef<"UserPAT", 'DateTime'>
    readonly expirationDate: FieldRef<"UserPAT", 'DateTime'>
    readonly tokenStatus: FieldRef<"UserPAT", 'TokenStatus'>
    readonly userId: FieldRef<"UserPAT", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserPAT findUnique
   */
  export type UserPATFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * Filter, which UserPAT to fetch.
     */
    where: UserPATWhereUniqueInput
  }

  /**
   * UserPAT findUniqueOrThrow
   */
  export type UserPATFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * Filter, which UserPAT to fetch.
     */
    where: UserPATWhereUniqueInput
  }

  /**
   * UserPAT findFirst
   */
  export type UserPATFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * Filter, which UserPAT to fetch.
     */
    where?: UserPATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPATS to fetch.
     */
    orderBy?: UserPATOrderByWithRelationInput | UserPATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPATS.
     */
    cursor?: UserPATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPATS.
     */
    distinct?: UserPATScalarFieldEnum | UserPATScalarFieldEnum[]
  }

  /**
   * UserPAT findFirstOrThrow
   */
  export type UserPATFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * Filter, which UserPAT to fetch.
     */
    where?: UserPATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPATS to fetch.
     */
    orderBy?: UserPATOrderByWithRelationInput | UserPATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPATS.
     */
    cursor?: UserPATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPATS.
     */
    distinct?: UserPATScalarFieldEnum | UserPATScalarFieldEnum[]
  }

  /**
   * UserPAT findMany
   */
  export type UserPATFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * Filter, which UserPATS to fetch.
     */
    where?: UserPATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPATS to fetch.
     */
    orderBy?: UserPATOrderByWithRelationInput | UserPATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPATS.
     */
    cursor?: UserPATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPATS.
     */
    skip?: number
    distinct?: UserPATScalarFieldEnum | UserPATScalarFieldEnum[]
  }

  /**
   * UserPAT create
   */
  export type UserPATCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPAT.
     */
    data: XOR<UserPATCreateInput, UserPATUncheckedCreateInput>
  }

  /**
   * UserPAT createMany
   */
  export type UserPATCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPATS.
     */
    data: UserPATCreateManyInput | UserPATCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPAT createManyAndReturn
   */
  export type UserPATCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * The data used to create many UserPATS.
     */
    data: UserPATCreateManyInput | UserPATCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPAT update
   */
  export type UserPATUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPAT.
     */
    data: XOR<UserPATUpdateInput, UserPATUncheckedUpdateInput>
    /**
     * Choose, which UserPAT to update.
     */
    where: UserPATWhereUniqueInput
  }

  /**
   * UserPAT updateMany
   */
  export type UserPATUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPATS.
     */
    data: XOR<UserPATUpdateManyMutationInput, UserPATUncheckedUpdateManyInput>
    /**
     * Filter which UserPATS to update
     */
    where?: UserPATWhereInput
    /**
     * Limit how many UserPATS to update.
     */
    limit?: number
  }

  /**
   * UserPAT updateManyAndReturn
   */
  export type UserPATUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * The data used to update UserPATS.
     */
    data: XOR<UserPATUpdateManyMutationInput, UserPATUncheckedUpdateManyInput>
    /**
     * Filter which UserPATS to update
     */
    where?: UserPATWhereInput
    /**
     * Limit how many UserPATS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPAT upsert
   */
  export type UserPATUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPAT to update in case it exists.
     */
    where: UserPATWhereUniqueInput
    /**
     * In case the UserPAT found by the `where` argument doesn't exist, create a new UserPAT with this data.
     */
    create: XOR<UserPATCreateInput, UserPATUncheckedCreateInput>
    /**
     * In case the UserPAT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPATUpdateInput, UserPATUncheckedUpdateInput>
  }

  /**
   * UserPAT delete
   */
  export type UserPATDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
    /**
     * Filter which UserPAT to delete.
     */
    where: UserPATWhereUniqueInput
  }

  /**
   * UserPAT deleteMany
   */
  export type UserPATDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPATS to delete
     */
    where?: UserPATWhereInput
    /**
     * Limit how many UserPATS to delete.
     */
    limit?: number
  }

  /**
   * UserPAT without action
   */
  export type UserPATDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPAT
     */
    select?: UserPATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPAT
     */
    omit?: UserPATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPATInclude<ExtArgs> | null
  }


  /**
   * Model UserSetting
   */

  export type AggregateUserSetting = {
    _count: UserSettingCountAggregateOutputType | null
    _avg: UserSettingAvgAggregateOutputType | null
    _sum: UserSettingSumAggregateOutputType | null
    _min: UserSettingMinAggregateOutputType | null
    _max: UserSettingMaxAggregateOutputType | null
  }

  export type UserSettingAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSettingSumAggregateOutputType = {
    id: number | null
  }

  export type UserSettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type UserSettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type UserSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type UserSettingAvgAggregateInputType = {
    id?: true
  }

  export type UserSettingSumAggregateInputType = {
    id?: true
  }

  export type UserSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type UserSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type UserSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type UserSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSetting to aggregate.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingMaxAggregateInputType
  }

  export type GetUserSettingAggregateType<T extends UserSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSetting[P]>
      : GetScalarType<T[P], AggregateUserSetting[P]>
  }




  export type UserSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingWhereInput
    orderBy?: UserSettingOrderByWithAggregationInput | UserSettingOrderByWithAggregationInput[]
    by: UserSettingScalarFieldEnum[] | UserSettingScalarFieldEnum
    having?: UserSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingCountAggregateInputType | true
    _avg?: UserSettingAvgAggregateInputType
    _sum?: UserSettingSumAggregateInputType
    _min?: UserSettingMinAggregateInputType
    _max?: UserSettingMaxAggregateInputType
  }

  export type UserSettingGroupByOutputType = {
    id: number
    key: string
    value: string
    _count: UserSettingCountAggregateOutputType | null
    _avg: UserSettingAvgAggregateOutputType | null
    _sum: UserSettingSumAggregateOutputType | null
    _min: UserSettingMinAggregateOutputType | null
    _max: UserSettingMaxAggregateOutputType | null
  }

  type GetUserSettingGroupByPayload<T extends UserSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    users?: boolean | UserSetting$usersArgs<ExtArgs>
    _count?: boolean | UserSettingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSetting"]>

  export type UserSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["userSetting"]>

  export type UserSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["userSetting"]>

  export type UserSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }

  export type UserSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value", ExtArgs["result"]["userSetting"]>
  export type UserSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserSetting$usersArgs<ExtArgs>
    _count?: boolean | UserSettingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSetting"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
    }, ExtArgs["result"]["userSetting"]>
    composites: {}
  }

  type UserSettingGetPayload<S extends boolean | null | undefined | UserSettingDefaultArgs> = $Result.GetResult<Prisma.$UserSettingPayload, S>

  type UserSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingCountAggregateInputType | true
    }

  export interface UserSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSetting'], meta: { name: 'UserSetting' } }
    /**
     * Find zero or one UserSetting that matches the filter.
     * @param {UserSettingFindUniqueArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingFindUniqueArgs>(args: SelectSubset<T, UserSettingFindUniqueArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingFindUniqueOrThrowArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindFirstArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingFindFirstArgs>(args?: SelectSubset<T, UserSettingFindFirstArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindFirstOrThrowArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSetting.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingWithIdOnly = await prisma.userSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingFindManyArgs>(args?: SelectSubset<T, UserSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSetting.
     * @param {UserSettingCreateArgs} args - Arguments to create a UserSetting.
     * @example
     * // Create one UserSetting
     * const UserSetting = await prisma.userSetting.create({
     *   data: {
     *     // ... data to create a UserSetting
     *   }
     * })
     * 
     */
    create<T extends UserSettingCreateArgs>(args: SelectSubset<T, UserSettingCreateArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSetting = await prisma.userSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingCreateManyArgs>(args?: SelectSubset<T, UserSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSetting = await prisma.userSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingWithIdOnly = await prisma.userSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSetting.
     * @param {UserSettingDeleteArgs} args - Arguments to delete one UserSetting.
     * @example
     * // Delete one UserSetting
     * const UserSetting = await prisma.userSetting.delete({
     *   where: {
     *     // ... filter to delete one UserSetting
     *   }
     * })
     * 
     */
    delete<T extends UserSettingDeleteArgs>(args: SelectSubset<T, UserSettingDeleteArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSetting.
     * @param {UserSettingUpdateArgs} args - Arguments to update one UserSetting.
     * @example
     * // Update one UserSetting
     * const userSetting = await prisma.userSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingUpdateArgs>(args: SelectSubset<T, UserSettingUpdateArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingDeleteManyArgs>(args?: SelectSubset<T, UserSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSetting = await prisma.userSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingUpdateManyArgs>(args: SelectSubset<T, UserSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSetting = await prisma.userSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingWithIdOnly = await prisma.userSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSetting.
     * @param {UserSettingUpsertArgs} args - Arguments to update or create a UserSetting.
     * @example
     * // Update or create a UserSetting
     * const userSetting = await prisma.userSetting.upsert({
     *   create: {
     *     // ... data to create a UserSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSetting we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingUpsertArgs>(args: SelectSubset<T, UserSettingUpsertArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSetting.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingCountArgs>(
      args?: Subset<T, UserSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingAggregateArgs>(args: Subset<T, UserSettingAggregateArgs>): Prisma.PrismaPromise<GetUserSettingAggregateType<T>>

    /**
     * Group by UserSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSetting model
   */
  readonly fields: UserSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserSetting$usersArgs<ExtArgs> = {}>(args?: Subset<T, UserSetting$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSetting model
   */
  interface UserSettingFieldRefs {
    readonly id: FieldRef<"UserSetting", 'Int'>
    readonly key: FieldRef<"UserSetting", 'String'>
    readonly value: FieldRef<"UserSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSetting findUnique
   */
  export type UserSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting findUniqueOrThrow
   */
  export type UserSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting findFirst
   */
  export type UserSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting findFirstOrThrow
   */
  export type UserSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting findMany
   */
  export type UserSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting create
   */
  export type UserSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSetting.
     */
    data: XOR<UserSettingCreateInput, UserSettingUncheckedCreateInput>
  }

  /**
   * UserSetting createMany
   */
  export type UserSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingCreateManyInput | UserSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSetting createManyAndReturn
   */
  export type UserSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingCreateManyInput | UserSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSetting update
   */
  export type UserSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSetting.
     */
    data: XOR<UserSettingUpdateInput, UserSettingUncheckedUpdateInput>
    /**
     * Choose, which UserSetting to update.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting updateMany
   */
  export type UserSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSetting updateManyAndReturn
   */
  export type UserSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSetting upsert
   */
  export type UserSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSetting to update in case it exists.
     */
    where: UserSettingWhereUniqueInput
    /**
     * In case the UserSetting found by the `where` argument doesn't exist, create a new UserSetting with this data.
     */
    create: XOR<UserSettingCreateInput, UserSettingUncheckedCreateInput>
    /**
     * In case the UserSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingUpdateInput, UserSettingUncheckedUpdateInput>
  }

  /**
   * UserSetting delete
   */
  export type UserSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter which UserSetting to delete.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting deleteMany
   */
  export type UserSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSetting.users
   */
  export type UserSetting$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * UserSetting without action
   */
  export type UserSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSetting
     */
    omit?: UserSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    managed: number
    system: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managed?: true
    system?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: number
    name: string
    description: string | null
    managed: boolean | null
    system: boolean | null
    createDate: Date | null
    updateDate: Date | null
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
    policies?: boolean | Group$policiesArgs<ExtArgs>
    roles?: boolean | Group$rolesArgs<ExtArgs>
    users?: boolean | Group$usersArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    managed?: boolean
    system?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "managed" | "system" | "createDate" | "updateDate", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policies?: boolean | Group$policiesArgs<ExtArgs>
    roles?: boolean | Group$rolesArgs<ExtArgs>
    users?: boolean | Group$usersArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      policies: Prisma.$PolicyPayload<ExtArgs>[]
      roles: Prisma.$RolePayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      managed: boolean | null
      system: boolean | null
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    policies<T extends Group$policiesArgs<ExtArgs> = {}>(args?: Subset<T, Group$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends Group$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Group$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Group$usersArgs<ExtArgs> = {}>(args?: Subset<T, Group$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'Int'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly managed: FieldRef<"Group", 'Boolean'>
    readonly system: FieldRef<"Group", 'Boolean'>
    readonly createDate: FieldRef<"Group", 'DateTime'>
    readonly updateDate: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.policies
   */
  export type Group$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Group.roles
   */
  export type Group$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Group.users
   */
  export type Group$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model Export
   */

  export type AggregateExport = {
    _count: ExportCountAggregateOutputType | null
    _avg: ExportAvgAggregateOutputType | null
    _sum: ExportSumAggregateOutputType | null
    _min: ExportMinAggregateOutputType | null
    _max: ExportMaxAggregateOutputType | null
  }

  export type ExportAvgAggregateOutputType = {
    id: number | null
  }

  export type ExportSumAggregateOutputType = {
    id: number | null
  }

  export type ExportMinAggregateOutputType = {
    id: number | null
    name: string | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type ExportMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type ExportCountAggregateOutputType = {
    id: number
    name: number
    content: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type ExportAvgAggregateInputType = {
    id?: true
  }

  export type ExportSumAggregateInputType = {
    id?: true
  }

  export type ExportMinAggregateInputType = {
    id?: true
    name?: true
    createDate?: true
    updateDate?: true
  }

  export type ExportMaxAggregateInputType = {
    id?: true
    name?: true
    createDate?: true
    updateDate?: true
  }

  export type ExportCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type ExportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Export to aggregate.
     */
    where?: ExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exports to fetch.
     */
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exports
    **/
    _count?: true | ExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportMaxAggregateInputType
  }

  export type GetExportAggregateType<T extends ExportAggregateArgs> = {
        [P in keyof T & keyof AggregateExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExport[P]>
      : GetScalarType<T[P], AggregateExport[P]>
  }




  export type ExportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportWhereInput
    orderBy?: ExportOrderByWithAggregationInput | ExportOrderByWithAggregationInput[]
    by: ExportScalarFieldEnum[] | ExportScalarFieldEnum
    having?: ExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportCountAggregateInputType | true
    _avg?: ExportAvgAggregateInputType
    _sum?: ExportSumAggregateInputType
    _min?: ExportMinAggregateInputType
    _max?: ExportMaxAggregateInputType
  }

  export type ExportGroupByOutputType = {
    id: number
    name: string
    content: JsonValue
    createDate: Date | null
    updateDate: Date | null
    _count: ExportCountAggregateOutputType | null
    _avg: ExportAvgAggregateOutputType | null
    _sum: ExportSumAggregateOutputType | null
    _min: ExportMinAggregateOutputType | null
    _max: ExportMaxAggregateOutputType | null
  }

  type GetExportGroupByPayload<T extends ExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportGroupByOutputType[P]>
            : GetScalarType<T[P], ExportGroupByOutputType[P]>
        }
      >
    >


  export type ExportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["export"]>

  export type ExportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["export"]>

  export type ExportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["export"]>

  export type ExportSelectScalar = {
    id?: boolean
    name?: boolean
    content?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type ExportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "content" | "createDate" | "updateDate", ExtArgs["result"]["export"]>

  export type $ExportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Export"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      content: Prisma.JsonValue
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["export"]>
    composites: {}
  }

  type ExportGetPayload<S extends boolean | null | undefined | ExportDefaultArgs> = $Result.GetResult<Prisma.$ExportPayload, S>

  type ExportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExportCountAggregateInputType | true
    }

  export interface ExportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Export'], meta: { name: 'Export' } }
    /**
     * Find zero or one Export that matches the filter.
     * @param {ExportFindUniqueArgs} args - Arguments to find a Export
     * @example
     * // Get one Export
     * const export = await prisma.export.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportFindUniqueArgs>(args: SelectSubset<T, ExportFindUniqueArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Export that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExportFindUniqueOrThrowArgs} args - Arguments to find a Export
     * @example
     * // Get one Export
     * const export = await prisma.export.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Export that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportFindFirstArgs} args - Arguments to find a Export
     * @example
     * // Get one Export
     * const export = await prisma.export.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportFindFirstArgs>(args?: SelectSubset<T, ExportFindFirstArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Export that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportFindFirstOrThrowArgs} args - Arguments to find a Export
     * @example
     * // Get one Export
     * const export = await prisma.export.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exports
     * const exports = await prisma.export.findMany()
     * 
     * // Get first 10 Exports
     * const exports = await prisma.export.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportWithIdOnly = await prisma.export.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportFindManyArgs>(args?: SelectSubset<T, ExportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Export.
     * @param {ExportCreateArgs} args - Arguments to create a Export.
     * @example
     * // Create one Export
     * const Export = await prisma.export.create({
     *   data: {
     *     // ... data to create a Export
     *   }
     * })
     * 
     */
    create<T extends ExportCreateArgs>(args: SelectSubset<T, ExportCreateArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exports.
     * @param {ExportCreateManyArgs} args - Arguments to create many Exports.
     * @example
     * // Create many Exports
     * const export = await prisma.export.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportCreateManyArgs>(args?: SelectSubset<T, ExportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exports and returns the data saved in the database.
     * @param {ExportCreateManyAndReturnArgs} args - Arguments to create many Exports.
     * @example
     * // Create many Exports
     * const export = await prisma.export.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exports and only return the `id`
     * const exportWithIdOnly = await prisma.export.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Export.
     * @param {ExportDeleteArgs} args - Arguments to delete one Export.
     * @example
     * // Delete one Export
     * const Export = await prisma.export.delete({
     *   where: {
     *     // ... filter to delete one Export
     *   }
     * })
     * 
     */
    delete<T extends ExportDeleteArgs>(args: SelectSubset<T, ExportDeleteArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Export.
     * @param {ExportUpdateArgs} args - Arguments to update one Export.
     * @example
     * // Update one Export
     * const export = await prisma.export.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportUpdateArgs>(args: SelectSubset<T, ExportUpdateArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exports.
     * @param {ExportDeleteManyArgs} args - Arguments to filter Exports to delete.
     * @example
     * // Delete a few Exports
     * const { count } = await prisma.export.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportDeleteManyArgs>(args?: SelectSubset<T, ExportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exports
     * const export = await prisma.export.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportUpdateManyArgs>(args: SelectSubset<T, ExportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exports and returns the data updated in the database.
     * @param {ExportUpdateManyAndReturnArgs} args - Arguments to update many Exports.
     * @example
     * // Update many Exports
     * const export = await prisma.export.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exports and only return the `id`
     * const exportWithIdOnly = await prisma.export.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExportUpdateManyAndReturnArgs>(args: SelectSubset<T, ExportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Export.
     * @param {ExportUpsertArgs} args - Arguments to update or create a Export.
     * @example
     * // Update or create a Export
     * const export = await prisma.export.upsert({
     *   create: {
     *     // ... data to create a Export
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Export we want to update
     *   }
     * })
     */
    upsert<T extends ExportUpsertArgs>(args: SelectSubset<T, ExportUpsertArgs<ExtArgs>>): Prisma__ExportClient<$Result.GetResult<Prisma.$ExportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportCountArgs} args - Arguments to filter Exports to count.
     * @example
     * // Count the number of Exports
     * const count = await prisma.export.count({
     *   where: {
     *     // ... the filter for the Exports we want to count
     *   }
     * })
    **/
    count<T extends ExportCountArgs>(
      args?: Subset<T, ExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Export.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportAggregateArgs>(args: Subset<T, ExportAggregateArgs>): Prisma.PrismaPromise<GetExportAggregateType<T>>

    /**
     * Group by Export.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportGroupByArgs['orderBy'] }
        : { orderBy?: ExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Export model
   */
  readonly fields: ExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Export.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Export model
   */
  interface ExportFieldRefs {
    readonly id: FieldRef<"Export", 'Int'>
    readonly name: FieldRef<"Export", 'String'>
    readonly content: FieldRef<"Export", 'Json'>
    readonly createDate: FieldRef<"Export", 'DateTime'>
    readonly updateDate: FieldRef<"Export", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Export findUnique
   */
  export type ExportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * Filter, which Export to fetch.
     */
    where: ExportWhereUniqueInput
  }

  /**
   * Export findUniqueOrThrow
   */
  export type ExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * Filter, which Export to fetch.
     */
    where: ExportWhereUniqueInput
  }

  /**
   * Export findFirst
   */
  export type ExportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * Filter, which Export to fetch.
     */
    where?: ExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exports to fetch.
     */
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exports.
     */
    cursor?: ExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exports.
     */
    distinct?: ExportScalarFieldEnum | ExportScalarFieldEnum[]
  }

  /**
   * Export findFirstOrThrow
   */
  export type ExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * Filter, which Export to fetch.
     */
    where?: ExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exports to fetch.
     */
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exports.
     */
    cursor?: ExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exports.
     */
    distinct?: ExportScalarFieldEnum | ExportScalarFieldEnum[]
  }

  /**
   * Export findMany
   */
  export type ExportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * Filter, which Exports to fetch.
     */
    where?: ExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exports to fetch.
     */
    orderBy?: ExportOrderByWithRelationInput | ExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exports.
     */
    cursor?: ExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exports.
     */
    skip?: number
    distinct?: ExportScalarFieldEnum | ExportScalarFieldEnum[]
  }

  /**
   * Export create
   */
  export type ExportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * The data needed to create a Export.
     */
    data: XOR<ExportCreateInput, ExportUncheckedCreateInput>
  }

  /**
   * Export createMany
   */
  export type ExportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exports.
     */
    data: ExportCreateManyInput | ExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Export createManyAndReturn
   */
  export type ExportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * The data used to create many Exports.
     */
    data: ExportCreateManyInput | ExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Export update
   */
  export type ExportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * The data needed to update a Export.
     */
    data: XOR<ExportUpdateInput, ExportUncheckedUpdateInput>
    /**
     * Choose, which Export to update.
     */
    where: ExportWhereUniqueInput
  }

  /**
   * Export updateMany
   */
  export type ExportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exports.
     */
    data: XOR<ExportUpdateManyMutationInput, ExportUncheckedUpdateManyInput>
    /**
     * Filter which Exports to update
     */
    where?: ExportWhereInput
    /**
     * Limit how many Exports to update.
     */
    limit?: number
  }

  /**
   * Export updateManyAndReturn
   */
  export type ExportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * The data used to update Exports.
     */
    data: XOR<ExportUpdateManyMutationInput, ExportUncheckedUpdateManyInput>
    /**
     * Filter which Exports to update
     */
    where?: ExportWhereInput
    /**
     * Limit how many Exports to update.
     */
    limit?: number
  }

  /**
   * Export upsert
   */
  export type ExportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * The filter to search for the Export to update in case it exists.
     */
    where: ExportWhereUniqueInput
    /**
     * In case the Export found by the `where` argument doesn't exist, create a new Export with this data.
     */
    create: XOR<ExportCreateInput, ExportUncheckedCreateInput>
    /**
     * In case the Export was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportUpdateInput, ExportUncheckedUpdateInput>
  }

  /**
   * Export delete
   */
  export type ExportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
    /**
     * Filter which Export to delete.
     */
    where: ExportWhereUniqueInput
  }

  /**
   * Export deleteMany
   */
  export type ExportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exports to delete
     */
    where?: ExportWhereInput
    /**
     * Limit how many Exports to delete.
     */
    limit?: number
  }

  /**
   * Export without action
   */
  export type ExportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Export
     */
    select?: ExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Export
     */
    omit?: ExportOmit<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    amount: number | null
    userId: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    amount: number | null
    status: $Enums.AccountStatus | null
    userId: number | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    status: $Enums.AccountStatus | null
    userId: number | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    amount: number
    status: number
    userId: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    amount?: true
    userId?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    userId?: true
    createDate?: true
    updateDate?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    userId?: true
    createDate?: true
    updateDate?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    userId?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    amount: number
    status: $Enums.AccountStatus
    userId: number | null
    createDate: Date
    updateDate: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createDate?: boolean
    updateDate?: boolean
    user?: boolean | Account$userArgs<ExtArgs>
    sendertransactions?: boolean | Account$sendertransactionsArgs<ExtArgs>
    receivertransactions?: boolean | Account$receivertransactionsArgs<ExtArgs>
    bankaccounts?: boolean | Account$bankaccountsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createDate?: boolean
    updateDate?: boolean
    user?: boolean | Account$userArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createDate?: boolean
    updateDate?: boolean
    user?: boolean | Account$userArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "status" | "userId" | "createDate" | "updateDate", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Account$userArgs<ExtArgs>
    sendertransactions?: boolean | Account$sendertransactionsArgs<ExtArgs>
    receivertransactions?: boolean | Account$receivertransactionsArgs<ExtArgs>
    bankaccounts?: boolean | Account$bankaccountsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Account$userArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Account$userArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      sendertransactions: Prisma.$TransactionPayload<ExtArgs>[]
      receivertransactions: Prisma.$TransactionPayload<ExtArgs>[]
      bankaccounts: Prisma.$BankAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      status: $Enums.AccountStatus
      userId: number | null
      createDate: Date
      updateDate: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Account$userArgs<ExtArgs> = {}>(args?: Subset<T, Account$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sendertransactions<T extends Account$sendertransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$sendertransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivertransactions<T extends Account$receivertransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$receivertransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bankaccounts<T extends Account$bankaccountsArgs<ExtArgs> = {}>(args?: Subset<T, Account$bankaccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly amount: FieldRef<"Account", 'Float'>
    readonly status: FieldRef<"Account", 'AccountStatus'>
    readonly userId: FieldRef<"Account", 'Int'>
    readonly createDate: FieldRef<"Account", 'DateTime'>
    readonly updateDate: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.user
   */
  export type Account$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Account.sendertransactions
   */
  export type Account$sendertransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account.receivertransactions
   */
  export type Account$receivertransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account.bankaccounts
   */
  export type Account$bankaccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    cursor?: BankAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model AccountApply
   */

  export type AggregateAccountApply = {
    _count: AccountApplyCountAggregateOutputType | null
    _avg: AccountApplyAvgAggregateOutputType | null
    _sum: AccountApplySumAggregateOutputType | null
    _min: AccountApplyMinAggregateOutputType | null
    _max: AccountApplyMaxAggregateOutputType | null
  }

  export type AccountApplyAvgAggregateOutputType = {
    id: number | null
  }

  export type AccountApplySumAggregateOutputType = {
    id: number | null
  }

  export type AccountApplyMinAggregateOutputType = {
    id: number | null
    username: string | null
    firstname: string | null
    lastname: string | null
    password: string | null
    email: string | null
    country: string | null
    gender: $Enums.Gender | null
    status: $Enums.AccountApplyStatus | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type AccountApplyMaxAggregateOutputType = {
    id: number | null
    username: string | null
    firstname: string | null
    lastname: string | null
    password: string | null
    email: string | null
    country: string | null
    gender: $Enums.Gender | null
    status: $Enums.AccountApplyStatus | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type AccountApplyCountAggregateOutputType = {
    id: number
    username: number
    firstname: number
    lastname: number
    password: number
    email: number
    country: number
    gender: number
    status: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type AccountApplyAvgAggregateInputType = {
    id?: true
  }

  export type AccountApplySumAggregateInputType = {
    id?: true
  }

  export type AccountApplyMinAggregateInputType = {
    id?: true
    username?: true
    firstname?: true
    lastname?: true
    password?: true
    email?: true
    country?: true
    gender?: true
    status?: true
    createDate?: true
    updateDate?: true
  }

  export type AccountApplyMaxAggregateInputType = {
    id?: true
    username?: true
    firstname?: true
    lastname?: true
    password?: true
    email?: true
    country?: true
    gender?: true
    status?: true
    createDate?: true
    updateDate?: true
  }

  export type AccountApplyCountAggregateInputType = {
    id?: true
    username?: true
    firstname?: true
    lastname?: true
    password?: true
    email?: true
    country?: true
    gender?: true
    status?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type AccountApplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountApply to aggregate.
     */
    where?: AccountApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountApplies to fetch.
     */
    orderBy?: AccountApplyOrderByWithRelationInput | AccountApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountApplies
    **/
    _count?: true | AccountApplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountApplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountApplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountApplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountApplyMaxAggregateInputType
  }

  export type GetAccountApplyAggregateType<T extends AccountApplyAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountApply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountApply[P]>
      : GetScalarType<T[P], AggregateAccountApply[P]>
  }




  export type AccountApplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountApplyWhereInput
    orderBy?: AccountApplyOrderByWithAggregationInput | AccountApplyOrderByWithAggregationInput[]
    by: AccountApplyScalarFieldEnum[] | AccountApplyScalarFieldEnum
    having?: AccountApplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountApplyCountAggregateInputType | true
    _avg?: AccountApplyAvgAggregateInputType
    _sum?: AccountApplySumAggregateInputType
    _min?: AccountApplyMinAggregateInputType
    _max?: AccountApplyMaxAggregateInputType
  }

  export type AccountApplyGroupByOutputType = {
    id: number
    username: string | null
    firstname: string
    lastname: string
    password: string
    email: string
    country: string
    gender: $Enums.Gender | null
    status: $Enums.AccountApplyStatus
    createDate: Date | null
    updateDate: Date | null
    _count: AccountApplyCountAggregateOutputType | null
    _avg: AccountApplyAvgAggregateOutputType | null
    _sum: AccountApplySumAggregateOutputType | null
    _min: AccountApplyMinAggregateOutputType | null
    _max: AccountApplyMaxAggregateOutputType | null
  }

  type GetAccountApplyGroupByPayload<T extends AccountApplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountApplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountApplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountApplyGroupByOutputType[P]>
            : GetScalarType<T[P], AccountApplyGroupByOutputType[P]>
        }
      >
    >


  export type AccountApplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    firstname?: boolean
    lastname?: boolean
    password?: boolean
    email?: boolean
    country?: boolean
    gender?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["accountApply"]>

  export type AccountApplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    firstname?: boolean
    lastname?: boolean
    password?: boolean
    email?: boolean
    country?: boolean
    gender?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["accountApply"]>

  export type AccountApplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    firstname?: boolean
    lastname?: boolean
    password?: boolean
    email?: boolean
    country?: boolean
    gender?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["accountApply"]>

  export type AccountApplySelectScalar = {
    id?: boolean
    username?: boolean
    firstname?: boolean
    lastname?: boolean
    password?: boolean
    email?: boolean
    country?: boolean
    gender?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type AccountApplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "firstname" | "lastname" | "password" | "email" | "country" | "gender" | "status" | "createDate" | "updateDate", ExtArgs["result"]["accountApply"]>

  export type $AccountApplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountApply"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      firstname: string
      lastname: string
      password: string
      email: string
      country: string
      gender: $Enums.Gender | null
      status: $Enums.AccountApplyStatus
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["accountApply"]>
    composites: {}
  }

  type AccountApplyGetPayload<S extends boolean | null | undefined | AccountApplyDefaultArgs> = $Result.GetResult<Prisma.$AccountApplyPayload, S>

  type AccountApplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountApplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountApplyCountAggregateInputType | true
    }

  export interface AccountApplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountApply'], meta: { name: 'AccountApply' } }
    /**
     * Find zero or one AccountApply that matches the filter.
     * @param {AccountApplyFindUniqueArgs} args - Arguments to find a AccountApply
     * @example
     * // Get one AccountApply
     * const accountApply = await prisma.accountApply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountApplyFindUniqueArgs>(args: SelectSubset<T, AccountApplyFindUniqueArgs<ExtArgs>>): Prisma__AccountApplyClient<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountApply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountApplyFindUniqueOrThrowArgs} args - Arguments to find a AccountApply
     * @example
     * // Get one AccountApply
     * const accountApply = await prisma.accountApply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountApplyFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountApplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountApplyClient<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountApply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountApplyFindFirstArgs} args - Arguments to find a AccountApply
     * @example
     * // Get one AccountApply
     * const accountApply = await prisma.accountApply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountApplyFindFirstArgs>(args?: SelectSubset<T, AccountApplyFindFirstArgs<ExtArgs>>): Prisma__AccountApplyClient<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountApply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountApplyFindFirstOrThrowArgs} args - Arguments to find a AccountApply
     * @example
     * // Get one AccountApply
     * const accountApply = await prisma.accountApply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountApplyFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountApplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountApplyClient<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountApplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountApplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountApplies
     * const accountApplies = await prisma.accountApply.findMany()
     * 
     * // Get first 10 AccountApplies
     * const accountApplies = await prisma.accountApply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountApplyWithIdOnly = await prisma.accountApply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountApplyFindManyArgs>(args?: SelectSubset<T, AccountApplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountApply.
     * @param {AccountApplyCreateArgs} args - Arguments to create a AccountApply.
     * @example
     * // Create one AccountApply
     * const AccountApply = await prisma.accountApply.create({
     *   data: {
     *     // ... data to create a AccountApply
     *   }
     * })
     * 
     */
    create<T extends AccountApplyCreateArgs>(args: SelectSubset<T, AccountApplyCreateArgs<ExtArgs>>): Prisma__AccountApplyClient<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountApplies.
     * @param {AccountApplyCreateManyArgs} args - Arguments to create many AccountApplies.
     * @example
     * // Create many AccountApplies
     * const accountApply = await prisma.accountApply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountApplyCreateManyArgs>(args?: SelectSubset<T, AccountApplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountApplies and returns the data saved in the database.
     * @param {AccountApplyCreateManyAndReturnArgs} args - Arguments to create many AccountApplies.
     * @example
     * // Create many AccountApplies
     * const accountApply = await prisma.accountApply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountApplies and only return the `id`
     * const accountApplyWithIdOnly = await prisma.accountApply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountApplyCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountApplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccountApply.
     * @param {AccountApplyDeleteArgs} args - Arguments to delete one AccountApply.
     * @example
     * // Delete one AccountApply
     * const AccountApply = await prisma.accountApply.delete({
     *   where: {
     *     // ... filter to delete one AccountApply
     *   }
     * })
     * 
     */
    delete<T extends AccountApplyDeleteArgs>(args: SelectSubset<T, AccountApplyDeleteArgs<ExtArgs>>): Prisma__AccountApplyClient<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountApply.
     * @param {AccountApplyUpdateArgs} args - Arguments to update one AccountApply.
     * @example
     * // Update one AccountApply
     * const accountApply = await prisma.accountApply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountApplyUpdateArgs>(args: SelectSubset<T, AccountApplyUpdateArgs<ExtArgs>>): Prisma__AccountApplyClient<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountApplies.
     * @param {AccountApplyDeleteManyArgs} args - Arguments to filter AccountApplies to delete.
     * @example
     * // Delete a few AccountApplies
     * const { count } = await prisma.accountApply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountApplyDeleteManyArgs>(args?: SelectSubset<T, AccountApplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountApplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountApplies
     * const accountApply = await prisma.accountApply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountApplyUpdateManyArgs>(args: SelectSubset<T, AccountApplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountApplies and returns the data updated in the database.
     * @param {AccountApplyUpdateManyAndReturnArgs} args - Arguments to update many AccountApplies.
     * @example
     * // Update many AccountApplies
     * const accountApply = await prisma.accountApply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccountApplies and only return the `id`
     * const accountApplyWithIdOnly = await prisma.accountApply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountApplyUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountApplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccountApply.
     * @param {AccountApplyUpsertArgs} args - Arguments to update or create a AccountApply.
     * @example
     * // Update or create a AccountApply
     * const accountApply = await prisma.accountApply.upsert({
     *   create: {
     *     // ... data to create a AccountApply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountApply we want to update
     *   }
     * })
     */
    upsert<T extends AccountApplyUpsertArgs>(args: SelectSubset<T, AccountApplyUpsertArgs<ExtArgs>>): Prisma__AccountApplyClient<$Result.GetResult<Prisma.$AccountApplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountApplyCountArgs} args - Arguments to filter AccountApplies to count.
     * @example
     * // Count the number of AccountApplies
     * const count = await prisma.accountApply.count({
     *   where: {
     *     // ... the filter for the AccountApplies we want to count
     *   }
     * })
    **/
    count<T extends AccountApplyCountArgs>(
      args?: Subset<T, AccountApplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountApplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountApplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountApplyAggregateArgs>(args: Subset<T, AccountApplyAggregateArgs>): Prisma.PrismaPromise<GetAccountApplyAggregateType<T>>

    /**
     * Group by AccountApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountApplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountApplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountApplyGroupByArgs['orderBy'] }
        : { orderBy?: AccountApplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountApplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountApplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountApply model
   */
  readonly fields: AccountApplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountApply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountApplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountApply model
   */
  interface AccountApplyFieldRefs {
    readonly id: FieldRef<"AccountApply", 'Int'>
    readonly username: FieldRef<"AccountApply", 'String'>
    readonly firstname: FieldRef<"AccountApply", 'String'>
    readonly lastname: FieldRef<"AccountApply", 'String'>
    readonly password: FieldRef<"AccountApply", 'String'>
    readonly email: FieldRef<"AccountApply", 'String'>
    readonly country: FieldRef<"AccountApply", 'String'>
    readonly gender: FieldRef<"AccountApply", 'Gender'>
    readonly status: FieldRef<"AccountApply", 'AccountApplyStatus'>
    readonly createDate: FieldRef<"AccountApply", 'DateTime'>
    readonly updateDate: FieldRef<"AccountApply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountApply findUnique
   */
  export type AccountApplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * Filter, which AccountApply to fetch.
     */
    where: AccountApplyWhereUniqueInput
  }

  /**
   * AccountApply findUniqueOrThrow
   */
  export type AccountApplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * Filter, which AccountApply to fetch.
     */
    where: AccountApplyWhereUniqueInput
  }

  /**
   * AccountApply findFirst
   */
  export type AccountApplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * Filter, which AccountApply to fetch.
     */
    where?: AccountApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountApplies to fetch.
     */
    orderBy?: AccountApplyOrderByWithRelationInput | AccountApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountApplies.
     */
    cursor?: AccountApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountApplies.
     */
    distinct?: AccountApplyScalarFieldEnum | AccountApplyScalarFieldEnum[]
  }

  /**
   * AccountApply findFirstOrThrow
   */
  export type AccountApplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * Filter, which AccountApply to fetch.
     */
    where?: AccountApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountApplies to fetch.
     */
    orderBy?: AccountApplyOrderByWithRelationInput | AccountApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountApplies.
     */
    cursor?: AccountApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountApplies.
     */
    distinct?: AccountApplyScalarFieldEnum | AccountApplyScalarFieldEnum[]
  }

  /**
   * AccountApply findMany
   */
  export type AccountApplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * Filter, which AccountApplies to fetch.
     */
    where?: AccountApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountApplies to fetch.
     */
    orderBy?: AccountApplyOrderByWithRelationInput | AccountApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountApplies.
     */
    cursor?: AccountApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountApplies.
     */
    skip?: number
    distinct?: AccountApplyScalarFieldEnum | AccountApplyScalarFieldEnum[]
  }

  /**
   * AccountApply create
   */
  export type AccountApplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * The data needed to create a AccountApply.
     */
    data: XOR<AccountApplyCreateInput, AccountApplyUncheckedCreateInput>
  }

  /**
   * AccountApply createMany
   */
  export type AccountApplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountApplies.
     */
    data: AccountApplyCreateManyInput | AccountApplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountApply createManyAndReturn
   */
  export type AccountApplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * The data used to create many AccountApplies.
     */
    data: AccountApplyCreateManyInput | AccountApplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountApply update
   */
  export type AccountApplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * The data needed to update a AccountApply.
     */
    data: XOR<AccountApplyUpdateInput, AccountApplyUncheckedUpdateInput>
    /**
     * Choose, which AccountApply to update.
     */
    where: AccountApplyWhereUniqueInput
  }

  /**
   * AccountApply updateMany
   */
  export type AccountApplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountApplies.
     */
    data: XOR<AccountApplyUpdateManyMutationInput, AccountApplyUncheckedUpdateManyInput>
    /**
     * Filter which AccountApplies to update
     */
    where?: AccountApplyWhereInput
    /**
     * Limit how many AccountApplies to update.
     */
    limit?: number
  }

  /**
   * AccountApply updateManyAndReturn
   */
  export type AccountApplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * The data used to update AccountApplies.
     */
    data: XOR<AccountApplyUpdateManyMutationInput, AccountApplyUncheckedUpdateManyInput>
    /**
     * Filter which AccountApplies to update
     */
    where?: AccountApplyWhereInput
    /**
     * Limit how many AccountApplies to update.
     */
    limit?: number
  }

  /**
   * AccountApply upsert
   */
  export type AccountApplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * The filter to search for the AccountApply to update in case it exists.
     */
    where: AccountApplyWhereUniqueInput
    /**
     * In case the AccountApply found by the `where` argument doesn't exist, create a new AccountApply with this data.
     */
    create: XOR<AccountApplyCreateInput, AccountApplyUncheckedCreateInput>
    /**
     * In case the AccountApply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountApplyUpdateInput, AccountApplyUncheckedUpdateInput>
  }

  /**
   * AccountApply delete
   */
  export type AccountApplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
    /**
     * Filter which AccountApply to delete.
     */
    where: AccountApplyWhereUniqueInput
  }

  /**
   * AccountApply deleteMany
   */
  export type AccountApplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountApplies to delete
     */
    where?: AccountApplyWhereInput
    /**
     * Limit how many AccountApplies to delete.
     */
    limit?: number
  }

  /**
   * AccountApply without action
   */
  export type AccountApplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountApply
     */
    select?: AccountApplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountApply
     */
    omit?: AccountApplyOmit<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    predecessorTaskId: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    predecessorTaskId: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    predecessorTaskId: number | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    predecessorTaskId: number | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    params: number
    fromStatus: number
    predecessorTaskId: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    predecessorTaskId?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    predecessorTaskId?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    predecessorTaskId?: true
    createDate?: true
    updateDate?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    predecessorTaskId?: true
    createDate?: true
    updateDate?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    params?: true
    fromStatus?: true
    predecessorTaskId?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: number
    name: string
    description: string
    status: $Enums.TaskStatus
    params: JsonValue
    fromStatus: $Enums.TaskStatus[]
    predecessorTaskId: number | null
    createDate: Date | null
    updateDate: Date | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    params?: boolean
    fromStatus?: boolean
    predecessorTaskId?: boolean
    createDate?: boolean
    updateDate?: boolean
    predecessorTask?: boolean | Task$predecessorTaskArgs<ExtArgs>
    successorTask?: boolean | Task$successorTaskArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    params?: boolean
    fromStatus?: boolean
    predecessorTaskId?: boolean
    createDate?: boolean
    updateDate?: boolean
    predecessorTask?: boolean | Task$predecessorTaskArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    params?: boolean
    fromStatus?: boolean
    predecessorTaskId?: boolean
    createDate?: boolean
    updateDate?: boolean
    predecessorTask?: boolean | Task$predecessorTaskArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    params?: boolean
    fromStatus?: boolean
    predecessorTaskId?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "params" | "fromStatus" | "predecessorTaskId" | "createDate" | "updateDate", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    predecessorTask?: boolean | Task$predecessorTaskArgs<ExtArgs>
    successorTask?: boolean | Task$successorTaskArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    predecessorTask?: boolean | Task$predecessorTaskArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    predecessorTask?: boolean | Task$predecessorTaskArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      predecessorTask: Prisma.$TaskPayload<ExtArgs> | null
      successorTask: Prisma.$TaskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      status: $Enums.TaskStatus
      params: Prisma.JsonValue
      fromStatus: $Enums.TaskStatus[]
      predecessorTaskId: number | null
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    predecessorTask<T extends Task$predecessorTaskArgs<ExtArgs> = {}>(args?: Subset<T, Task$predecessorTaskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    successorTask<T extends Task$successorTaskArgs<ExtArgs> = {}>(args?: Subset<T, Task$successorTaskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'Int'>
    readonly name: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly params: FieldRef<"Task", 'Json'>
    readonly fromStatus: FieldRef<"Task", 'TaskStatus[]'>
    readonly predecessorTaskId: FieldRef<"Task", 'Int'>
    readonly createDate: FieldRef<"Task", 'DateTime'>
    readonly updateDate: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.predecessorTask
   */
  export type Task$predecessorTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * Task.successorTask
   */
  export type Task$successorTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model OTP
   */

  export type AggregateOTP = {
    _count: OTPCountAggregateOutputType | null
    _avg: OTPAvgAggregateOutputType | null
    _sum: OTPSumAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  export type OTPAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OTPSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OTPMinAggregateOutputType = {
    id: number | null
    OTP: string | null
    email: string | null
    userId: number | null
    status: $Enums.OTPStatus | null
    createDate: Date | null
    updateDate: Date | null
    expirationDate: Date | null
  }

  export type OTPMaxAggregateOutputType = {
    id: number | null
    OTP: string | null
    email: string | null
    userId: number | null
    status: $Enums.OTPStatus | null
    createDate: Date | null
    updateDate: Date | null
    expirationDate: Date | null
  }

  export type OTPCountAggregateOutputType = {
    id: number
    OTP: number
    email: number
    userId: number
    status: number
    createDate: number
    updateDate: number
    expirationDate: number
    _all: number
  }


  export type OTPAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OTPSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OTPMinAggregateInputType = {
    id?: true
    OTP?: true
    email?: true
    userId?: true
    status?: true
    createDate?: true
    updateDate?: true
    expirationDate?: true
  }

  export type OTPMaxAggregateInputType = {
    id?: true
    OTP?: true
    email?: true
    userId?: true
    status?: true
    createDate?: true
    updateDate?: true
    expirationDate?: true
  }

  export type OTPCountAggregateInputType = {
    id?: true
    OTP?: true
    email?: true
    userId?: true
    status?: true
    createDate?: true
    updateDate?: true
    expirationDate?: true
    _all?: true
  }

  export type OTPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTP to aggregate.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTPS
    **/
    _count?: true | OTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OTPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OTPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTPMaxAggregateInputType
  }

  export type GetOTPAggregateType<T extends OTPAggregateArgs> = {
        [P in keyof T & keyof AggregateOTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOTP[P]>
      : GetScalarType<T[P], AggregateOTP[P]>
  }




  export type OTPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPWhereInput
    orderBy?: OTPOrderByWithAggregationInput | OTPOrderByWithAggregationInput[]
    by: OTPScalarFieldEnum[] | OTPScalarFieldEnum
    having?: OTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTPCountAggregateInputType | true
    _avg?: OTPAvgAggregateInputType
    _sum?: OTPSumAggregateInputType
    _min?: OTPMinAggregateInputType
    _max?: OTPMaxAggregateInputType
  }

  export type OTPGroupByOutputType = {
    id: number
    OTP: string
    email: string
    userId: number | null
    status: $Enums.OTPStatus
    createDate: Date | null
    updateDate: Date | null
    expirationDate: Date
    _count: OTPCountAggregateOutputType | null
    _avg: OTPAvgAggregateOutputType | null
    _sum: OTPSumAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  type GetOTPGroupByPayload<T extends OTPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTPGroupByOutputType[P]>
            : GetScalarType<T[P], OTPGroupByOutputType[P]>
        }
      >
    >


  export type OTPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    OTP?: boolean
    email?: boolean
    userId?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
    expirationDate?: boolean
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    OTP?: boolean
    email?: boolean
    userId?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
    expirationDate?: boolean
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    OTP?: boolean
    email?: boolean
    userId?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
    expirationDate?: boolean
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectScalar = {
    id?: boolean
    OTP?: boolean
    email?: boolean
    userId?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
    expirationDate?: boolean
  }

  export type OTPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "OTP" | "email" | "userId" | "status" | "createDate" | "updateDate" | "expirationDate", ExtArgs["result"]["oTP"]>

  export type $OTPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OTP"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      OTP: string
      email: string
      userId: number | null
      status: $Enums.OTPStatus
      createDate: Date | null
      updateDate: Date | null
      expirationDate: Date
    }, ExtArgs["result"]["oTP"]>
    composites: {}
  }

  type OTPGetPayload<S extends boolean | null | undefined | OTPDefaultArgs> = $Result.GetResult<Prisma.$OTPPayload, S>

  type OTPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OTPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OTPCountAggregateInputType | true
    }

  export interface OTPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OTP'], meta: { name: 'OTP' } }
    /**
     * Find zero or one OTP that matches the filter.
     * @param {OTPFindUniqueArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTPFindUniqueArgs>(args: SelectSubset<T, OTPFindUniqueArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OTP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OTPFindUniqueOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTPFindUniqueOrThrowArgs>(args: SelectSubset<T, OTPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTPFindFirstArgs>(args?: SelectSubset<T, OTPFindFirstArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTPFindFirstOrThrowArgs>(args?: SelectSubset<T, OTPFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTPS
     * const oTPS = await prisma.oTP.findMany()
     * 
     * // Get first 10 OTPS
     * const oTPS = await prisma.oTP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTPWithIdOnly = await prisma.oTP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTPFindManyArgs>(args?: SelectSubset<T, OTPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OTP.
     * @param {OTPCreateArgs} args - Arguments to create a OTP.
     * @example
     * // Create one OTP
     * const OTP = await prisma.oTP.create({
     *   data: {
     *     // ... data to create a OTP
     *   }
     * })
     * 
     */
    create<T extends OTPCreateArgs>(args: SelectSubset<T, OTPCreateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OTPS.
     * @param {OTPCreateManyArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTPCreateManyArgs>(args?: SelectSubset<T, OTPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTPS and returns the data saved in the database.
     * @param {OTPCreateManyAndReturnArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTPCreateManyAndReturnArgs>(args?: SelectSubset<T, OTPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OTP.
     * @param {OTPDeleteArgs} args - Arguments to delete one OTP.
     * @example
     * // Delete one OTP
     * const OTP = await prisma.oTP.delete({
     *   where: {
     *     // ... filter to delete one OTP
     *   }
     * })
     * 
     */
    delete<T extends OTPDeleteArgs>(args: SelectSubset<T, OTPDeleteArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OTP.
     * @param {OTPUpdateArgs} args - Arguments to update one OTP.
     * @example
     * // Update one OTP
     * const oTP = await prisma.oTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTPUpdateArgs>(args: SelectSubset<T, OTPUpdateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OTPS.
     * @param {OTPDeleteManyArgs} args - Arguments to filter OTPS to delete.
     * @example
     * // Delete a few OTPS
     * const { count } = await prisma.oTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTPDeleteManyArgs>(args?: SelectSubset<T, OTPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTPUpdateManyArgs>(args: SelectSubset<T, OTPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS and returns the data updated in the database.
     * @param {OTPUpdateManyAndReturnArgs} args - Arguments to update many OTPS.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OTPUpdateManyAndReturnArgs>(args: SelectSubset<T, OTPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OTP.
     * @param {OTPUpsertArgs} args - Arguments to update or create a OTP.
     * @example
     * // Update or create a OTP
     * const oTP = await prisma.oTP.upsert({
     *   create: {
     *     // ... data to create a OTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OTP we want to update
     *   }
     * })
     */
    upsert<T extends OTPUpsertArgs>(args: SelectSubset<T, OTPUpsertArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCountArgs} args - Arguments to filter OTPS to count.
     * @example
     * // Count the number of OTPS
     * const count = await prisma.oTP.count({
     *   where: {
     *     // ... the filter for the OTPS we want to count
     *   }
     * })
    **/
    count<T extends OTPCountArgs>(
      args?: Subset<T, OTPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTPAggregateArgs>(args: Subset<T, OTPAggregateArgs>): Prisma.PrismaPromise<GetOTPAggregateType<T>>

    /**
     * Group by OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTPGroupByArgs['orderBy'] }
        : { orderBy?: OTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OTP model
   */
  readonly fields: OTPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OTP model
   */
  interface OTPFieldRefs {
    readonly id: FieldRef<"OTP", 'Int'>
    readonly OTP: FieldRef<"OTP", 'String'>
    readonly email: FieldRef<"OTP", 'String'>
    readonly userId: FieldRef<"OTP", 'Int'>
    readonly status: FieldRef<"OTP", 'OTPStatus'>
    readonly createDate: FieldRef<"OTP", 'DateTime'>
    readonly updateDate: FieldRef<"OTP", 'DateTime'>
    readonly expirationDate: FieldRef<"OTP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OTP findUnique
   */
  export type OTPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findUniqueOrThrow
   */
  export type OTPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findFirst
   */
  export type OTPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findFirstOrThrow
   */
  export type OTPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findMany
   */
  export type OTPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter, which OTPS to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP create
   */
  export type OTPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data needed to create a OTP.
     */
    data: XOR<OTPCreateInput, OTPUncheckedCreateInput>
  }

  /**
   * OTP createMany
   */
  export type OTPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTP createManyAndReturn
   */
  export type OTPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTP update
   */
  export type OTPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data needed to update a OTP.
     */
    data: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
    /**
     * Choose, which OTP to update.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP updateMany
   */
  export type OTPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to update.
     */
    limit?: number
  }

  /**
   * OTP updateManyAndReturn
   */
  export type OTPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to update.
     */
    limit?: number
  }

  /**
   * OTP upsert
   */
  export type OTPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The filter to search for the OTP to update in case it exists.
     */
    where: OTPWhereUniqueInput
    /**
     * In case the OTP found by the `where` argument doesn't exist, create a new OTP with this data.
     */
    create: XOR<OTPCreateInput, OTPUncheckedCreateInput>
    /**
     * In case the OTP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
  }

  /**
   * OTP delete
   */
  export type OTPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Filter which OTP to delete.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP deleteMany
   */
  export type OTPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPS to delete
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to delete.
     */
    limit?: number
  }

  /**
   * OTP without action
   */
  export type OTPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
  }


  /**
   * Model History
   */

  export type AggregateHistory = {
    _count: HistoryCountAggregateOutputType | null
    _avg: HistoryAvgAggregateOutputType | null
    _sum: HistorySumAggregateOutputType | null
    _min: HistoryMinAggregateOutputType | null
    _max: HistoryMaxAggregateOutputType | null
  }

  export type HistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type HistorySumAggregateOutputType = {
    id: number | null
  }

  export type HistoryMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    originator: string | null
    createDate: Date | null
    updateDate: Date | null
    type: $Enums.HistoryType | null
  }

  export type HistoryMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    originator: string | null
    createDate: Date | null
    updateDate: Date | null
    type: $Enums.HistoryType | null
  }

  export type HistoryCountAggregateOutputType = {
    id: number
    title: number
    description: number
    originator: number
    createDate: number
    updateDate: number
    type: number
    _all: number
  }


  export type HistoryAvgAggregateInputType = {
    id?: true
  }

  export type HistorySumAggregateInputType = {
    id?: true
  }

  export type HistoryMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    originator?: true
    createDate?: true
    updateDate?: true
    type?: true
  }

  export type HistoryMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    originator?: true
    createDate?: true
    updateDate?: true
    type?: true
  }

  export type HistoryCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    originator?: true
    createDate?: true
    updateDate?: true
    type?: true
    _all?: true
  }

  export type HistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which History to aggregate.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Histories
    **/
    _count?: true | HistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoryMaxAggregateInputType
  }

  export type GetHistoryAggregateType<T extends HistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistory[P]>
      : GetScalarType<T[P], AggregateHistory[P]>
  }




  export type HistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoryWhereInput
    orderBy?: HistoryOrderByWithAggregationInput | HistoryOrderByWithAggregationInput[]
    by: HistoryScalarFieldEnum[] | HistoryScalarFieldEnum
    having?: HistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoryCountAggregateInputType | true
    _avg?: HistoryAvgAggregateInputType
    _sum?: HistorySumAggregateInputType
    _min?: HistoryMinAggregateInputType
    _max?: HistoryMaxAggregateInputType
  }

  export type HistoryGroupByOutputType = {
    id: number
    title: string | null
    description: string | null
    originator: string | null
    createDate: Date | null
    updateDate: Date | null
    type: $Enums.HistoryType | null
    _count: HistoryCountAggregateOutputType | null
    _avg: HistoryAvgAggregateOutputType | null
    _sum: HistorySumAggregateOutputType | null
    _min: HistoryMinAggregateOutputType | null
    _max: HistoryMaxAggregateOutputType | null
  }

  type GetHistoryGroupByPayload<T extends HistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoryGroupByOutputType[P]>
            : GetScalarType<T[P], HistoryGroupByOutputType[P]>
        }
      >
    >


  export type HistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    originator?: boolean
    createDate?: boolean
    updateDate?: boolean
    type?: boolean
  }, ExtArgs["result"]["history"]>

  export type HistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    originator?: boolean
    createDate?: boolean
    updateDate?: boolean
    type?: boolean
  }, ExtArgs["result"]["history"]>

  export type HistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    originator?: boolean
    createDate?: boolean
    updateDate?: boolean
    type?: boolean
  }, ExtArgs["result"]["history"]>

  export type HistorySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    originator?: boolean
    createDate?: boolean
    updateDate?: boolean
    type?: boolean
  }

  export type HistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "originator" | "createDate" | "updateDate" | "type", ExtArgs["result"]["history"]>

  export type $HistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "History"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      description: string | null
      originator: string | null
      createDate: Date | null
      updateDate: Date | null
      type: $Enums.HistoryType | null
    }, ExtArgs["result"]["history"]>
    composites: {}
  }

  type HistoryGetPayload<S extends boolean | null | undefined | HistoryDefaultArgs> = $Result.GetResult<Prisma.$HistoryPayload, S>

  type HistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoryCountAggregateInputType | true
    }

  export interface HistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['History'], meta: { name: 'History' } }
    /**
     * Find zero or one History that matches the filter.
     * @param {HistoryFindUniqueArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistoryFindUniqueArgs>(args: SelectSubset<T, HistoryFindUniqueArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one History that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HistoryFindUniqueOrThrowArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, HistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first History that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindFirstArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistoryFindFirstArgs>(args?: SelectSubset<T, HistoryFindFirstArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first History that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindFirstOrThrowArgs} args - Arguments to find a History
     * @example
     * // Get one History
     * const history = await prisma.history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, HistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Histories
     * const histories = await prisma.history.findMany()
     * 
     * // Get first 10 Histories
     * const histories = await prisma.history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historyWithIdOnly = await prisma.history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistoryFindManyArgs>(args?: SelectSubset<T, HistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a History.
     * @param {HistoryCreateArgs} args - Arguments to create a History.
     * @example
     * // Create one History
     * const History = await prisma.history.create({
     *   data: {
     *     // ... data to create a History
     *   }
     * })
     * 
     */
    create<T extends HistoryCreateArgs>(args: SelectSubset<T, HistoryCreateArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Histories.
     * @param {HistoryCreateManyArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const history = await prisma.history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistoryCreateManyArgs>(args?: SelectSubset<T, HistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Histories and returns the data saved in the database.
     * @param {HistoryCreateManyAndReturnArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const history = await prisma.history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Histories and only return the `id`
     * const historyWithIdOnly = await prisma.history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, HistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a History.
     * @param {HistoryDeleteArgs} args - Arguments to delete one History.
     * @example
     * // Delete one History
     * const History = await prisma.history.delete({
     *   where: {
     *     // ... filter to delete one History
     *   }
     * })
     * 
     */
    delete<T extends HistoryDeleteArgs>(args: SelectSubset<T, HistoryDeleteArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one History.
     * @param {HistoryUpdateArgs} args - Arguments to update one History.
     * @example
     * // Update one History
     * const history = await prisma.history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistoryUpdateArgs>(args: SelectSubset<T, HistoryUpdateArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Histories.
     * @param {HistoryDeleteManyArgs} args - Arguments to filter Histories to delete.
     * @example
     * // Delete a few Histories
     * const { count } = await prisma.history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistoryDeleteManyArgs>(args?: SelectSubset<T, HistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Histories
     * const history = await prisma.history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistoryUpdateManyArgs>(args: SelectSubset<T, HistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histories and returns the data updated in the database.
     * @param {HistoryUpdateManyAndReturnArgs} args - Arguments to update many Histories.
     * @example
     * // Update many Histories
     * const history = await prisma.history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Histories and only return the `id`
     * const historyWithIdOnly = await prisma.history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, HistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one History.
     * @param {HistoryUpsertArgs} args - Arguments to update or create a History.
     * @example
     * // Update or create a History
     * const history = await prisma.history.upsert({
     *   create: {
     *     // ... data to create a History
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the History we want to update
     *   }
     * })
     */
    upsert<T extends HistoryUpsertArgs>(args: SelectSubset<T, HistoryUpsertArgs<ExtArgs>>): Prisma__HistoryClient<$Result.GetResult<Prisma.$HistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryCountArgs} args - Arguments to filter Histories to count.
     * @example
     * // Count the number of Histories
     * const count = await prisma.history.count({
     *   where: {
     *     // ... the filter for the Histories we want to count
     *   }
     * })
    **/
    count<T extends HistoryCountArgs>(
      args?: Subset<T, HistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a History.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoryAggregateArgs>(args: Subset<T, HistoryAggregateArgs>): Prisma.PrismaPromise<GetHistoryAggregateType<T>>

    /**
     * Group by History.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoryGroupByArgs['orderBy'] }
        : { orderBy?: HistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the History model
   */
  readonly fields: HistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for History.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the History model
   */
  interface HistoryFieldRefs {
    readonly id: FieldRef<"History", 'Int'>
    readonly title: FieldRef<"History", 'String'>
    readonly description: FieldRef<"History", 'String'>
    readonly originator: FieldRef<"History", 'String'>
    readonly createDate: FieldRef<"History", 'DateTime'>
    readonly updateDate: FieldRef<"History", 'DateTime'>
    readonly type: FieldRef<"History", 'HistoryType'>
  }
    

  // Custom InputTypes
  /**
   * History findUnique
   */
  export type HistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History findUniqueOrThrow
   */
  export type HistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History findFirst
   */
  export type HistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Histories.
     */
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History findFirstOrThrow
   */
  export type HistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * Filter, which History to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Histories.
     */
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History findMany
   */
  export type HistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * Filter, which Histories to fetch.
     */
    where?: HistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histories to fetch.
     */
    orderBy?: HistoryOrderByWithRelationInput | HistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Histories.
     */
    cursor?: HistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histories.
     */
    skip?: number
    distinct?: HistoryScalarFieldEnum | HistoryScalarFieldEnum[]
  }

  /**
   * History create
   */
  export type HistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a History.
     */
    data?: XOR<HistoryCreateInput, HistoryUncheckedCreateInput>
  }

  /**
   * History createMany
   */
  export type HistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Histories.
     */
    data: HistoryCreateManyInput | HistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * History createManyAndReturn
   */
  export type HistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * The data used to create many Histories.
     */
    data: HistoryCreateManyInput | HistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * History update
   */
  export type HistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a History.
     */
    data: XOR<HistoryUpdateInput, HistoryUncheckedUpdateInput>
    /**
     * Choose, which History to update.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History updateMany
   */
  export type HistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Histories.
     */
    data: XOR<HistoryUpdateManyMutationInput, HistoryUncheckedUpdateManyInput>
    /**
     * Filter which Histories to update
     */
    where?: HistoryWhereInput
    /**
     * Limit how many Histories to update.
     */
    limit?: number
  }

  /**
   * History updateManyAndReturn
   */
  export type HistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * The data used to update Histories.
     */
    data: XOR<HistoryUpdateManyMutationInput, HistoryUncheckedUpdateManyInput>
    /**
     * Filter which Histories to update
     */
    where?: HistoryWhereInput
    /**
     * Limit how many Histories to update.
     */
    limit?: number
  }

  /**
   * History upsert
   */
  export type HistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the History to update in case it exists.
     */
    where: HistoryWhereUniqueInput
    /**
     * In case the History found by the `where` argument doesn't exist, create a new History with this data.
     */
    create: XOR<HistoryCreateInput, HistoryUncheckedCreateInput>
    /**
     * In case the History was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoryUpdateInput, HistoryUncheckedUpdateInput>
  }

  /**
   * History delete
   */
  export type HistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
    /**
     * Filter which History to delete.
     */
    where: HistoryWhereUniqueInput
  }

  /**
   * History deleteMany
   */
  export type HistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Histories to delete
     */
    where?: HistoryWhereInput
    /**
     * Limit how many Histories to delete.
     */
    limit?: number
  }

  /**
   * History without action
   */
  export type HistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    id: number | null
  }

  export type JobSumAggregateOutputType = {
    id: number | null
  }

  export type JobMinAggregateOutputType = {
    id: number | null
    jobname: string | null
    status: $Enums.JobStatus | null
    description: string | null
    model: $Enums.JobModel | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type JobMaxAggregateOutputType = {
    id: number | null
    jobname: string | null
    status: $Enums.JobStatus | null
    description: string | null
    model: $Enums.JobModel | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    jobname: number
    status: number
    description: number
    model: number
    data: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    id?: true
  }

  export type JobSumAggregateInputType = {
    id?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    jobname?: true
    status?: true
    description?: true
    model?: true
    createDate?: true
    updateDate?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    jobname?: true
    status?: true
    description?: true
    model?: true
    createDate?: true
    updateDate?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    jobname?: true
    status?: true
    description?: true
    model?: true
    data?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: number
    jobname: string
    status: $Enums.JobStatus
    description: string
    model: $Enums.JobModel
    data: JsonValue
    createDate: Date | null
    updateDate: Date | null
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobname?: boolean
    status?: boolean
    description?: boolean
    model?: boolean
    data?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobname?: boolean
    status?: boolean
    description?: boolean
    model?: boolean
    data?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["job"]>

  export type JobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobname?: boolean
    status?: boolean
    description?: boolean
    model?: boolean
    data?: boolean
    createDate?: boolean
    updateDate?: boolean
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    jobname?: boolean
    status?: boolean
    description?: boolean
    model?: boolean
    data?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type JobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobname" | "status" | "description" | "model" | "data" | "createDate" | "updateDate", ExtArgs["result"]["job"]>

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jobname: string
      status: $Enums.JobStatus
      description: string
      model: $Enums.JobModel
      data: Prisma.JsonValue
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {JobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobUpdateManyAndReturnArgs>(args: SelectSubset<T, JobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'Int'>
    readonly jobname: FieldRef<"Job", 'String'>
    readonly status: FieldRef<"Job", 'JobStatus'>
    readonly description: FieldRef<"Job", 'String'>
    readonly model: FieldRef<"Job", 'JobModel'>
    readonly data: FieldRef<"Job", 'Json'>
    readonly createDate: FieldRef<"Job", 'DateTime'>
    readonly updateDate: FieldRef<"Job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Job updateManyAndReturn
   */
  export type JobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    senderAmount: number | null
    receiverAmount: number | null
    senderAccountAmount: number | null
    receiverAccountAmount: number | null
    senderAccountId: number | null
    receiverAccountId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    senderAmount: number | null
    receiverAmount: number | null
    senderAccountAmount: number | null
    receiverAccountAmount: number | null
    senderAccountId: number | null
    receiverAccountId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    transactionid: string | null
    status: $Enums.TransactionStatus | null
    statusMessage: string | null
    isBankTransaction: boolean | null
    senderAmount: number | null
    receiverAmount: number | null
    senderAccountAmount: number | null
    receiverAccountAmount: number | null
    senderAccountId: number | null
    receiverAccountId: number | null
    sender: string | null
    receiver: string | null
    message: string | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    transactionid: string | null
    status: $Enums.TransactionStatus | null
    statusMessage: string | null
    isBankTransaction: boolean | null
    senderAmount: number | null
    receiverAmount: number | null
    senderAccountAmount: number | null
    receiverAccountAmount: number | null
    senderAccountId: number | null
    receiverAccountId: number | null
    sender: string | null
    receiver: string | null
    message: string | null
    createDate: Date | null
    updateDate: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    transactionid: number
    status: number
    statusMessage: number
    isBankTransaction: number
    senderAmount: number
    receiverAmount: number
    senderAccountAmount: number
    receiverAccountAmount: number
    senderAccountId: number
    receiverAccountId: number
    sender: number
    receiver: number
    message: number
    createDate: number
    updateDate: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    senderAmount?: true
    receiverAmount?: true
    senderAccountAmount?: true
    receiverAccountAmount?: true
    senderAccountId?: true
    receiverAccountId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    senderAmount?: true
    receiverAmount?: true
    senderAccountAmount?: true
    receiverAccountAmount?: true
    senderAccountId?: true
    receiverAccountId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    transactionid?: true
    status?: true
    statusMessage?: true
    isBankTransaction?: true
    senderAmount?: true
    receiverAmount?: true
    senderAccountAmount?: true
    receiverAccountAmount?: true
    senderAccountId?: true
    receiverAccountId?: true
    sender?: true
    receiver?: true
    message?: true
    createDate?: true
    updateDate?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    transactionid?: true
    status?: true
    statusMessage?: true
    isBankTransaction?: true
    senderAmount?: true
    receiverAmount?: true
    senderAccountAmount?: true
    receiverAccountAmount?: true
    senderAccountId?: true
    receiverAccountId?: true
    sender?: true
    receiver?: true
    message?: true
    createDate?: true
    updateDate?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    transactionid?: true
    status?: true
    statusMessage?: true
    isBankTransaction?: true
    senderAmount?: true
    receiverAmount?: true
    senderAccountAmount?: true
    receiverAccountAmount?: true
    senderAccountId?: true
    receiverAccountId?: true
    sender?: true
    receiver?: true
    message?: true
    createDate?: true
    updateDate?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    transactionid: string
    status: $Enums.TransactionStatus
    statusMessage: string
    isBankTransaction: boolean
    senderAmount: number
    receiverAmount: number | null
    senderAccountAmount: number
    receiverAccountAmount: number | null
    senderAccountId: number
    receiverAccountId: number | null
    sender: string | null
    receiver: string | null
    message: string | null
    createDate: Date | null
    updateDate: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionid?: boolean
    status?: boolean
    statusMessage?: boolean
    isBankTransaction?: boolean
    senderAmount?: boolean
    receiverAmount?: boolean
    senderAccountAmount?: boolean
    receiverAccountAmount?: boolean
    senderAccountId?: boolean
    receiverAccountId?: boolean
    sender?: boolean
    receiver?: boolean
    message?: boolean
    createDate?: boolean
    updateDate?: boolean
    senderAccount?: boolean | Transaction$senderAccountArgs<ExtArgs>
    receiverAccount?: boolean | Transaction$receiverAccountArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionid?: boolean
    status?: boolean
    statusMessage?: boolean
    isBankTransaction?: boolean
    senderAmount?: boolean
    receiverAmount?: boolean
    senderAccountAmount?: boolean
    receiverAccountAmount?: boolean
    senderAccountId?: boolean
    receiverAccountId?: boolean
    sender?: boolean
    receiver?: boolean
    message?: boolean
    createDate?: boolean
    updateDate?: boolean
    senderAccount?: boolean | Transaction$senderAccountArgs<ExtArgs>
    receiverAccount?: boolean | Transaction$receiverAccountArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionid?: boolean
    status?: boolean
    statusMessage?: boolean
    isBankTransaction?: boolean
    senderAmount?: boolean
    receiverAmount?: boolean
    senderAccountAmount?: boolean
    receiverAccountAmount?: boolean
    senderAccountId?: boolean
    receiverAccountId?: boolean
    sender?: boolean
    receiver?: boolean
    message?: boolean
    createDate?: boolean
    updateDate?: boolean
    senderAccount?: boolean | Transaction$senderAccountArgs<ExtArgs>
    receiverAccount?: boolean | Transaction$receiverAccountArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    transactionid?: boolean
    status?: boolean
    statusMessage?: boolean
    isBankTransaction?: boolean
    senderAmount?: boolean
    receiverAmount?: boolean
    senderAccountAmount?: boolean
    receiverAccountAmount?: boolean
    senderAccountId?: boolean
    receiverAccountId?: boolean
    sender?: boolean
    receiver?: boolean
    message?: boolean
    createDate?: boolean
    updateDate?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionid" | "status" | "statusMessage" | "isBankTransaction" | "senderAmount" | "receiverAmount" | "senderAccountAmount" | "receiverAccountAmount" | "senderAccountId" | "receiverAccountId" | "sender" | "receiver" | "message" | "createDate" | "updateDate", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senderAccount?: boolean | Transaction$senderAccountArgs<ExtArgs>
    receiverAccount?: boolean | Transaction$receiverAccountArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senderAccount?: boolean | Transaction$senderAccountArgs<ExtArgs>
    receiverAccount?: boolean | Transaction$receiverAccountArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senderAccount?: boolean | Transaction$senderAccountArgs<ExtArgs>
    receiverAccount?: boolean | Transaction$receiverAccountArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      senderAccount: Prisma.$AccountPayload<ExtArgs> | null
      receiverAccount: Prisma.$AccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionid: string
      status: $Enums.TransactionStatus
      statusMessage: string
      isBankTransaction: boolean
      senderAmount: number
      receiverAmount: number | null
      senderAccountAmount: number
      receiverAccountAmount: number | null
      senderAccountId: number
      receiverAccountId: number | null
      sender: string | null
      receiver: string | null
      message: string | null
      createDate: Date | null
      updateDate: Date | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    senderAccount<T extends Transaction$senderAccountArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$senderAccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    receiverAccount<T extends Transaction$receiverAccountArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$receiverAccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly transactionid: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly statusMessage: FieldRef<"Transaction", 'String'>
    readonly isBankTransaction: FieldRef<"Transaction", 'Boolean'>
    readonly senderAmount: FieldRef<"Transaction", 'Float'>
    readonly receiverAmount: FieldRef<"Transaction", 'Float'>
    readonly senderAccountAmount: FieldRef<"Transaction", 'Float'>
    readonly receiverAccountAmount: FieldRef<"Transaction", 'Float'>
    readonly senderAccountId: FieldRef<"Transaction", 'Int'>
    readonly receiverAccountId: FieldRef<"Transaction", 'Int'>
    readonly sender: FieldRef<"Transaction", 'String'>
    readonly receiver: FieldRef<"Transaction", 'String'>
    readonly message: FieldRef<"Transaction", 'String'>
    readonly createDate: FieldRef<"Transaction", 'DateTime'>
    readonly updateDate: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.senderAccount
   */
  export type Transaction$senderAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Transaction.receiverAccount
   */
  export type Transaction$receiverAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    id: number | null
    accountId: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: number | null
    IBAN: string | null
    status: $Enums.IBANStatus | null
    createDate: Date | null
    updateDate: Date | null
    accountId: number | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: number | null
    IBAN: string | null
    status: $Enums.IBANStatus | null
    createDate: Date | null
    updateDate: Date | null
    accountId: number | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    IBAN: number
    status: number
    createDate: number
    updateDate: number
    accountId: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type BankAccountSumAggregateInputType = {
    id?: true
    accountId?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    IBAN?: true
    status?: true
    createDate?: true
    updateDate?: true
    accountId?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    IBAN?: true
    status?: true
    createDate?: true
    updateDate?: true
    accountId?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    IBAN?: true
    status?: true
    createDate?: true
    updateDate?: true
    accountId?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: number
    IBAN: string
    status: $Enums.IBANStatus
    createDate: Date
    updateDate: Date
    accountId: number
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    IBAN?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
    accountId?: boolean
    account?: boolean | BankAccount$accountArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    IBAN?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
    accountId?: boolean
    account?: boolean | BankAccount$accountArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    IBAN?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
    accountId?: boolean
    account?: boolean | BankAccount$accountArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    IBAN?: boolean
    status?: boolean
    createDate?: boolean
    updateDate?: boolean
    accountId?: boolean
  }

  export type BankAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "IBAN" | "status" | "createDate" | "updateDate" | "accountId", ExtArgs["result"]["bankAccount"]>
  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccount$accountArgs<ExtArgs>
  }
  export type BankAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccount$accountArgs<ExtArgs>
  }
  export type BankAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccount$accountArgs<ExtArgs>
  }

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      IBAN: string
      status: $Enums.IBANStatus
      createDate: Date
      updateDate: Date
      accountId: number
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankAccounts and returns the data saved in the database.
     * @param {BankAccountCreateManyAndReturnArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BankAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts and returns the data updated in the database.
     * @param {BankAccountUpdateManyAndReturnArgs} args - Arguments to update many BankAccounts.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, BankAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends BankAccount$accountArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'Int'>
    readonly IBAN: FieldRef<"BankAccount", 'String'>
    readonly status: FieldRef<"BankAccount", 'IBANStatus'>
    readonly createDate: FieldRef<"BankAccount", 'DateTime'>
    readonly updateDate: FieldRef<"BankAccount", 'DateTime'>
    readonly accountId: FieldRef<"BankAccount", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount createManyAndReturn
   */
  export type BankAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount updateManyAndReturn
   */
  export type BankAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to delete.
     */
    limit?: number
  }

  /**
   * BankAccount.account
   */
  export type BankAccount$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    servicename: 'servicename'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceActionScalarFieldEnum: {
    id: 'id',
    serviceactionname: 'serviceactionname'
  };

  export type ServiceActionScalarFieldEnum = (typeof ServiceActionScalarFieldEnum)[keyof typeof ServiceActionScalarFieldEnum]


  export const ServiceStatementActionScalarFieldEnum: {
    id: 'id',
    ssactionname: 'ssactionname',
    createDate: 'createDate',
    updateDate: 'updateDate',
    statementid: 'statementid',
    serviceactionid: 'serviceactionid'
  };

  export type ServiceStatementActionScalarFieldEnum = (typeof ServiceStatementActionScalarFieldEnum)[keyof typeof ServiceStatementActionScalarFieldEnum]


  export const ServiceStatementScalarFieldEnum: {
    id: 'id',
    ssname: 'ssname',
    description: 'description',
    permission: 'permission',
    managed: 'managed',
    system: 'system',
    createDate: 'createDate',
    updateDate: 'updateDate',
    serviceid: 'serviceid'
  };

  export type ServiceStatementScalarFieldEnum = (typeof ServiceStatementScalarFieldEnum)[keyof typeof ServiceStatementScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    role: 'role',
    name: 'name',
    description: 'description',
    content: 'content',
    asHtml: 'asHtml',
    fromFile: 'fromFile',
    parameters: 'parameters',
    managed: 'managed'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    managed: 'managed',
    system: 'system',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    type: 'type',
    subtype: 'subtype',
    key: 'key',
    value: 'value'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    managed: 'managed',
    system: 'system',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    dialCode: 'dialCode',
    code: 'code',
    currency: 'currency',
    currencycode: 'currencycode',
    symbol: 'symbol'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    street: 'street',
    number: 'number',
    box: 'box',
    city: 'city',
    postalcode: 'postalcode',
    createDate: 'createDate',
    updateDate: 'updateDate',
    county: 'county',
    countryId: 'countryId',
    userId: 'userId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    lastname: 'lastname',
    firstname: 'firstname',
    avatar: 'avatar',
    phone: 'phone',
    email: 'email',
    password: 'password',
    passwordless: 'passwordless',
    attemps: 'attemps',
    blocked: 'blocked',
    managed: 'managed',
    system: 'system',
    loggedinDate: 'loggedinDate',
    type: 'type',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPATScalarFieldEnum: {
    id: 'id',
    tokenName: 'tokenName',
    token: 'token',
    createDate: 'createDate',
    expirationDate: 'expirationDate',
    tokenStatus: 'tokenStatus',
    userId: 'userId'
  };

  export type UserPATScalarFieldEnum = (typeof UserPATScalarFieldEnum)[keyof typeof UserPATScalarFieldEnum]


  export const UserSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type UserSettingScalarFieldEnum = (typeof UserSettingScalarFieldEnum)[keyof typeof UserSettingScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    managed: 'managed',
    system: 'system',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const ExportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type ExportScalarFieldEnum = (typeof ExportScalarFieldEnum)[keyof typeof ExportScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    status: 'status',
    userId: 'userId',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountApplyScalarFieldEnum: {
    id: 'id',
    username: 'username',
    firstname: 'firstname',
    lastname: 'lastname',
    password: 'password',
    email: 'email',
    country: 'country',
    gender: 'gender',
    status: 'status',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type AccountApplyScalarFieldEnum = (typeof AccountApplyScalarFieldEnum)[keyof typeof AccountApplyScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    params: 'params',
    fromStatus: 'fromStatus',
    predecessorTaskId: 'predecessorTaskId',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const OTPScalarFieldEnum: {
    id: 'id',
    OTP: 'OTP',
    email: 'email',
    userId: 'userId',
    status: 'status',
    createDate: 'createDate',
    updateDate: 'updateDate',
    expirationDate: 'expirationDate'
  };

  export type OTPScalarFieldEnum = (typeof OTPScalarFieldEnum)[keyof typeof OTPScalarFieldEnum]


  export const HistoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    originator: 'originator',
    createDate: 'createDate',
    updateDate: 'updateDate',
    type: 'type'
  };

  export type HistoryScalarFieldEnum = (typeof HistoryScalarFieldEnum)[keyof typeof HistoryScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    jobname: 'jobname',
    status: 'status',
    description: 'description',
    model: 'model',
    data: 'data',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    transactionid: 'transactionid',
    status: 'status',
    statusMessage: 'statusMessage',
    isBankTransaction: 'isBankTransaction',
    senderAmount: 'senderAmount',
    receiverAmount: 'receiverAmount',
    senderAccountAmount: 'senderAccountAmount',
    receiverAccountAmount: 'receiverAccountAmount',
    senderAccountId: 'senderAccountId',
    receiverAccountId: 'receiverAccountId',
    sender: 'sender',
    receiver: 'receiver',
    message: 'message',
    createDate: 'createDate',
    updateDate: 'updateDate'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    IBAN: 'IBAN',
    status: 'status',
    createDate: 'createDate',
    updateDate: 'updateDate',
    accountId: 'accountId'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Permission'
   */
  export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission'>
    


  /**
   * Reference to a field of type 'Permission[]'
   */
  export type ListEnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TemplateRole'
   */
  export type EnumTemplateRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateRole'>
    


  /**
   * Reference to a field of type 'TemplateRole[]'
   */
  export type ListEnumTemplateRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateRole[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'TokenStatus'
   */
  export type EnumTokenStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenStatus'>
    


  /**
   * Reference to a field of type 'TokenStatus[]'
   */
  export type ListEnumTokenStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'AccountApplyStatus'
   */
  export type EnumAccountApplyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountApplyStatus'>
    


  /**
   * Reference to a field of type 'AccountApplyStatus[]'
   */
  export type ListEnumAccountApplyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountApplyStatus[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'OTPStatus'
   */
  export type EnumOTPStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPStatus'>
    


  /**
   * Reference to a field of type 'OTPStatus[]'
   */
  export type ListEnumOTPStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPStatus[]'>
    


  /**
   * Reference to a field of type 'HistoryType'
   */
  export type EnumHistoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HistoryType'>
    


  /**
   * Reference to a field of type 'HistoryType[]'
   */
  export type ListEnumHistoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HistoryType[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'JobModel'
   */
  export type EnumJobModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobModel'>
    


  /**
   * Reference to a field of type 'JobModel[]'
   */
  export type ListEnumJobModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobModel[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'IBANStatus'
   */
  export type EnumIBANStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IBANStatus'>
    


  /**
   * Reference to a field of type 'IBANStatus[]'
   */
  export type ListEnumIBANStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IBANStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    servicename?: StringFilter<"Service"> | string
    serviceactions?: ServiceActionListRelationFilter
    servicestatements?: ServiceStatementListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    servicename?: SortOrder
    serviceactions?: ServiceActionOrderByRelationAggregateInput
    servicestatements?: ServiceStatementOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    servicename?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    serviceactions?: ServiceActionListRelationFilter
    servicestatements?: ServiceStatementListRelationFilter
  }, "id" | "servicename">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    servicename?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    servicename?: StringWithAggregatesFilter<"Service"> | string
  }

  export type ServiceActionWhereInput = {
    AND?: ServiceActionWhereInput | ServiceActionWhereInput[]
    OR?: ServiceActionWhereInput[]
    NOT?: ServiceActionWhereInput | ServiceActionWhereInput[]
    id?: IntFilter<"ServiceAction"> | number
    serviceactionname?: StringFilter<"ServiceAction"> | string
    services?: ServiceListRelationFilter
    serviceStatementActions?: ServiceStatementActionListRelationFilter
  }

  export type ServiceActionOrderByWithRelationInput = {
    id?: SortOrder
    serviceactionname?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    serviceStatementActions?: ServiceStatementActionOrderByRelationAggregateInput
  }

  export type ServiceActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceactionname?: string
    AND?: ServiceActionWhereInput | ServiceActionWhereInput[]
    OR?: ServiceActionWhereInput[]
    NOT?: ServiceActionWhereInput | ServiceActionWhereInput[]
    services?: ServiceListRelationFilter
    serviceStatementActions?: ServiceStatementActionListRelationFilter
  }, "id" | "serviceactionname">

  export type ServiceActionOrderByWithAggregationInput = {
    id?: SortOrder
    serviceactionname?: SortOrder
    _count?: ServiceActionCountOrderByAggregateInput
    _avg?: ServiceActionAvgOrderByAggregateInput
    _max?: ServiceActionMaxOrderByAggregateInput
    _min?: ServiceActionMinOrderByAggregateInput
    _sum?: ServiceActionSumOrderByAggregateInput
  }

  export type ServiceActionScalarWhereWithAggregatesInput = {
    AND?: ServiceActionScalarWhereWithAggregatesInput | ServiceActionScalarWhereWithAggregatesInput[]
    OR?: ServiceActionScalarWhereWithAggregatesInput[]
    NOT?: ServiceActionScalarWhereWithAggregatesInput | ServiceActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceAction"> | number
    serviceactionname?: StringWithAggregatesFilter<"ServiceAction"> | string
  }

  export type ServiceStatementActionWhereInput = {
    AND?: ServiceStatementActionWhereInput | ServiceStatementActionWhereInput[]
    OR?: ServiceStatementActionWhereInput[]
    NOT?: ServiceStatementActionWhereInput | ServiceStatementActionWhereInput[]
    id?: IntFilter<"ServiceStatementAction"> | number
    ssactionname?: StringFilter<"ServiceStatementAction"> | string
    createDate?: DateTimeNullableFilter<"ServiceStatementAction"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"ServiceStatementAction"> | Date | string | null
    statementid?: IntFilter<"ServiceStatementAction"> | number
    serviceactionid?: IntFilter<"ServiceStatementAction"> | number
    servicestatement?: XOR<ServiceStatementScalarRelationFilter, ServiceStatementWhereInput>
    serviceaction?: XOR<ServiceActionScalarRelationFilter, ServiceActionWhereInput>
  }

  export type ServiceStatementActionOrderByWithRelationInput = {
    id?: SortOrder
    ssactionname?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    statementid?: SortOrder
    serviceactionid?: SortOrder
    servicestatement?: ServiceStatementOrderByWithRelationInput
    serviceaction?: ServiceActionOrderByWithRelationInput
  }

  export type ServiceStatementActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceStatementActionWhereInput | ServiceStatementActionWhereInput[]
    OR?: ServiceStatementActionWhereInput[]
    NOT?: ServiceStatementActionWhereInput | ServiceStatementActionWhereInput[]
    ssactionname?: StringFilter<"ServiceStatementAction"> | string
    createDate?: DateTimeNullableFilter<"ServiceStatementAction"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"ServiceStatementAction"> | Date | string | null
    statementid?: IntFilter<"ServiceStatementAction"> | number
    serviceactionid?: IntFilter<"ServiceStatementAction"> | number
    servicestatement?: XOR<ServiceStatementScalarRelationFilter, ServiceStatementWhereInput>
    serviceaction?: XOR<ServiceActionScalarRelationFilter, ServiceActionWhereInput>
  }, "id">

  export type ServiceStatementActionOrderByWithAggregationInput = {
    id?: SortOrder
    ssactionname?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    statementid?: SortOrder
    serviceactionid?: SortOrder
    _count?: ServiceStatementActionCountOrderByAggregateInput
    _avg?: ServiceStatementActionAvgOrderByAggregateInput
    _max?: ServiceStatementActionMaxOrderByAggregateInput
    _min?: ServiceStatementActionMinOrderByAggregateInput
    _sum?: ServiceStatementActionSumOrderByAggregateInput
  }

  export type ServiceStatementActionScalarWhereWithAggregatesInput = {
    AND?: ServiceStatementActionScalarWhereWithAggregatesInput | ServiceStatementActionScalarWhereWithAggregatesInput[]
    OR?: ServiceStatementActionScalarWhereWithAggregatesInput[]
    NOT?: ServiceStatementActionScalarWhereWithAggregatesInput | ServiceStatementActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceStatementAction"> | number
    ssactionname?: StringWithAggregatesFilter<"ServiceStatementAction"> | string
    createDate?: DateTimeNullableWithAggregatesFilter<"ServiceStatementAction"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"ServiceStatementAction"> | Date | string | null
    statementid?: IntWithAggregatesFilter<"ServiceStatementAction"> | number
    serviceactionid?: IntWithAggregatesFilter<"ServiceStatementAction"> | number
  }

  export type ServiceStatementWhereInput = {
    AND?: ServiceStatementWhereInput | ServiceStatementWhereInput[]
    OR?: ServiceStatementWhereInput[]
    NOT?: ServiceStatementWhereInput | ServiceStatementWhereInput[]
    id?: IntFilter<"ServiceStatement"> | number
    ssname?: StringFilter<"ServiceStatement"> | string
    description?: StringNullableFilter<"ServiceStatement"> | string | null
    permission?: EnumPermissionNullableFilter<"ServiceStatement"> | $Enums.Permission | null
    managed?: BoolNullableFilter<"ServiceStatement"> | boolean | null
    system?: BoolNullableFilter<"ServiceStatement"> | boolean | null
    createDate?: DateTimeNullableFilter<"ServiceStatement"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"ServiceStatement"> | Date | string | null
    serviceid?: IntFilter<"ServiceStatement"> | number
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    servicestatementactions?: ServiceStatementActionListRelationFilter
    policies?: PolicyListRelationFilter
  }

  export type ServiceStatementOrderByWithRelationInput = {
    id?: SortOrder
    ssname?: SortOrder
    description?: SortOrderInput | SortOrder
    permission?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    serviceid?: SortOrder
    service?: ServiceOrderByWithRelationInput
    servicestatementactions?: ServiceStatementActionOrderByRelationAggregateInput
    policies?: PolicyOrderByRelationAggregateInput
  }

  export type ServiceStatementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ssname?: string
    AND?: ServiceStatementWhereInput | ServiceStatementWhereInput[]
    OR?: ServiceStatementWhereInput[]
    NOT?: ServiceStatementWhereInput | ServiceStatementWhereInput[]
    description?: StringNullableFilter<"ServiceStatement"> | string | null
    permission?: EnumPermissionNullableFilter<"ServiceStatement"> | $Enums.Permission | null
    managed?: BoolNullableFilter<"ServiceStatement"> | boolean | null
    system?: BoolNullableFilter<"ServiceStatement"> | boolean | null
    createDate?: DateTimeNullableFilter<"ServiceStatement"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"ServiceStatement"> | Date | string | null
    serviceid?: IntFilter<"ServiceStatement"> | number
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    servicestatementactions?: ServiceStatementActionListRelationFilter
    policies?: PolicyListRelationFilter
  }, "id" | "ssname">

  export type ServiceStatementOrderByWithAggregationInput = {
    id?: SortOrder
    ssname?: SortOrder
    description?: SortOrderInput | SortOrder
    permission?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    serviceid?: SortOrder
    _count?: ServiceStatementCountOrderByAggregateInput
    _avg?: ServiceStatementAvgOrderByAggregateInput
    _max?: ServiceStatementMaxOrderByAggregateInput
    _min?: ServiceStatementMinOrderByAggregateInput
    _sum?: ServiceStatementSumOrderByAggregateInput
  }

  export type ServiceStatementScalarWhereWithAggregatesInput = {
    AND?: ServiceStatementScalarWhereWithAggregatesInput | ServiceStatementScalarWhereWithAggregatesInput[]
    OR?: ServiceStatementScalarWhereWithAggregatesInput[]
    NOT?: ServiceStatementScalarWhereWithAggregatesInput | ServiceStatementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceStatement"> | number
    ssname?: StringWithAggregatesFilter<"ServiceStatement"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceStatement"> | string | null
    permission?: EnumPermissionNullableWithAggregatesFilter<"ServiceStatement"> | $Enums.Permission | null
    managed?: BoolNullableWithAggregatesFilter<"ServiceStatement"> | boolean | null
    system?: BoolNullableWithAggregatesFilter<"ServiceStatement"> | boolean | null
    createDate?: DateTimeNullableWithAggregatesFilter<"ServiceStatement"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"ServiceStatement"> | Date | string | null
    serviceid?: IntWithAggregatesFilter<"ServiceStatement"> | number
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: IntFilter<"Template"> | number
    role?: EnumTemplateRoleNullableFilter<"Template"> | $Enums.TemplateRole | null
    name?: StringFilter<"Template"> | string
    description?: StringNullableFilter<"Template"> | string | null
    content?: StringFilter<"Template"> | string
    asHtml?: BoolNullableFilter<"Template"> | boolean | null
    fromFile?: BoolNullableFilter<"Template"> | boolean | null
    parameters?: StringNullableFilter<"Template"> | string | null
    managed?: BoolNullableFilter<"Template"> | boolean | null
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    asHtml?: SortOrderInput | SortOrder
    fromFile?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    role?: EnumTemplateRoleNullableFilter<"Template"> | $Enums.TemplateRole | null
    name?: StringFilter<"Template"> | string
    description?: StringNullableFilter<"Template"> | string | null
    content?: StringFilter<"Template"> | string
    asHtml?: BoolNullableFilter<"Template"> | boolean | null
    fromFile?: BoolNullableFilter<"Template"> | boolean | null
    parameters?: StringNullableFilter<"Template"> | string | null
    managed?: BoolNullableFilter<"Template"> | boolean | null
  }, "id">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    asHtml?: SortOrderInput | SortOrder
    fromFile?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _avg?: TemplateAvgOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
    _sum?: TemplateSumOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Template"> | number
    role?: EnumTemplateRoleNullableWithAggregatesFilter<"Template"> | $Enums.TemplateRole | null
    name?: StringWithAggregatesFilter<"Template"> | string
    description?: StringNullableWithAggregatesFilter<"Template"> | string | null
    content?: StringWithAggregatesFilter<"Template"> | string
    asHtml?: BoolNullableWithAggregatesFilter<"Template"> | boolean | null
    fromFile?: BoolNullableWithAggregatesFilter<"Template"> | boolean | null
    parameters?: StringNullableWithAggregatesFilter<"Template"> | string | null
    managed?: BoolNullableWithAggregatesFilter<"Template"> | boolean | null
  }

  export type PolicyWhereInput = {
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    id?: IntFilter<"Policy"> | number
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    managed?: BoolNullableFilter<"Policy"> | boolean | null
    system?: BoolNullableFilter<"Policy"> | boolean | null
    createDate?: DateTimeNullableFilter<"Policy"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Policy"> | Date | string | null
    servicestatements?: ServiceStatementListRelationFilter
    roles?: RoleListRelationFilter
    users?: UserListRelationFilter
    groups?: GroupListRelationFilter
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    servicestatements?: ServiceStatementOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    groups?: GroupOrderByRelationAggregateInput
  }

  export type PolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    description?: StringNullableFilter<"Policy"> | string | null
    managed?: BoolNullableFilter<"Policy"> | boolean | null
    system?: BoolNullableFilter<"Policy"> | boolean | null
    createDate?: DateTimeNullableFilter<"Policy"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Policy"> | Date | string | null
    servicestatements?: ServiceStatementListRelationFilter
    roles?: RoleListRelationFilter
    users?: UserListRelationFilter
    groups?: GroupListRelationFilter
  }, "id" | "name">

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    OR?: PolicyScalarWhereWithAggregatesInput[]
    NOT?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Policy"> | number
    name?: StringWithAggregatesFilter<"Policy"> | string
    description?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    managed?: BoolNullableWithAggregatesFilter<"Policy"> | boolean | null
    system?: BoolNullableWithAggregatesFilter<"Policy"> | boolean | null
    createDate?: DateTimeNullableWithAggregatesFilter<"Policy"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"Policy"> | Date | string | null
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: IntFilter<"Setting"> | number
    type?: StringFilter<"Setting"> | string
    subtype?: StringFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    type?: StringFilter<"Setting"> | string
    subtype?: StringFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
  }, "id">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _avg?: SettingAvgOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
    _sum?: SettingSumOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Setting"> | number
    type?: StringWithAggregatesFilter<"Setting"> | string
    subtype?: StringWithAggregatesFilter<"Setting"> | string
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    managed?: BoolNullableFilter<"Role"> | boolean | null
    system?: BoolNullableFilter<"Role"> | boolean | null
    createDate?: DateTimeNullableFilter<"Role"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Role"> | Date | string | null
    policies?: PolicyListRelationFilter
    users?: UserListRelationFilter
    groups?: GroupListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    policies?: PolicyOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    groups?: GroupOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    managed?: BoolNullableFilter<"Role"> | boolean | null
    system?: BoolNullableFilter<"Role"> | boolean | null
    createDate?: DateTimeNullableFilter<"Role"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Role"> | Date | string | null
    policies?: PolicyListRelationFilter
    users?: UserListRelationFilter
    groups?: GroupListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    managed?: BoolNullableWithAggregatesFilter<"Role"> | boolean | null
    system?: BoolNullableWithAggregatesFilter<"Role"> | boolean | null
    createDate?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    name?: StringFilter<"Country"> | string
    dialCode?: StringNullableFilter<"Country"> | string | null
    code?: StringNullableFilter<"Country"> | string | null
    currency?: StringNullableFilter<"Country"> | string | null
    currencycode?: StringNullableFilter<"Country"> | string | null
    symbol?: StringNullableFilter<"Country"> | string | null
    addresses?: AddressListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    dialCode?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    currencycode?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    dialCode?: StringNullableFilter<"Country"> | string | null
    code?: StringNullableFilter<"Country"> | string | null
    currency?: StringNullableFilter<"Country"> | string | null
    currencycode?: StringNullableFilter<"Country"> | string | null
    symbol?: StringNullableFilter<"Country"> | string | null
    addresses?: AddressListRelationFilter
  }, "id" | "name">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    dialCode?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    currencycode?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    name?: StringWithAggregatesFilter<"Country"> | string
    dialCode?: StringNullableWithAggregatesFilter<"Country"> | string | null
    code?: StringNullableWithAggregatesFilter<"Country"> | string | null
    currency?: StringNullableWithAggregatesFilter<"Country"> | string | null
    currencycode?: StringNullableWithAggregatesFilter<"Country"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"Country"> | string | null
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    street?: StringNullableFilter<"Address"> | string | null
    number?: StringNullableFilter<"Address"> | string | null
    box?: StringNullableFilter<"Address"> | string | null
    city?: StringNullableFilter<"Address"> | string | null
    postalcode?: StringFilter<"Address"> | string
    createDate?: DateTimeNullableFilter<"Address"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Address"> | Date | string | null
    county?: StringNullableFilter<"Address"> | string | null
    countryId?: IntNullableFilter<"Address"> | number | null
    userId?: IntNullableFilter<"Address"> | number | null
    country?: XOR<CountryNullableScalarRelationFilter, CountryWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    street?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    box?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalcode?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    county?: SortOrderInput | SortOrder
    countryId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    street?: StringNullableFilter<"Address"> | string | null
    number?: StringNullableFilter<"Address"> | string | null
    box?: StringNullableFilter<"Address"> | string | null
    city?: StringNullableFilter<"Address"> | string | null
    postalcode?: StringFilter<"Address"> | string
    createDate?: DateTimeNullableFilter<"Address"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Address"> | Date | string | null
    county?: StringNullableFilter<"Address"> | string | null
    countryId?: IntNullableFilter<"Address"> | number | null
    country?: XOR<CountryNullableScalarRelationFilter, CountryWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "userId">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    street?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    box?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalcode?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    county?: SortOrderInput | SortOrder
    countryId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    street?: StringNullableWithAggregatesFilter<"Address"> | string | null
    number?: StringNullableWithAggregatesFilter<"Address"> | string | null
    box?: StringNullableWithAggregatesFilter<"Address"> | string | null
    city?: StringNullableWithAggregatesFilter<"Address"> | string | null
    postalcode?: StringWithAggregatesFilter<"Address"> | string
    createDate?: DateTimeNullableWithAggregatesFilter<"Address"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"Address"> | Date | string | null
    county?: StringNullableWithAggregatesFilter<"Address"> | string | null
    countryId?: IntNullableWithAggregatesFilter<"Address"> | number | null
    userId?: IntNullableWithAggregatesFilter<"Address"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringNullableFilter<"User"> | string | null
    lastname?: StringFilter<"User"> | string
    firstname?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    passwordless?: BoolNullableFilter<"User"> | boolean | null
    attemps?: IntNullableFilter<"User"> | number | null
    blocked?: BoolNullableFilter<"User"> | boolean | null
    managed?: BoolNullableFilter<"User"> | boolean | null
    system?: BoolNullableFilter<"User"> | boolean | null
    loggedinDate?: DateTimeNullableFilter<"User"> | Date | string | null
    type?: EnumUserTypeFilter<"User"> | $Enums.UserType
    createDate?: DateTimeNullableFilter<"User"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    policies?: PolicyListRelationFilter
    roles?: RoleListRelationFilter
    groups?: GroupListRelationFilter
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    settings?: UserSettingListRelationFilter
    pats?: UserPATListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    lastname?: SortOrder
    firstname?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordless?: SortOrderInput | SortOrder
    attemps?: SortOrderInput | SortOrder
    blocked?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    loggedinDate?: SortOrderInput | SortOrder
    type?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    address?: AddressOrderByWithRelationInput
    policies?: PolicyOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
    groups?: GroupOrderByRelationAggregateInput
    account?: AccountOrderByWithRelationInput
    settings?: UserSettingOrderByRelationAggregateInput
    pats?: UserPATOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    firstname_lastname?: UserFirstnameLastnameCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    lastname?: StringFilter<"User"> | string
    firstname?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    passwordless?: BoolNullableFilter<"User"> | boolean | null
    attemps?: IntNullableFilter<"User"> | number | null
    blocked?: BoolNullableFilter<"User"> | boolean | null
    managed?: BoolNullableFilter<"User"> | boolean | null
    system?: BoolNullableFilter<"User"> | boolean | null
    loggedinDate?: DateTimeNullableFilter<"User"> | Date | string | null
    type?: EnumUserTypeFilter<"User"> | $Enums.UserType
    createDate?: DateTimeNullableFilter<"User"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    policies?: PolicyListRelationFilter
    roles?: RoleListRelationFilter
    groups?: GroupListRelationFilter
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    settings?: UserSettingListRelationFilter
    pats?: UserPATListRelationFilter
  }, "id" | "id" | "username" | "firstname_lastname">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    lastname?: SortOrder
    firstname?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordless?: SortOrderInput | SortOrder
    attemps?: SortOrderInput | SortOrder
    blocked?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    loggedinDate?: SortOrderInput | SortOrder
    type?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastname?: StringWithAggregatesFilter<"User"> | string
    firstname?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    passwordless?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    attemps?: IntNullableWithAggregatesFilter<"User"> | number | null
    blocked?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    managed?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    system?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    loggedinDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    type?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    createDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserPATWhereInput = {
    AND?: UserPATWhereInput | UserPATWhereInput[]
    OR?: UserPATWhereInput[]
    NOT?: UserPATWhereInput | UserPATWhereInput[]
    id?: IntFilter<"UserPAT"> | number
    tokenName?: StringFilter<"UserPAT"> | string
    token?: StringFilter<"UserPAT"> | string
    createDate?: DateTimeNullableFilter<"UserPAT"> | Date | string | null
    expirationDate?: DateTimeFilter<"UserPAT"> | Date | string
    tokenStatus?: EnumTokenStatusFilter<"UserPAT"> | $Enums.TokenStatus
    userId?: IntFilter<"UserPAT"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPATOrderByWithRelationInput = {
    id?: SortOrder
    tokenName?: SortOrder
    token?: SortOrder
    createDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrder
    tokenStatus?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPATWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserPATWhereInput | UserPATWhereInput[]
    OR?: UserPATWhereInput[]
    NOT?: UserPATWhereInput | UserPATWhereInput[]
    tokenName?: StringFilter<"UserPAT"> | string
    token?: StringFilter<"UserPAT"> | string
    createDate?: DateTimeNullableFilter<"UserPAT"> | Date | string | null
    expirationDate?: DateTimeFilter<"UserPAT"> | Date | string
    tokenStatus?: EnumTokenStatusFilter<"UserPAT"> | $Enums.TokenStatus
    userId?: IntFilter<"UserPAT"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserPATOrderByWithAggregationInput = {
    id?: SortOrder
    tokenName?: SortOrder
    token?: SortOrder
    createDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrder
    tokenStatus?: SortOrder
    userId?: SortOrder
    _count?: UserPATCountOrderByAggregateInput
    _avg?: UserPATAvgOrderByAggregateInput
    _max?: UserPATMaxOrderByAggregateInput
    _min?: UserPATMinOrderByAggregateInput
    _sum?: UserPATSumOrderByAggregateInput
  }

  export type UserPATScalarWhereWithAggregatesInput = {
    AND?: UserPATScalarWhereWithAggregatesInput | UserPATScalarWhereWithAggregatesInput[]
    OR?: UserPATScalarWhereWithAggregatesInput[]
    NOT?: UserPATScalarWhereWithAggregatesInput | UserPATScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPAT"> | number
    tokenName?: StringWithAggregatesFilter<"UserPAT"> | string
    token?: StringWithAggregatesFilter<"UserPAT"> | string
    createDate?: DateTimeNullableWithAggregatesFilter<"UserPAT"> | Date | string | null
    expirationDate?: DateTimeWithAggregatesFilter<"UserPAT"> | Date | string
    tokenStatus?: EnumTokenStatusWithAggregatesFilter<"UserPAT"> | $Enums.TokenStatus
    userId?: IntWithAggregatesFilter<"UserPAT"> | number
  }

  export type UserSettingWhereInput = {
    AND?: UserSettingWhereInput | UserSettingWhereInput[]
    OR?: UserSettingWhereInput[]
    NOT?: UserSettingWhereInput | UserSettingWhereInput[]
    id?: IntFilter<"UserSetting"> | number
    key?: StringFilter<"UserSetting"> | string
    value?: StringFilter<"UserSetting"> | string
    users?: UserListRelationFilter
  }

  export type UserSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type UserSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserSettingWhereInput | UserSettingWhereInput[]
    OR?: UserSettingWhereInput[]
    NOT?: UserSettingWhereInput | UserSettingWhereInput[]
    key?: StringFilter<"UserSetting"> | string
    value?: StringFilter<"UserSetting"> | string
    users?: UserListRelationFilter
  }, "id">

  export type UserSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: UserSettingCountOrderByAggregateInput
    _avg?: UserSettingAvgOrderByAggregateInput
    _max?: UserSettingMaxOrderByAggregateInput
    _min?: UserSettingMinOrderByAggregateInput
    _sum?: UserSettingSumOrderByAggregateInput
  }

  export type UserSettingScalarWhereWithAggregatesInput = {
    AND?: UserSettingScalarWhereWithAggregatesInput | UserSettingScalarWhereWithAggregatesInput[]
    OR?: UserSettingScalarWhereWithAggregatesInput[]
    NOT?: UserSettingScalarWhereWithAggregatesInput | UserSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSetting"> | number
    key?: StringWithAggregatesFilter<"UserSetting"> | string
    value?: StringWithAggregatesFilter<"UserSetting"> | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: IntFilter<"Group"> | number
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    managed?: BoolNullableFilter<"Group"> | boolean | null
    system?: BoolNullableFilter<"Group"> | boolean | null
    createDate?: DateTimeNullableFilter<"Group"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Group"> | Date | string | null
    policies?: PolicyListRelationFilter
    roles?: RoleListRelationFilter
    users?: UserListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    policies?: PolicyOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    description?: StringNullableFilter<"Group"> | string | null
    managed?: BoolNullableFilter<"Group"> | boolean | null
    system?: BoolNullableFilter<"Group"> | boolean | null
    createDate?: DateTimeNullableFilter<"Group"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Group"> | Date | string | null
    policies?: PolicyListRelationFilter
    roles?: RoleListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "name">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managed?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Group"> | number
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    managed?: BoolNullableWithAggregatesFilter<"Group"> | boolean | null
    system?: BoolNullableWithAggregatesFilter<"Group"> | boolean | null
    createDate?: DateTimeNullableWithAggregatesFilter<"Group"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"Group"> | Date | string | null
  }

  export type ExportWhereInput = {
    AND?: ExportWhereInput | ExportWhereInput[]
    OR?: ExportWhereInput[]
    NOT?: ExportWhereInput | ExportWhereInput[]
    id?: IntFilter<"Export"> | number
    name?: StringFilter<"Export"> | string
    content?: JsonFilter<"Export">
    createDate?: DateTimeNullableFilter<"Export"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Export"> | Date | string | null
  }

  export type ExportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
  }

  export type ExportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ExportWhereInput | ExportWhereInput[]
    OR?: ExportWhereInput[]
    NOT?: ExportWhereInput | ExportWhereInput[]
    content?: JsonFilter<"Export">
    createDate?: DateTimeNullableFilter<"Export"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Export"> | Date | string | null
  }, "id" | "name">

  export type ExportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: ExportCountOrderByAggregateInput
    _avg?: ExportAvgOrderByAggregateInput
    _max?: ExportMaxOrderByAggregateInput
    _min?: ExportMinOrderByAggregateInput
    _sum?: ExportSumOrderByAggregateInput
  }

  export type ExportScalarWhereWithAggregatesInput = {
    AND?: ExportScalarWhereWithAggregatesInput | ExportScalarWhereWithAggregatesInput[]
    OR?: ExportScalarWhereWithAggregatesInput[]
    NOT?: ExportScalarWhereWithAggregatesInput | ExportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Export"> | number
    name?: StringWithAggregatesFilter<"Export"> | string
    content?: JsonWithAggregatesFilter<"Export">
    createDate?: DateTimeNullableWithAggregatesFilter<"Export"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"Export"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    amount?: FloatFilter<"Account"> | number
    status?: EnumAccountStatusFilter<"Account"> | $Enums.AccountStatus
    userId?: IntNullableFilter<"Account"> | number | null
    createDate?: DateTimeFilter<"Account"> | Date | string
    updateDate?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sendertransactions?: TransactionListRelationFilter
    receivertransactions?: TransactionListRelationFilter
    bankaccounts?: BankAccountListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrderInput | SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    user?: UserOrderByWithRelationInput
    sendertransactions?: TransactionOrderByRelationAggregateInput
    receivertransactions?: TransactionOrderByRelationAggregateInput
    bankaccounts?: BankAccountOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    amount?: FloatFilter<"Account"> | number
    status?: EnumAccountStatusFilter<"Account"> | $Enums.AccountStatus
    createDate?: DateTimeFilter<"Account"> | Date | string
    updateDate?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sendertransactions?: TransactionListRelationFilter
    receivertransactions?: TransactionListRelationFilter
    bankaccounts?: BankAccountListRelationFilter
  }, "id" | "userId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrderInput | SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    amount?: FloatWithAggregatesFilter<"Account"> | number
    status?: EnumAccountStatusWithAggregatesFilter<"Account"> | $Enums.AccountStatus
    userId?: IntNullableWithAggregatesFilter<"Account"> | number | null
    createDate?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type AccountApplyWhereInput = {
    AND?: AccountApplyWhereInput | AccountApplyWhereInput[]
    OR?: AccountApplyWhereInput[]
    NOT?: AccountApplyWhereInput | AccountApplyWhereInput[]
    id?: IntFilter<"AccountApply"> | number
    username?: StringNullableFilter<"AccountApply"> | string | null
    firstname?: StringFilter<"AccountApply"> | string
    lastname?: StringFilter<"AccountApply"> | string
    password?: StringFilter<"AccountApply"> | string
    email?: StringFilter<"AccountApply"> | string
    country?: StringFilter<"AccountApply"> | string
    gender?: EnumGenderNullableFilter<"AccountApply"> | $Enums.Gender | null
    status?: EnumAccountApplyStatusFilter<"AccountApply"> | $Enums.AccountApplyStatus
    createDate?: DateTimeNullableFilter<"AccountApply"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"AccountApply"> | Date | string | null
  }

  export type AccountApplyOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    email?: SortOrder
    country?: SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
  }

  export type AccountApplyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountApplyWhereInput | AccountApplyWhereInput[]
    OR?: AccountApplyWhereInput[]
    NOT?: AccountApplyWhereInput | AccountApplyWhereInput[]
    username?: StringNullableFilter<"AccountApply"> | string | null
    firstname?: StringFilter<"AccountApply"> | string
    lastname?: StringFilter<"AccountApply"> | string
    password?: StringFilter<"AccountApply"> | string
    email?: StringFilter<"AccountApply"> | string
    country?: StringFilter<"AccountApply"> | string
    gender?: EnumGenderNullableFilter<"AccountApply"> | $Enums.Gender | null
    status?: EnumAccountApplyStatusFilter<"AccountApply"> | $Enums.AccountApplyStatus
    createDate?: DateTimeNullableFilter<"AccountApply"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"AccountApply"> | Date | string | null
  }, "id">

  export type AccountApplyOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    email?: SortOrder
    country?: SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: AccountApplyCountOrderByAggregateInput
    _avg?: AccountApplyAvgOrderByAggregateInput
    _max?: AccountApplyMaxOrderByAggregateInput
    _min?: AccountApplyMinOrderByAggregateInput
    _sum?: AccountApplySumOrderByAggregateInput
  }

  export type AccountApplyScalarWhereWithAggregatesInput = {
    AND?: AccountApplyScalarWhereWithAggregatesInput | AccountApplyScalarWhereWithAggregatesInput[]
    OR?: AccountApplyScalarWhereWithAggregatesInput[]
    NOT?: AccountApplyScalarWhereWithAggregatesInput | AccountApplyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountApply"> | number
    username?: StringNullableWithAggregatesFilter<"AccountApply"> | string | null
    firstname?: StringWithAggregatesFilter<"AccountApply"> | string
    lastname?: StringWithAggregatesFilter<"AccountApply"> | string
    password?: StringWithAggregatesFilter<"AccountApply"> | string
    email?: StringWithAggregatesFilter<"AccountApply"> | string
    country?: StringWithAggregatesFilter<"AccountApply"> | string
    gender?: EnumGenderNullableWithAggregatesFilter<"AccountApply"> | $Enums.Gender | null
    status?: EnumAccountApplyStatusWithAggregatesFilter<"AccountApply"> | $Enums.AccountApplyStatus
    createDate?: DateTimeNullableWithAggregatesFilter<"AccountApply"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"AccountApply"> | Date | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: IntFilter<"Task"> | number
    name?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    params?: JsonFilter<"Task">
    fromStatus?: EnumTaskStatusNullableListFilter<"Task">
    predecessorTaskId?: IntNullableFilter<"Task"> | number | null
    createDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    predecessorTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    successorTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    params?: SortOrder
    fromStatus?: SortOrder
    predecessorTaskId?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    predecessorTask?: TaskOrderByWithRelationInput
    successorTask?: TaskOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    predecessorTaskId?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    name?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    params?: JsonFilter<"Task">
    fromStatus?: EnumTaskStatusNullableListFilter<"Task">
    createDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    predecessorTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
    successorTask?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }, "id" | "predecessorTaskId">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    params?: SortOrder
    fromStatus?: SortOrder
    predecessorTaskId?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Task"> | number
    name?: StringWithAggregatesFilter<"Task"> | string
    description?: StringWithAggregatesFilter<"Task"> | string
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    params?: JsonWithAggregatesFilter<"Task">
    fromStatus?: EnumTaskStatusNullableListFilter<"Task">
    predecessorTaskId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    createDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
  }

  export type OTPWhereInput = {
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    id?: IntFilter<"OTP"> | number
    OTP?: StringFilter<"OTP"> | string
    email?: StringFilter<"OTP"> | string
    userId?: IntNullableFilter<"OTP"> | number | null
    status?: EnumOTPStatusFilter<"OTP"> | $Enums.OTPStatus
    createDate?: DateTimeNullableFilter<"OTP"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"OTP"> | Date | string | null
    expirationDate?: DateTimeFilter<"OTP"> | Date | string
  }

  export type OTPOrderByWithRelationInput = {
    id?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrder
  }

  export type OTPWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    OTP?: StringFilter<"OTP"> | string
    email?: StringFilter<"OTP"> | string
    userId?: IntNullableFilter<"OTP"> | number | null
    status?: EnumOTPStatusFilter<"OTP"> | $Enums.OTPStatus
    createDate?: DateTimeNullableFilter<"OTP"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"OTP"> | Date | string | null
    expirationDate?: DateTimeFilter<"OTP"> | Date | string
  }, "id">

  export type OTPOrderByWithAggregationInput = {
    id?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrder
    _count?: OTPCountOrderByAggregateInput
    _avg?: OTPAvgOrderByAggregateInput
    _max?: OTPMaxOrderByAggregateInput
    _min?: OTPMinOrderByAggregateInput
    _sum?: OTPSumOrderByAggregateInput
  }

  export type OTPScalarWhereWithAggregatesInput = {
    AND?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    OR?: OTPScalarWhereWithAggregatesInput[]
    NOT?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OTP"> | number
    OTP?: StringWithAggregatesFilter<"OTP"> | string
    email?: StringWithAggregatesFilter<"OTP"> | string
    userId?: IntNullableWithAggregatesFilter<"OTP"> | number | null
    status?: EnumOTPStatusWithAggregatesFilter<"OTP"> | $Enums.OTPStatus
    createDate?: DateTimeNullableWithAggregatesFilter<"OTP"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"OTP"> | Date | string | null
    expirationDate?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
  }

  export type HistoryWhereInput = {
    AND?: HistoryWhereInput | HistoryWhereInput[]
    OR?: HistoryWhereInput[]
    NOT?: HistoryWhereInput | HistoryWhereInput[]
    id?: IntFilter<"History"> | number
    title?: StringNullableFilter<"History"> | string | null
    description?: StringNullableFilter<"History"> | string | null
    originator?: StringNullableFilter<"History"> | string | null
    createDate?: DateTimeNullableFilter<"History"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"History"> | Date | string | null
    type?: EnumHistoryTypeNullableFilter<"History"> | $Enums.HistoryType | null
  }

  export type HistoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    originator?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
  }

  export type HistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistoryWhereInput | HistoryWhereInput[]
    OR?: HistoryWhereInput[]
    NOT?: HistoryWhereInput | HistoryWhereInput[]
    title?: StringNullableFilter<"History"> | string | null
    description?: StringNullableFilter<"History"> | string | null
    originator?: StringNullableFilter<"History"> | string | null
    createDate?: DateTimeNullableFilter<"History"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"History"> | Date | string | null
    type?: EnumHistoryTypeNullableFilter<"History"> | $Enums.HistoryType | null
  }, "id">

  export type HistoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    originator?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: HistoryCountOrderByAggregateInput
    _avg?: HistoryAvgOrderByAggregateInput
    _max?: HistoryMaxOrderByAggregateInput
    _min?: HistoryMinOrderByAggregateInput
    _sum?: HistorySumOrderByAggregateInput
  }

  export type HistoryScalarWhereWithAggregatesInput = {
    AND?: HistoryScalarWhereWithAggregatesInput | HistoryScalarWhereWithAggregatesInput[]
    OR?: HistoryScalarWhereWithAggregatesInput[]
    NOT?: HistoryScalarWhereWithAggregatesInput | HistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"History"> | number
    title?: StringNullableWithAggregatesFilter<"History"> | string | null
    description?: StringNullableWithAggregatesFilter<"History"> | string | null
    originator?: StringNullableWithAggregatesFilter<"History"> | string | null
    createDate?: DateTimeNullableWithAggregatesFilter<"History"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"History"> | Date | string | null
    type?: EnumHistoryTypeNullableWithAggregatesFilter<"History"> | $Enums.HistoryType | null
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: IntFilter<"Job"> | number
    jobname?: StringFilter<"Job"> | string
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    description?: StringFilter<"Job"> | string
    model?: EnumJobModelFilter<"Job"> | $Enums.JobModel
    data?: JsonFilter<"Job">
    createDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Job"> | Date | string | null
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    jobname?: SortOrder
    status?: SortOrder
    description?: SortOrder
    model?: SortOrder
    data?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    jobname?: StringFilter<"Job"> | string
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    description?: StringFilter<"Job"> | string
    model?: EnumJobModelFilter<"Job"> | $Enums.JobModel
    data?: JsonFilter<"Job">
    createDate?: DateTimeNullableFilter<"Job"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Job"> | Date | string | null
  }, "id">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    jobname?: SortOrder
    status?: SortOrder
    description?: SortOrder
    model?: SortOrder
    data?: SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Job"> | number
    jobname?: StringWithAggregatesFilter<"Job"> | string
    status?: EnumJobStatusWithAggregatesFilter<"Job"> | $Enums.JobStatus
    description?: StringWithAggregatesFilter<"Job"> | string
    model?: EnumJobModelWithAggregatesFilter<"Job"> | $Enums.JobModel
    data?: JsonWithAggregatesFilter<"Job">
    createDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    transactionid?: StringFilter<"Transaction"> | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    statusMessage?: StringFilter<"Transaction"> | string
    isBankTransaction?: BoolFilter<"Transaction"> | boolean
    senderAmount?: FloatFilter<"Transaction"> | number
    receiverAmount?: FloatNullableFilter<"Transaction"> | number | null
    senderAccountAmount?: FloatFilter<"Transaction"> | number
    receiverAccountAmount?: FloatNullableFilter<"Transaction"> | number | null
    senderAccountId?: IntFilter<"Transaction"> | number
    receiverAccountId?: IntNullableFilter<"Transaction"> | number | null
    sender?: StringNullableFilter<"Transaction"> | string | null
    receiver?: StringNullableFilter<"Transaction"> | string | null
    message?: StringNullableFilter<"Transaction"> | string | null
    createDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    senderAccount?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    receiverAccount?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionid?: SortOrder
    status?: SortOrder
    statusMessage?: SortOrder
    isBankTransaction?: SortOrder
    senderAmount?: SortOrder
    receiverAmount?: SortOrderInput | SortOrder
    senderAccountAmount?: SortOrder
    receiverAccountAmount?: SortOrderInput | SortOrder
    senderAccountId?: SortOrder
    receiverAccountId?: SortOrderInput | SortOrder
    sender?: SortOrderInput | SortOrder
    receiver?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    senderAccount?: AccountOrderByWithRelationInput
    receiverAccount?: AccountOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    transactionid?: StringFilter<"Transaction"> | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    statusMessage?: StringFilter<"Transaction"> | string
    isBankTransaction?: BoolFilter<"Transaction"> | boolean
    senderAmount?: FloatFilter<"Transaction"> | number
    receiverAmount?: FloatNullableFilter<"Transaction"> | number | null
    senderAccountAmount?: FloatFilter<"Transaction"> | number
    receiverAccountAmount?: FloatNullableFilter<"Transaction"> | number | null
    senderAccountId?: IntFilter<"Transaction"> | number
    receiverAccountId?: IntNullableFilter<"Transaction"> | number | null
    sender?: StringNullableFilter<"Transaction"> | string | null
    receiver?: StringNullableFilter<"Transaction"> | string | null
    message?: StringNullableFilter<"Transaction"> | string | null
    createDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    senderAccount?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    receiverAccount?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionid?: SortOrder
    status?: SortOrder
    statusMessage?: SortOrder
    isBankTransaction?: SortOrder
    senderAmount?: SortOrder
    receiverAmount?: SortOrderInput | SortOrder
    senderAccountAmount?: SortOrder
    receiverAccountAmount?: SortOrderInput | SortOrder
    senderAccountId?: SortOrder
    receiverAccountId?: SortOrderInput | SortOrder
    sender?: SortOrderInput | SortOrder
    receiver?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    updateDate?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    transactionid?: StringWithAggregatesFilter<"Transaction"> | string
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    statusMessage?: StringWithAggregatesFilter<"Transaction"> | string
    isBankTransaction?: BoolWithAggregatesFilter<"Transaction"> | boolean
    senderAmount?: FloatWithAggregatesFilter<"Transaction"> | number
    receiverAmount?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    senderAccountAmount?: FloatWithAggregatesFilter<"Transaction"> | number
    receiverAccountAmount?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    senderAccountId?: IntWithAggregatesFilter<"Transaction"> | number
    receiverAccountId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    sender?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    receiver?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    message?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    updateDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: IntFilter<"BankAccount"> | number
    IBAN?: StringFilter<"BankAccount"> | string
    status?: EnumIBANStatusFilter<"BankAccount"> | $Enums.IBANStatus
    createDate?: DateTimeFilter<"BankAccount"> | Date | string
    updateDate?: DateTimeFilter<"BankAccount"> | Date | string
    accountId?: IntFilter<"BankAccount"> | number
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    IBAN?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    accountId?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    IBAN?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    status?: EnumIBANStatusFilter<"BankAccount"> | $Enums.IBANStatus
    createDate?: DateTimeFilter<"BankAccount"> | Date | string
    updateDate?: DateTimeFilter<"BankAccount"> | Date | string
    accountId?: IntFilter<"BankAccount"> | number
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
  }, "id" | "IBAN">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    IBAN?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    accountId?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BankAccount"> | number
    IBAN?: StringWithAggregatesFilter<"BankAccount"> | string
    status?: EnumIBANStatusWithAggregatesFilter<"BankAccount"> | $Enums.IBANStatus
    createDate?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    accountId?: IntWithAggregatesFilter<"BankAccount"> | number
  }

  export type ServiceCreateInput = {
    servicename: string
    serviceactions?: ServiceActionCreateNestedManyWithoutServicesInput
    servicestatements?: ServiceStatementCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    servicename: string
    serviceactions?: ServiceActionUncheckedCreateNestedManyWithoutServicesInput
    servicestatements?: ServiceStatementUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    servicename?: StringFieldUpdateOperationsInput | string
    serviceactions?: ServiceActionUpdateManyWithoutServicesNestedInput
    servicestatements?: ServiceStatementUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicename?: StringFieldUpdateOperationsInput | string
    serviceactions?: ServiceActionUncheckedUpdateManyWithoutServicesNestedInput
    servicestatements?: ServiceStatementUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    servicename: string
  }

  export type ServiceUpdateManyMutationInput = {
    servicename?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicename?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceActionCreateInput = {
    serviceactionname: string
    services?: ServiceCreateNestedManyWithoutServiceactionsInput
    serviceStatementActions?: ServiceStatementActionCreateNestedManyWithoutServiceactionInput
  }

  export type ServiceActionUncheckedCreateInput = {
    id?: number
    serviceactionname: string
    services?: ServiceUncheckedCreateNestedManyWithoutServiceactionsInput
    serviceStatementActions?: ServiceStatementActionUncheckedCreateNestedManyWithoutServiceactionInput
  }

  export type ServiceActionUpdateInput = {
    serviceactionname?: StringFieldUpdateOperationsInput | string
    services?: ServiceUpdateManyWithoutServiceactionsNestedInput
    serviceStatementActions?: ServiceStatementActionUpdateManyWithoutServiceactionNestedInput
  }

  export type ServiceActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceactionname?: StringFieldUpdateOperationsInput | string
    services?: ServiceUncheckedUpdateManyWithoutServiceactionsNestedInput
    serviceStatementActions?: ServiceStatementActionUncheckedUpdateManyWithoutServiceactionNestedInput
  }

  export type ServiceActionCreateManyInput = {
    id?: number
    serviceactionname: string
  }

  export type ServiceActionUpdateManyMutationInput = {
    serviceactionname?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceactionname?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceStatementActionCreateInput = {
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatement: ServiceStatementCreateNestedOneWithoutServicestatementactionsInput
    serviceaction: ServiceActionCreateNestedOneWithoutServiceStatementActionsInput
  }

  export type ServiceStatementActionUncheckedCreateInput = {
    id?: number
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    statementid: number
    serviceactionid: number
  }

  export type ServiceStatementActionUpdateInput = {
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatement?: ServiceStatementUpdateOneRequiredWithoutServicestatementactionsNestedInput
    serviceaction?: ServiceActionUpdateOneRequiredWithoutServiceStatementActionsNestedInput
  }

  export type ServiceStatementActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statementid?: IntFieldUpdateOperationsInput | number
    serviceactionid?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceStatementActionCreateManyInput = {
    id?: number
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    statementid: number
    serviceactionid: number
  }

  export type ServiceStatementActionUpdateManyMutationInput = {
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceStatementActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statementid?: IntFieldUpdateOperationsInput | number
    serviceactionid?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceStatementCreateInput = {
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    service: ServiceCreateNestedOneWithoutServicestatementsInput
    servicestatementactions?: ServiceStatementActionCreateNestedManyWithoutServicestatementInput
    policies?: PolicyCreateNestedManyWithoutServicestatementsInput
  }

  export type ServiceStatementUncheckedCreateInput = {
    id?: number
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    serviceid: number
    servicestatementactions?: ServiceStatementActionUncheckedCreateNestedManyWithoutServicestatementInput
    policies?: PolicyUncheckedCreateNestedManyWithoutServicestatementsInput
  }

  export type ServiceStatementUpdateInput = {
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: ServiceUpdateOneRequiredWithoutServicestatementsNestedInput
    servicestatementactions?: ServiceStatementActionUpdateManyWithoutServicestatementNestedInput
    policies?: PolicyUpdateManyWithoutServicestatementsNestedInput
  }

  export type ServiceStatementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceid?: IntFieldUpdateOperationsInput | number
    servicestatementactions?: ServiceStatementActionUncheckedUpdateManyWithoutServicestatementNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutServicestatementsNestedInput
  }

  export type ServiceStatementCreateManyInput = {
    id?: number
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    serviceid: number
  }

  export type ServiceStatementUpdateManyMutationInput = {
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceStatementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceid?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateCreateInput = {
    role?: $Enums.TemplateRole | null
    name: string
    description?: string | null
    content: string
    asHtml?: boolean | null
    fromFile?: boolean | null
    parameters?: string | null
    managed?: boolean | null
  }

  export type TemplateUncheckedCreateInput = {
    id?: number
    role?: $Enums.TemplateRole | null
    name: string
    description?: string | null
    content: string
    asHtml?: boolean | null
    fromFile?: boolean | null
    parameters?: string | null
    managed?: boolean | null
  }

  export type TemplateUpdateInput = {
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asHtml?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fromFile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asHtml?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fromFile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TemplateCreateManyInput = {
    id?: number
    role?: $Enums.TemplateRole | null
    name: string
    description?: string | null
    content: string
    asHtml?: boolean | null
    fromFile?: boolean | null
    parameters?: string | null
    managed?: boolean | null
  }

  export type TemplateUpdateManyMutationInput = {
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asHtml?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fromFile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: NullableEnumTemplateRoleFieldUpdateOperationsInput | $Enums.TemplateRole | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    asHtml?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fromFile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PolicyCreateInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatements?: ServiceStatementCreateNestedManyWithoutPoliciesInput
    roles?: RoleCreateNestedManyWithoutPoliciesInput
    users?: UserCreateNestedManyWithoutPoliciesInput
    groups?: GroupCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatements?: ServiceStatementUncheckedCreateNestedManyWithoutPoliciesInput
    roles?: RoleUncheckedCreateNestedManyWithoutPoliciesInput
    users?: UserUncheckedCreateNestedManyWithoutPoliciesInput
    groups?: GroupUncheckedCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatements?: ServiceStatementUpdateManyWithoutPoliciesNestedInput
    roles?: RoleUpdateManyWithoutPoliciesNestedInput
    users?: UserUpdateManyWithoutPoliciesNestedInput
    groups?: GroupUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatements?: ServiceStatementUncheckedUpdateManyWithoutPoliciesNestedInput
    roles?: RoleUncheckedUpdateManyWithoutPoliciesNestedInput
    users?: UserUncheckedUpdateManyWithoutPoliciesNestedInput
    groups?: GroupUncheckedUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type PolicyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingCreateInput = {
    type: string
    subtype: string
    key: string
    value: string
  }

  export type SettingUncheckedCreateInput = {
    id?: number
    type: string
    subtype: string
    key: string
    value: string
  }

  export type SettingUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingCreateManyInput = {
    id?: number
    type: string
    subtype: string
    key: string
    value: string
  }

  export type SettingUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyCreateNestedManyWithoutRolesInput
    users?: UserCreateNestedManyWithoutRolesInput
    groups?: GroupCreateNestedManyWithoutRolesInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyUncheckedCreateNestedManyWithoutRolesInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    groups?: GroupUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUpdateManyWithoutRolesNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    groups?: GroupUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUncheckedUpdateManyWithoutRolesNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    groups?: GroupUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCreateInput = {
    name: string
    dialCode?: string | null
    code?: string | null
    currency?: string | null
    currencycode?: string | null
    symbol?: string | null
    addresses?: AddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    name: string
    dialCode?: string | null
    code?: string | null
    currency?: string | null
    currencycode?: string | null
    symbol?: string | null
    addresses?: AddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencycode?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencycode?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    name: string
    dialCode?: string | null
    code?: string | null
    currency?: string | null
    currencycode?: string | null
    symbol?: string | null
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencycode?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencycode?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressCreateInput = {
    street?: string | null
    number?: string | null
    box?: string | null
    city?: string | null
    postalcode?: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    county?: string | null
    country?: CountryCreateNestedOneWithoutAddressesInput
    user?: UserCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    street?: string | null
    number?: string | null
    box?: string | null
    city?: string | null
    postalcode?: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    county?: string | null
    countryId?: number | null
    userId?: number | null
  }

  export type AddressUpdateInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutAddressesNestedInput
    user?: UserUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AddressCreateManyInput = {
    id?: number
    street?: string | null
    number?: string | null
    box?: string | null
    city?: string | null
    postalcode?: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    county?: string | null
    countryId?: number | null
    userId?: number | null
  }

  export type AddressUpdateManyMutationInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressCreateNestedOneWithoutUserInput
    policies?: PolicyCreateNestedManyWithoutUsersInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
    account?: AccountCreateNestedOneWithoutUserInput
    settings?: UserSettingCreateNestedManyWithoutUsersInput
    pats?: UserPATCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    policies?: PolicyUncheckedCreateNestedManyWithoutUsersInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingUncheckedCreateNestedManyWithoutUsersInput
    pats?: UserPATUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    policies?: PolicyUpdateManyWithoutUsersNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    settings?: UserSettingUpdateManyWithoutUsersNestedInput
    pats?: UserPATUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutUsersNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingUncheckedUpdateManyWithoutUsersNestedInput
    pats?: UserPATUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPATCreateInput = {
    tokenName: string
    token: string
    createDate?: Date | string | null
    expirationDate: Date | string
    tokenStatus: $Enums.TokenStatus
    user: UserCreateNestedOneWithoutPatsInput
  }

  export type UserPATUncheckedCreateInput = {
    id?: number
    tokenName: string
    token: string
    createDate?: Date | string | null
    expirationDate: Date | string
    tokenStatus: $Enums.TokenStatus
    userId: number
  }

  export type UserPATUpdateInput = {
    tokenName?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenStatus?: EnumTokenStatusFieldUpdateOperationsInput | $Enums.TokenStatus
    user?: UserUpdateOneRequiredWithoutPatsNestedInput
  }

  export type UserPATUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenName?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenStatus?: EnumTokenStatusFieldUpdateOperationsInput | $Enums.TokenStatus
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPATCreateManyInput = {
    id?: number
    tokenName: string
    token: string
    createDate?: Date | string | null
    expirationDate: Date | string
    tokenStatus: $Enums.TokenStatus
    userId: number
  }

  export type UserPATUpdateManyMutationInput = {
    tokenName?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenStatus?: EnumTokenStatusFieldUpdateOperationsInput | $Enums.TokenStatus
  }

  export type UserPATUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenName?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenStatus?: EnumTokenStatusFieldUpdateOperationsInput | $Enums.TokenStatus
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserSettingCreateInput = {
    key: string
    value: string
    users?: UserCreateNestedManyWithoutSettingsInput
  }

  export type UserSettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    users?: UserUncheckedCreateNestedManyWithoutSettingsInput
  }

  export type UserSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutSettingsNestedInput
  }

  export type UserSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutSettingsNestedInput
  }

  export type UserSettingCreateManyInput = {
    id?: number
    key: string
    value: string
  }

  export type UserSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type GroupCreateInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyCreateNestedManyWithoutGroupsInput
    roles?: RoleCreateNestedManyWithoutGroupsInput
    users?: UserCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyUncheckedCreateNestedManyWithoutGroupsInput
    roles?: RoleUncheckedCreateNestedManyWithoutGroupsInput
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUpdateManyWithoutGroupsNestedInput
    roles?: RoleUpdateManyWithoutGroupsNestedInput
    users?: UserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUncheckedUpdateManyWithoutGroupsNestedInput
    roles?: RoleUncheckedUpdateManyWithoutGroupsNestedInput
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type GroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportCreateInput = {
    name: string
    content: JsonNullValueInput | InputJsonValue
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type ExportUncheckedCreateInput = {
    id?: number
    name: string
    content: JsonNullValueInput | InputJsonValue
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type ExportUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportCreateManyInput = {
    id?: number
    name: string
    content: JsonNullValueInput | InputJsonValue
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type ExportUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    amount: number
    status?: $Enums.AccountStatus
    createDate?: Date | string
    updateDate?: Date | string
    user?: UserCreateNestedOneWithoutAccountInput
    sendertransactions?: TransactionCreateNestedManyWithoutSenderAccountInput
    receivertransactions?: TransactionCreateNestedManyWithoutReceiverAccountInput
    bankaccounts?: BankAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    amount: number
    status?: $Enums.AccountStatus
    userId?: number | null
    createDate?: Date | string
    updateDate?: Date | string
    sendertransactions?: TransactionUncheckedCreateNestedManyWithoutSenderAccountInput
    receivertransactions?: TransactionUncheckedCreateNestedManyWithoutReceiverAccountInput
    bankaccounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountNestedInput
    sendertransactions?: TransactionUpdateManyWithoutSenderAccountNestedInput
    receivertransactions?: TransactionUpdateManyWithoutReceiverAccountNestedInput
    bankaccounts?: BankAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendertransactions?: TransactionUncheckedUpdateManyWithoutSenderAccountNestedInput
    receivertransactions?: TransactionUncheckedUpdateManyWithoutReceiverAccountNestedInput
    bankaccounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: number
    amount: number
    status?: $Enums.AccountStatus
    userId?: number | null
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountApplyCreateInput = {
    username?: string | null
    firstname: string
    lastname: string
    password: string
    email: string
    country: string
    gender?: $Enums.Gender | null
    status?: $Enums.AccountApplyStatus
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type AccountApplyUncheckedCreateInput = {
    id?: number
    username?: string | null
    firstname: string
    lastname: string
    password: string
    email: string
    country: string
    gender?: $Enums.Gender | null
    status?: $Enums.AccountApplyStatus
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type AccountApplyUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumAccountApplyStatusFieldUpdateOperationsInput | $Enums.AccountApplyStatus
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountApplyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumAccountApplyStatusFieldUpdateOperationsInput | $Enums.AccountApplyStatus
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountApplyCreateManyInput = {
    id?: number
    username?: string | null
    firstname: string
    lastname: string
    password: string
    email: string
    country: string
    gender?: $Enums.Gender | null
    status?: $Enums.AccountApplyStatus
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type AccountApplyUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumAccountApplyStatusFieldUpdateOperationsInput | $Enums.AccountApplyStatus
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountApplyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumAccountApplyStatusFieldUpdateOperationsInput | $Enums.AccountApplyStatus
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskCreateInput = {
    name: string
    description: string
    status?: $Enums.TaskStatus
    params: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskCreatefromStatusInput | $Enums.TaskStatus[]
    createDate?: Date | string | null
    updateDate?: Date | string | null
    predecessorTask?: TaskCreateNestedOneWithoutSuccessorTaskInput
    successorTask?: TaskCreateNestedOneWithoutPredecessorTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    status?: $Enums.TaskStatus
    params: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskCreatefromStatusInput | $Enums.TaskStatus[]
    predecessorTaskId?: number | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    successorTask?: TaskUncheckedCreateNestedOneWithoutPredecessorTaskInput
  }

  export type TaskUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    params?: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskUpdatefromStatusInput | $Enums.TaskStatus[]
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    predecessorTask?: TaskUpdateOneWithoutSuccessorTaskNestedInput
    successorTask?: TaskUpdateOneWithoutPredecessorTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    params?: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskUpdatefromStatusInput | $Enums.TaskStatus[]
    predecessorTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successorTask?: TaskUncheckedUpdateOneWithoutPredecessorTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: number
    name: string
    description: string
    status?: $Enums.TaskStatus
    params: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskCreatefromStatusInput | $Enums.TaskStatus[]
    predecessorTaskId?: number | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type TaskUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    params?: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskUpdatefromStatusInput | $Enums.TaskStatus[]
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    params?: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskUpdatefromStatusInput | $Enums.TaskStatus[]
    predecessorTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OTPCreateInput = {
    OTP: string
    email: string
    userId?: number | null
    status?: $Enums.OTPStatus
    createDate?: Date | string | null
    updateDate?: Date | string | null
    expirationDate?: Date | string
  }

  export type OTPUncheckedCreateInput = {
    id?: number
    OTP: string
    email: string
    userId?: number | null
    status?: $Enums.OTPStatus
    createDate?: Date | string | null
    updateDate?: Date | string | null
    expirationDate?: Date | string
  }

  export type OTPUpdateInput = {
    OTP?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOTPStatusFieldUpdateOperationsInput | $Enums.OTPStatus
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    OTP?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOTPStatusFieldUpdateOperationsInput | $Enums.OTPStatus
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCreateManyInput = {
    id?: number
    OTP: string
    email: string
    userId?: number | null
    status?: $Enums.OTPStatus
    createDate?: Date | string | null
    updateDate?: Date | string | null
    expirationDate?: Date | string
  }

  export type OTPUpdateManyMutationInput = {
    OTP?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOTPStatusFieldUpdateOperationsInput | $Enums.OTPStatus
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    OTP?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOTPStatusFieldUpdateOperationsInput | $Enums.OTPStatus
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoryCreateInput = {
    title?: string | null
    description?: string | null
    originator?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    type?: $Enums.HistoryType | null
  }

  export type HistoryUncheckedCreateInput = {
    id?: number
    title?: string | null
    description?: string | null
    originator?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    type?: $Enums.HistoryType | null
  }

  export type HistoryUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    originator?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumHistoryTypeFieldUpdateOperationsInput | $Enums.HistoryType | null
  }

  export type HistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    originator?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumHistoryTypeFieldUpdateOperationsInput | $Enums.HistoryType | null
  }

  export type HistoryCreateManyInput = {
    id?: number
    title?: string | null
    description?: string | null
    originator?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    type?: $Enums.HistoryType | null
  }

  export type HistoryUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    originator?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumHistoryTypeFieldUpdateOperationsInput | $Enums.HistoryType | null
  }

  export type HistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    originator?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumHistoryTypeFieldUpdateOperationsInput | $Enums.HistoryType | null
  }

  export type JobCreateInput = {
    jobname: string
    status?: $Enums.JobStatus
    description: string
    model?: $Enums.JobModel
    data: JsonNullValueInput | InputJsonValue
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type JobUncheckedCreateInput = {
    id?: number
    jobname: string
    status?: $Enums.JobStatus
    description: string
    model?: $Enums.JobModel
    data: JsonNullValueInput | InputJsonValue
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type JobUpdateInput = {
    jobname?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    description?: StringFieldUpdateOperationsInput | string
    model?: EnumJobModelFieldUpdateOperationsInput | $Enums.JobModel
    data?: JsonNullValueInput | InputJsonValue
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobname?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    description?: StringFieldUpdateOperationsInput | string
    model?: EnumJobModelFieldUpdateOperationsInput | $Enums.JobModel
    data?: JsonNullValueInput | InputJsonValue
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobCreateManyInput = {
    id?: number
    jobname: string
    status?: $Enums.JobStatus
    description: string
    model?: $Enums.JobModel
    data: JsonNullValueInput | InputJsonValue
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type JobUpdateManyMutationInput = {
    jobname?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    description?: StringFieldUpdateOperationsInput | string
    model?: EnumJobModelFieldUpdateOperationsInput | $Enums.JobModel
    data?: JsonNullValueInput | InputJsonValue
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobname?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    description?: StringFieldUpdateOperationsInput | string
    model?: EnumJobModelFieldUpdateOperationsInput | $Enums.JobModel
    data?: JsonNullValueInput | InputJsonValue
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateInput = {
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    senderAccount?: AccountCreateNestedOneWithoutSendertransactionsInput
    receiverAccount?: AccountCreateNestedOneWithoutReceivertransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    senderAccountId: number
    receiverAccountId?: number | null
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type TransactionUpdateInput = {
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderAccount?: AccountUpdateOneWithoutSendertransactionsNestedInput
    receiverAccount?: AccountUpdateOneWithoutReceivertransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountId?: IntFieldUpdateOperationsInput | number
    receiverAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyInput = {
    id?: number
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    senderAccountId: number
    receiverAccountId?: number | null
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountId?: IntFieldUpdateOperationsInput | number
    receiverAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BankAccountCreateInput = {
    IBAN: string
    status: $Enums.IBANStatus
    createDate?: Date | string
    updateDate?: Date | string
    account?: AccountCreateNestedOneWithoutBankaccountsInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: number
    IBAN: string
    status: $Enums.IBANStatus
    createDate?: Date | string
    updateDate?: Date | string
    accountId: number
  }

  export type BankAccountUpdateInput = {
    IBAN?: StringFieldUpdateOperationsInput | string
    status?: EnumIBANStatusFieldUpdateOperationsInput | $Enums.IBANStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutBankaccountsNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    IBAN?: StringFieldUpdateOperationsInput | string
    status?: EnumIBANStatusFieldUpdateOperationsInput | $Enums.IBANStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: IntFieldUpdateOperationsInput | number
  }

  export type BankAccountCreateManyInput = {
    id?: number
    IBAN: string
    status: $Enums.IBANStatus
    createDate?: Date | string
    updateDate?: Date | string
    accountId: number
  }

  export type BankAccountUpdateManyMutationInput = {
    IBAN?: StringFieldUpdateOperationsInput | string
    status?: EnumIBANStatusFieldUpdateOperationsInput | $Enums.IBANStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    IBAN?: StringFieldUpdateOperationsInput | string
    status?: EnumIBANStatusFieldUpdateOperationsInput | $Enums.IBANStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ServiceActionListRelationFilter = {
    every?: ServiceActionWhereInput
    some?: ServiceActionWhereInput
    none?: ServiceActionWhereInput
  }

  export type ServiceStatementListRelationFilter = {
    every?: ServiceStatementWhereInput
    some?: ServiceStatementWhereInput
    none?: ServiceStatementWhereInput
  }

  export type ServiceActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceStatementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    servicename?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    servicename?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    servicename?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceStatementActionListRelationFilter = {
    every?: ServiceStatementActionWhereInput
    some?: ServiceStatementActionWhereInput
    none?: ServiceStatementActionWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceStatementActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceActionCountOrderByAggregateInput = {
    id?: SortOrder
    serviceactionname?: SortOrder
  }

  export type ServiceActionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceActionMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceactionname?: SortOrder
  }

  export type ServiceActionMinOrderByAggregateInput = {
    id?: SortOrder
    serviceactionname?: SortOrder
  }

  export type ServiceActionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ServiceStatementScalarRelationFilter = {
    is?: ServiceStatementWhereInput
    isNot?: ServiceStatementWhereInput
  }

  export type ServiceActionScalarRelationFilter = {
    is?: ServiceActionWhereInput
    isNot?: ServiceActionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ServiceStatementActionCountOrderByAggregateInput = {
    id?: SortOrder
    ssactionname?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    statementid?: SortOrder
    serviceactionid?: SortOrder
  }

  export type ServiceStatementActionAvgOrderByAggregateInput = {
    id?: SortOrder
    statementid?: SortOrder
    serviceactionid?: SortOrder
  }

  export type ServiceStatementActionMaxOrderByAggregateInput = {
    id?: SortOrder
    ssactionname?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    statementid?: SortOrder
    serviceactionid?: SortOrder
  }

  export type ServiceStatementActionMinOrderByAggregateInput = {
    id?: SortOrder
    ssactionname?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    statementid?: SortOrder
    serviceactionid?: SortOrder
  }

  export type ServiceStatementActionSumOrderByAggregateInput = {
    id?: SortOrder
    statementid?: SortOrder
    serviceactionid?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPermissionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPermissionNullableFilter<$PrismaModel> | $Enums.Permission | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type PolicyListRelationFilter = {
    every?: PolicyWhereInput
    some?: PolicyWhereInput
    none?: PolicyWhereInput
  }

  export type PolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceStatementCountOrderByAggregateInput = {
    id?: SortOrder
    ssname?: SortOrder
    description?: SortOrder
    permission?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    serviceid?: SortOrder
  }

  export type ServiceStatementAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceid?: SortOrder
  }

  export type ServiceStatementMaxOrderByAggregateInput = {
    id?: SortOrder
    ssname?: SortOrder
    description?: SortOrder
    permission?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    serviceid?: SortOrder
  }

  export type ServiceStatementMinOrderByAggregateInput = {
    id?: SortOrder
    ssname?: SortOrder
    description?: SortOrder
    permission?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    serviceid?: SortOrder
  }

  export type ServiceStatementSumOrderByAggregateInput = {
    id?: SortOrder
    serviceid?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPermissionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPermissionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Permission | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPermissionNullableFilter<$PrismaModel>
    _max?: NestedEnumPermissionNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumTemplateRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateRole | EnumTemplateRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateRoleNullableFilter<$PrismaModel> | $Enums.TemplateRole | null
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    asHtml?: SortOrder
    fromFile?: SortOrder
    parameters?: SortOrder
    managed?: SortOrder
  }

  export type TemplateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    asHtml?: SortOrder
    fromFile?: SortOrder
    parameters?: SortOrder
    managed?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    asHtml?: SortOrder
    fromFile?: SortOrder
    parameters?: SortOrder
    managed?: SortOrder
  }

  export type TemplateSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTemplateRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateRole | EnumTemplateRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.TemplateRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTemplateRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumTemplateRoleNullableFilter<$PrismaModel>
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dialCode?: SortOrder
    code?: SortOrder
    currency?: SortOrder
    currencycode?: SortOrder
    symbol?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dialCode?: SortOrder
    code?: SortOrder
    currency?: SortOrder
    currencycode?: SortOrder
    symbol?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    dialCode?: SortOrder
    code?: SortOrder
    currency?: SortOrder
    currencycode?: SortOrder
    symbol?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CountryNullableScalarRelationFilter = {
    is?: CountryWhereInput | null
    isNot?: CountryWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    box?: SortOrder
    city?: SortOrder
    postalcode?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    county?: SortOrder
    countryId?: SortOrder
    userId?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    userId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    box?: SortOrder
    city?: SortOrder
    postalcode?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    county?: SortOrder
    countryId?: SortOrder
    userId?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    box?: SortOrder
    city?: SortOrder
    postalcode?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    county?: SortOrder
    countryId?: SortOrder
    userId?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type UserSettingListRelationFilter = {
    every?: UserSettingWhereInput
    some?: UserSettingWhereInput
    none?: UserSettingWhereInput
  }

  export type UserPATListRelationFilter = {
    every?: UserPATWhereInput
    some?: UserPATWhereInput
    none?: UserPATWhereInput
  }

  export type UserSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPATOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFirstnameLastnameCompoundUniqueInput = {
    firstname: string
    lastname: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    firstname?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordless?: SortOrder
    attemps?: SortOrder
    blocked?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    loggedinDate?: SortOrder
    type?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    attemps?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    firstname?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordless?: SortOrder
    attemps?: SortOrder
    blocked?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    loggedinDate?: SortOrder
    type?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    lastname?: SortOrder
    firstname?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordless?: SortOrder
    attemps?: SortOrder
    blocked?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    loggedinDate?: SortOrder
    type?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    attemps?: SortOrder
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumTokenStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenStatus | EnumTokenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TokenStatus[] | ListEnumTokenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenStatus[] | ListEnumTokenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenStatusFilter<$PrismaModel> | $Enums.TokenStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserPATCountOrderByAggregateInput = {
    id?: SortOrder
    tokenName?: SortOrder
    token?: SortOrder
    createDate?: SortOrder
    expirationDate?: SortOrder
    tokenStatus?: SortOrder
    userId?: SortOrder
  }

  export type UserPATAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserPATMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenName?: SortOrder
    token?: SortOrder
    createDate?: SortOrder
    expirationDate?: SortOrder
    tokenStatus?: SortOrder
    userId?: SortOrder
  }

  export type UserPATMinOrderByAggregateInput = {
    id?: SortOrder
    tokenName?: SortOrder
    token?: SortOrder
    createDate?: SortOrder
    expirationDate?: SortOrder
    tokenStatus?: SortOrder
    userId?: SortOrder
  }

  export type UserPATSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTokenStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenStatus | EnumTokenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TokenStatus[] | ListEnumTokenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenStatus[] | ListEnumTokenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenStatusWithAggregatesFilter<$PrismaModel> | $Enums.TokenStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenStatusFilter<$PrismaModel>
    _max?: NestedEnumTokenStatusFilter<$PrismaModel>
  }

  export type UserSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type UserSettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type UserSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type UserSettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managed?: SortOrder
    system?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ExportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type ExportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type ExportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type ExportSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type BankAccountListRelationFilter = {
    every?: BankAccountWhereInput
    some?: BankAccountWhereInput
    none?: BankAccountWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumAccountApplyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountApplyStatus | EnumAccountApplyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountApplyStatus[] | ListEnumAccountApplyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountApplyStatus[] | ListEnumAccountApplyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountApplyStatusFilter<$PrismaModel> | $Enums.AccountApplyStatus
  }

  export type AccountApplyCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    email?: SortOrder
    country?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type AccountApplyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountApplyMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    email?: SortOrder
    country?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type AccountApplyMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
    email?: SortOrder
    country?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type AccountApplySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumAccountApplyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountApplyStatus | EnumAccountApplyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountApplyStatus[] | ListEnumAccountApplyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountApplyStatus[] | ListEnumAccountApplyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountApplyStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountApplyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountApplyStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountApplyStatusFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type EnumTaskStatusNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    has?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    hasSome?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    params?: SortOrder
    fromStatus?: SortOrder
    predecessorTaskId?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    predecessorTaskId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    predecessorTaskId?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    predecessorTaskId?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    predecessorTaskId?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumOTPStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPStatus | EnumOTPStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OTPStatus[] | ListEnumOTPStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPStatus[] | ListEnumOTPStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPStatusFilter<$PrismaModel> | $Enums.OTPStatus
  }

  export type OTPCountOrderByAggregateInput = {
    id?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    expirationDate?: SortOrder
  }

  export type OTPAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OTPMaxOrderByAggregateInput = {
    id?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    expirationDate?: SortOrder
  }

  export type OTPMinOrderByAggregateInput = {
    id?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    expirationDate?: SortOrder
  }

  export type OTPSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumOTPStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPStatus | EnumOTPStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OTPStatus[] | ListEnumOTPStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPStatus[] | ListEnumOTPStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPStatusWithAggregatesFilter<$PrismaModel> | $Enums.OTPStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPStatusFilter<$PrismaModel>
    _max?: NestedEnumOTPStatusFilter<$PrismaModel>
  }

  export type EnumHistoryTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HistoryType | EnumHistoryTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.HistoryType[] | ListEnumHistoryTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HistoryType[] | ListEnumHistoryTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHistoryTypeNullableFilter<$PrismaModel> | $Enums.HistoryType | null
  }

  export type HistoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    originator?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    type?: SortOrder
  }

  export type HistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    originator?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    type?: SortOrder
  }

  export type HistoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    originator?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    type?: SortOrder
  }

  export type HistorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumHistoryTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HistoryType | EnumHistoryTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.HistoryType[] | ListEnumHistoryTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HistoryType[] | ListEnumHistoryTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHistoryTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.HistoryType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHistoryTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumHistoryTypeNullableFilter<$PrismaModel>
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type EnumJobModelFilter<$PrismaModel = never> = {
    equals?: $Enums.JobModel | EnumJobModelFieldRefInput<$PrismaModel>
    in?: $Enums.JobModel[] | ListEnumJobModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobModel[] | ListEnumJobModelFieldRefInput<$PrismaModel>
    not?: NestedEnumJobModelFilter<$PrismaModel> | $Enums.JobModel
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    jobname?: SortOrder
    status?: SortOrder
    description?: SortOrder
    model?: SortOrder
    data?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    jobname?: SortOrder
    status?: SortOrder
    description?: SortOrder
    model?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    jobname?: SortOrder
    status?: SortOrder
    description?: SortOrder
    model?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type EnumJobModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobModel | EnumJobModelFieldRefInput<$PrismaModel>
    in?: $Enums.JobModel[] | ListEnumJobModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobModel[] | ListEnumJobModelFieldRefInput<$PrismaModel>
    not?: NestedEnumJobModelWithAggregatesFilter<$PrismaModel> | $Enums.JobModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobModelFilter<$PrismaModel>
    _max?: NestedEnumJobModelFilter<$PrismaModel>
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionid?: SortOrder
    status?: SortOrder
    statusMessage?: SortOrder
    isBankTransaction?: SortOrder
    senderAmount?: SortOrder
    receiverAmount?: SortOrder
    senderAccountAmount?: SortOrder
    receiverAccountAmount?: SortOrder
    senderAccountId?: SortOrder
    receiverAccountId?: SortOrder
    sender?: SortOrder
    receiver?: SortOrder
    message?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    senderAmount?: SortOrder
    receiverAmount?: SortOrder
    senderAccountAmount?: SortOrder
    receiverAccountAmount?: SortOrder
    senderAccountId?: SortOrder
    receiverAccountId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionid?: SortOrder
    status?: SortOrder
    statusMessage?: SortOrder
    isBankTransaction?: SortOrder
    senderAmount?: SortOrder
    receiverAmount?: SortOrder
    senderAccountAmount?: SortOrder
    receiverAccountAmount?: SortOrder
    senderAccountId?: SortOrder
    receiverAccountId?: SortOrder
    sender?: SortOrder
    receiver?: SortOrder
    message?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionid?: SortOrder
    status?: SortOrder
    statusMessage?: SortOrder
    isBankTransaction?: SortOrder
    senderAmount?: SortOrder
    receiverAmount?: SortOrder
    senderAccountAmount?: SortOrder
    receiverAccountAmount?: SortOrder
    senderAccountId?: SortOrder
    receiverAccountId?: SortOrder
    sender?: SortOrder
    receiver?: SortOrder
    message?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    senderAmount?: SortOrder
    receiverAmount?: SortOrder
    senderAccountAmount?: SortOrder
    receiverAccountAmount?: SortOrder
    senderAccountId?: SortOrder
    receiverAccountId?: SortOrder
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumIBANStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IBANStatus | EnumIBANStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IBANStatus[] | ListEnumIBANStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IBANStatus[] | ListEnumIBANStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIBANStatusFilter<$PrismaModel> | $Enums.IBANStatus
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    IBAN?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    accountId?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    IBAN?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    accountId?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    IBAN?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    updateDate?: SortOrder
    accountId?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
  }

  export type EnumIBANStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IBANStatus | EnumIBANStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IBANStatus[] | ListEnumIBANStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IBANStatus[] | ListEnumIBANStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIBANStatusWithAggregatesFilter<$PrismaModel> | $Enums.IBANStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIBANStatusFilter<$PrismaModel>
    _max?: NestedEnumIBANStatusFilter<$PrismaModel>
  }

  export type ServiceActionCreateNestedManyWithoutServicesInput = {
    create?: XOR<ServiceActionCreateWithoutServicesInput, ServiceActionUncheckedCreateWithoutServicesInput> | ServiceActionCreateWithoutServicesInput[] | ServiceActionUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ServiceActionCreateOrConnectWithoutServicesInput | ServiceActionCreateOrConnectWithoutServicesInput[]
    connect?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
  }

  export type ServiceStatementCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceStatementCreateWithoutServiceInput, ServiceStatementUncheckedCreateWithoutServiceInput> | ServiceStatementCreateWithoutServiceInput[] | ServiceStatementUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutServiceInput | ServiceStatementCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceStatementCreateManyServiceInputEnvelope
    connect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
  }

  export type ServiceActionUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<ServiceActionCreateWithoutServicesInput, ServiceActionUncheckedCreateWithoutServicesInput> | ServiceActionCreateWithoutServicesInput[] | ServiceActionUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ServiceActionCreateOrConnectWithoutServicesInput | ServiceActionCreateOrConnectWithoutServicesInput[]
    connect?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
  }

  export type ServiceStatementUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceStatementCreateWithoutServiceInput, ServiceStatementUncheckedCreateWithoutServiceInput> | ServiceStatementCreateWithoutServiceInput[] | ServiceStatementUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutServiceInput | ServiceStatementCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceStatementCreateManyServiceInputEnvelope
    connect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ServiceActionUpdateManyWithoutServicesNestedInput = {
    create?: XOR<ServiceActionCreateWithoutServicesInput, ServiceActionUncheckedCreateWithoutServicesInput> | ServiceActionCreateWithoutServicesInput[] | ServiceActionUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ServiceActionCreateOrConnectWithoutServicesInput | ServiceActionCreateOrConnectWithoutServicesInput[]
    upsert?: ServiceActionUpsertWithWhereUniqueWithoutServicesInput | ServiceActionUpsertWithWhereUniqueWithoutServicesInput[]
    set?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
    disconnect?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
    delete?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
    connect?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
    update?: ServiceActionUpdateWithWhereUniqueWithoutServicesInput | ServiceActionUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: ServiceActionUpdateManyWithWhereWithoutServicesInput | ServiceActionUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: ServiceActionScalarWhereInput | ServiceActionScalarWhereInput[]
  }

  export type ServiceStatementUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceStatementCreateWithoutServiceInput, ServiceStatementUncheckedCreateWithoutServiceInput> | ServiceStatementCreateWithoutServiceInput[] | ServiceStatementUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutServiceInput | ServiceStatementCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceStatementUpsertWithWhereUniqueWithoutServiceInput | ServiceStatementUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceStatementCreateManyServiceInputEnvelope
    set?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    disconnect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    delete?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    connect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    update?: ServiceStatementUpdateWithWhereUniqueWithoutServiceInput | ServiceStatementUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceStatementUpdateManyWithWhereWithoutServiceInput | ServiceStatementUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceStatementScalarWhereInput | ServiceStatementScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceActionUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<ServiceActionCreateWithoutServicesInput, ServiceActionUncheckedCreateWithoutServicesInput> | ServiceActionCreateWithoutServicesInput[] | ServiceActionUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ServiceActionCreateOrConnectWithoutServicesInput | ServiceActionCreateOrConnectWithoutServicesInput[]
    upsert?: ServiceActionUpsertWithWhereUniqueWithoutServicesInput | ServiceActionUpsertWithWhereUniqueWithoutServicesInput[]
    set?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
    disconnect?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
    delete?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
    connect?: ServiceActionWhereUniqueInput | ServiceActionWhereUniqueInput[]
    update?: ServiceActionUpdateWithWhereUniqueWithoutServicesInput | ServiceActionUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: ServiceActionUpdateManyWithWhereWithoutServicesInput | ServiceActionUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: ServiceActionScalarWhereInput | ServiceActionScalarWhereInput[]
  }

  export type ServiceStatementUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceStatementCreateWithoutServiceInput, ServiceStatementUncheckedCreateWithoutServiceInput> | ServiceStatementCreateWithoutServiceInput[] | ServiceStatementUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutServiceInput | ServiceStatementCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceStatementUpsertWithWhereUniqueWithoutServiceInput | ServiceStatementUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceStatementCreateManyServiceInputEnvelope
    set?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    disconnect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    delete?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    connect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    update?: ServiceStatementUpdateWithWhereUniqueWithoutServiceInput | ServiceStatementUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceStatementUpdateManyWithWhereWithoutServiceInput | ServiceStatementUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceStatementScalarWhereInput | ServiceStatementScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutServiceactionsInput = {
    create?: XOR<ServiceCreateWithoutServiceactionsInput, ServiceUncheckedCreateWithoutServiceactionsInput> | ServiceCreateWithoutServiceactionsInput[] | ServiceUncheckedCreateWithoutServiceactionsInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceactionsInput | ServiceCreateOrConnectWithoutServiceactionsInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceStatementActionCreateNestedManyWithoutServiceactionInput = {
    create?: XOR<ServiceStatementActionCreateWithoutServiceactionInput, ServiceStatementActionUncheckedCreateWithoutServiceactionInput> | ServiceStatementActionCreateWithoutServiceactionInput[] | ServiceStatementActionUncheckedCreateWithoutServiceactionInput[]
    connectOrCreate?: ServiceStatementActionCreateOrConnectWithoutServiceactionInput | ServiceStatementActionCreateOrConnectWithoutServiceactionInput[]
    createMany?: ServiceStatementActionCreateManyServiceactionInputEnvelope
    connect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutServiceactionsInput = {
    create?: XOR<ServiceCreateWithoutServiceactionsInput, ServiceUncheckedCreateWithoutServiceactionsInput> | ServiceCreateWithoutServiceactionsInput[] | ServiceUncheckedCreateWithoutServiceactionsInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceactionsInput | ServiceCreateOrConnectWithoutServiceactionsInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceStatementActionUncheckedCreateNestedManyWithoutServiceactionInput = {
    create?: XOR<ServiceStatementActionCreateWithoutServiceactionInput, ServiceStatementActionUncheckedCreateWithoutServiceactionInput> | ServiceStatementActionCreateWithoutServiceactionInput[] | ServiceStatementActionUncheckedCreateWithoutServiceactionInput[]
    connectOrCreate?: ServiceStatementActionCreateOrConnectWithoutServiceactionInput | ServiceStatementActionCreateOrConnectWithoutServiceactionInput[]
    createMany?: ServiceStatementActionCreateManyServiceactionInputEnvelope
    connect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutServiceactionsNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceactionsInput, ServiceUncheckedCreateWithoutServiceactionsInput> | ServiceCreateWithoutServiceactionsInput[] | ServiceUncheckedCreateWithoutServiceactionsInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceactionsInput | ServiceCreateOrConnectWithoutServiceactionsInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceactionsInput | ServiceUpsertWithWhereUniqueWithoutServiceactionsInput[]
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceactionsInput | ServiceUpdateWithWhereUniqueWithoutServiceactionsInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceactionsInput | ServiceUpdateManyWithWhereWithoutServiceactionsInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceStatementActionUpdateManyWithoutServiceactionNestedInput = {
    create?: XOR<ServiceStatementActionCreateWithoutServiceactionInput, ServiceStatementActionUncheckedCreateWithoutServiceactionInput> | ServiceStatementActionCreateWithoutServiceactionInput[] | ServiceStatementActionUncheckedCreateWithoutServiceactionInput[]
    connectOrCreate?: ServiceStatementActionCreateOrConnectWithoutServiceactionInput | ServiceStatementActionCreateOrConnectWithoutServiceactionInput[]
    upsert?: ServiceStatementActionUpsertWithWhereUniqueWithoutServiceactionInput | ServiceStatementActionUpsertWithWhereUniqueWithoutServiceactionInput[]
    createMany?: ServiceStatementActionCreateManyServiceactionInputEnvelope
    set?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    disconnect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    delete?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    connect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    update?: ServiceStatementActionUpdateWithWhereUniqueWithoutServiceactionInput | ServiceStatementActionUpdateWithWhereUniqueWithoutServiceactionInput[]
    updateMany?: ServiceStatementActionUpdateManyWithWhereWithoutServiceactionInput | ServiceStatementActionUpdateManyWithWhereWithoutServiceactionInput[]
    deleteMany?: ServiceStatementActionScalarWhereInput | ServiceStatementActionScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutServiceactionsNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceactionsInput, ServiceUncheckedCreateWithoutServiceactionsInput> | ServiceCreateWithoutServiceactionsInput[] | ServiceUncheckedCreateWithoutServiceactionsInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceactionsInput | ServiceCreateOrConnectWithoutServiceactionsInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceactionsInput | ServiceUpsertWithWhereUniqueWithoutServiceactionsInput[]
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceactionsInput | ServiceUpdateWithWhereUniqueWithoutServiceactionsInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceactionsInput | ServiceUpdateManyWithWhereWithoutServiceactionsInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceStatementActionUncheckedUpdateManyWithoutServiceactionNestedInput = {
    create?: XOR<ServiceStatementActionCreateWithoutServiceactionInput, ServiceStatementActionUncheckedCreateWithoutServiceactionInput> | ServiceStatementActionCreateWithoutServiceactionInput[] | ServiceStatementActionUncheckedCreateWithoutServiceactionInput[]
    connectOrCreate?: ServiceStatementActionCreateOrConnectWithoutServiceactionInput | ServiceStatementActionCreateOrConnectWithoutServiceactionInput[]
    upsert?: ServiceStatementActionUpsertWithWhereUniqueWithoutServiceactionInput | ServiceStatementActionUpsertWithWhereUniqueWithoutServiceactionInput[]
    createMany?: ServiceStatementActionCreateManyServiceactionInputEnvelope
    set?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    disconnect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    delete?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    connect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    update?: ServiceStatementActionUpdateWithWhereUniqueWithoutServiceactionInput | ServiceStatementActionUpdateWithWhereUniqueWithoutServiceactionInput[]
    updateMany?: ServiceStatementActionUpdateManyWithWhereWithoutServiceactionInput | ServiceStatementActionUpdateManyWithWhereWithoutServiceactionInput[]
    deleteMany?: ServiceStatementActionScalarWhereInput | ServiceStatementActionScalarWhereInput[]
  }

  export type ServiceStatementCreateNestedOneWithoutServicestatementactionsInput = {
    create?: XOR<ServiceStatementCreateWithoutServicestatementactionsInput, ServiceStatementUncheckedCreateWithoutServicestatementactionsInput>
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutServicestatementactionsInput
    connect?: ServiceStatementWhereUniqueInput
  }

  export type ServiceActionCreateNestedOneWithoutServiceStatementActionsInput = {
    create?: XOR<ServiceActionCreateWithoutServiceStatementActionsInput, ServiceActionUncheckedCreateWithoutServiceStatementActionsInput>
    connectOrCreate?: ServiceActionCreateOrConnectWithoutServiceStatementActionsInput
    connect?: ServiceActionWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ServiceStatementUpdateOneRequiredWithoutServicestatementactionsNestedInput = {
    create?: XOR<ServiceStatementCreateWithoutServicestatementactionsInput, ServiceStatementUncheckedCreateWithoutServicestatementactionsInput>
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutServicestatementactionsInput
    upsert?: ServiceStatementUpsertWithoutServicestatementactionsInput
    connect?: ServiceStatementWhereUniqueInput
    update?: XOR<XOR<ServiceStatementUpdateToOneWithWhereWithoutServicestatementactionsInput, ServiceStatementUpdateWithoutServicestatementactionsInput>, ServiceStatementUncheckedUpdateWithoutServicestatementactionsInput>
  }

  export type ServiceActionUpdateOneRequiredWithoutServiceStatementActionsNestedInput = {
    create?: XOR<ServiceActionCreateWithoutServiceStatementActionsInput, ServiceActionUncheckedCreateWithoutServiceStatementActionsInput>
    connectOrCreate?: ServiceActionCreateOrConnectWithoutServiceStatementActionsInput
    upsert?: ServiceActionUpsertWithoutServiceStatementActionsInput
    connect?: ServiceActionWhereUniqueInput
    update?: XOR<XOR<ServiceActionUpdateToOneWithWhereWithoutServiceStatementActionsInput, ServiceActionUpdateWithoutServiceStatementActionsInput>, ServiceActionUncheckedUpdateWithoutServiceStatementActionsInput>
  }

  export type ServiceCreateNestedOneWithoutServicestatementsInput = {
    create?: XOR<ServiceCreateWithoutServicestatementsInput, ServiceUncheckedCreateWithoutServicestatementsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServicestatementsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceStatementActionCreateNestedManyWithoutServicestatementInput = {
    create?: XOR<ServiceStatementActionCreateWithoutServicestatementInput, ServiceStatementActionUncheckedCreateWithoutServicestatementInput> | ServiceStatementActionCreateWithoutServicestatementInput[] | ServiceStatementActionUncheckedCreateWithoutServicestatementInput[]
    connectOrCreate?: ServiceStatementActionCreateOrConnectWithoutServicestatementInput | ServiceStatementActionCreateOrConnectWithoutServicestatementInput[]
    createMany?: ServiceStatementActionCreateManyServicestatementInputEnvelope
    connect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
  }

  export type PolicyCreateNestedManyWithoutServicestatementsInput = {
    create?: XOR<PolicyCreateWithoutServicestatementsInput, PolicyUncheckedCreateWithoutServicestatementsInput> | PolicyCreateWithoutServicestatementsInput[] | PolicyUncheckedCreateWithoutServicestatementsInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutServicestatementsInput | PolicyCreateOrConnectWithoutServicestatementsInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type ServiceStatementActionUncheckedCreateNestedManyWithoutServicestatementInput = {
    create?: XOR<ServiceStatementActionCreateWithoutServicestatementInput, ServiceStatementActionUncheckedCreateWithoutServicestatementInput> | ServiceStatementActionCreateWithoutServicestatementInput[] | ServiceStatementActionUncheckedCreateWithoutServicestatementInput[]
    connectOrCreate?: ServiceStatementActionCreateOrConnectWithoutServicestatementInput | ServiceStatementActionCreateOrConnectWithoutServicestatementInput[]
    createMany?: ServiceStatementActionCreateManyServicestatementInputEnvelope
    connect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
  }

  export type PolicyUncheckedCreateNestedManyWithoutServicestatementsInput = {
    create?: XOR<PolicyCreateWithoutServicestatementsInput, PolicyUncheckedCreateWithoutServicestatementsInput> | PolicyCreateWithoutServicestatementsInput[] | PolicyUncheckedCreateWithoutServicestatementsInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutServicestatementsInput | PolicyCreateOrConnectWithoutServicestatementsInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumPermissionFieldUpdateOperationsInput = {
    set?: $Enums.Permission | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ServiceUpdateOneRequiredWithoutServicestatementsNestedInput = {
    create?: XOR<ServiceCreateWithoutServicestatementsInput, ServiceUncheckedCreateWithoutServicestatementsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServicestatementsInput
    upsert?: ServiceUpsertWithoutServicestatementsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServicestatementsInput, ServiceUpdateWithoutServicestatementsInput>, ServiceUncheckedUpdateWithoutServicestatementsInput>
  }

  export type ServiceStatementActionUpdateManyWithoutServicestatementNestedInput = {
    create?: XOR<ServiceStatementActionCreateWithoutServicestatementInput, ServiceStatementActionUncheckedCreateWithoutServicestatementInput> | ServiceStatementActionCreateWithoutServicestatementInput[] | ServiceStatementActionUncheckedCreateWithoutServicestatementInput[]
    connectOrCreate?: ServiceStatementActionCreateOrConnectWithoutServicestatementInput | ServiceStatementActionCreateOrConnectWithoutServicestatementInput[]
    upsert?: ServiceStatementActionUpsertWithWhereUniqueWithoutServicestatementInput | ServiceStatementActionUpsertWithWhereUniqueWithoutServicestatementInput[]
    createMany?: ServiceStatementActionCreateManyServicestatementInputEnvelope
    set?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    disconnect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    delete?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    connect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    update?: ServiceStatementActionUpdateWithWhereUniqueWithoutServicestatementInput | ServiceStatementActionUpdateWithWhereUniqueWithoutServicestatementInput[]
    updateMany?: ServiceStatementActionUpdateManyWithWhereWithoutServicestatementInput | ServiceStatementActionUpdateManyWithWhereWithoutServicestatementInput[]
    deleteMany?: ServiceStatementActionScalarWhereInput | ServiceStatementActionScalarWhereInput[]
  }

  export type PolicyUpdateManyWithoutServicestatementsNestedInput = {
    create?: XOR<PolicyCreateWithoutServicestatementsInput, PolicyUncheckedCreateWithoutServicestatementsInput> | PolicyCreateWithoutServicestatementsInput[] | PolicyUncheckedCreateWithoutServicestatementsInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutServicestatementsInput | PolicyCreateOrConnectWithoutServicestatementsInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutServicestatementsInput | PolicyUpsertWithWhereUniqueWithoutServicestatementsInput[]
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutServicestatementsInput | PolicyUpdateWithWhereUniqueWithoutServicestatementsInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutServicestatementsInput | PolicyUpdateManyWithWhereWithoutServicestatementsInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type ServiceStatementActionUncheckedUpdateManyWithoutServicestatementNestedInput = {
    create?: XOR<ServiceStatementActionCreateWithoutServicestatementInput, ServiceStatementActionUncheckedCreateWithoutServicestatementInput> | ServiceStatementActionCreateWithoutServicestatementInput[] | ServiceStatementActionUncheckedCreateWithoutServicestatementInput[]
    connectOrCreate?: ServiceStatementActionCreateOrConnectWithoutServicestatementInput | ServiceStatementActionCreateOrConnectWithoutServicestatementInput[]
    upsert?: ServiceStatementActionUpsertWithWhereUniqueWithoutServicestatementInput | ServiceStatementActionUpsertWithWhereUniqueWithoutServicestatementInput[]
    createMany?: ServiceStatementActionCreateManyServicestatementInputEnvelope
    set?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    disconnect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    delete?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    connect?: ServiceStatementActionWhereUniqueInput | ServiceStatementActionWhereUniqueInput[]
    update?: ServiceStatementActionUpdateWithWhereUniqueWithoutServicestatementInput | ServiceStatementActionUpdateWithWhereUniqueWithoutServicestatementInput[]
    updateMany?: ServiceStatementActionUpdateManyWithWhereWithoutServicestatementInput | ServiceStatementActionUpdateManyWithWhereWithoutServicestatementInput[]
    deleteMany?: ServiceStatementActionScalarWhereInput | ServiceStatementActionScalarWhereInput[]
  }

  export type PolicyUncheckedUpdateManyWithoutServicestatementsNestedInput = {
    create?: XOR<PolicyCreateWithoutServicestatementsInput, PolicyUncheckedCreateWithoutServicestatementsInput> | PolicyCreateWithoutServicestatementsInput[] | PolicyUncheckedCreateWithoutServicestatementsInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutServicestatementsInput | PolicyCreateOrConnectWithoutServicestatementsInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutServicestatementsInput | PolicyUpsertWithWhereUniqueWithoutServicestatementsInput[]
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutServicestatementsInput | PolicyUpdateWithWhereUniqueWithoutServicestatementsInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutServicestatementsInput | PolicyUpdateManyWithWhereWithoutServicestatementsInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type NullableEnumTemplateRoleFieldUpdateOperationsInput = {
    set?: $Enums.TemplateRole | null
  }

  export type ServiceStatementCreateNestedManyWithoutPoliciesInput = {
    create?: XOR<ServiceStatementCreateWithoutPoliciesInput, ServiceStatementUncheckedCreateWithoutPoliciesInput> | ServiceStatementCreateWithoutPoliciesInput[] | ServiceStatementUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutPoliciesInput | ServiceStatementCreateOrConnectWithoutPoliciesInput[]
    connect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutPoliciesInput = {
    create?: XOR<RoleCreateWithoutPoliciesInput, RoleUncheckedCreateWithoutPoliciesInput> | RoleCreateWithoutPoliciesInput[] | RoleUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPoliciesInput | RoleCreateOrConnectWithoutPoliciesInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutPoliciesInput = {
    create?: XOR<UserCreateWithoutPoliciesInput, UserUncheckedCreateWithoutPoliciesInput> | UserCreateWithoutPoliciesInput[] | UserUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPoliciesInput | UserCreateOrConnectWithoutPoliciesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutPoliciesInput = {
    create?: XOR<GroupCreateWithoutPoliciesInput, GroupUncheckedCreateWithoutPoliciesInput> | GroupCreateWithoutPoliciesInput[] | GroupUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutPoliciesInput | GroupCreateOrConnectWithoutPoliciesInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ServiceStatementUncheckedCreateNestedManyWithoutPoliciesInput = {
    create?: XOR<ServiceStatementCreateWithoutPoliciesInput, ServiceStatementUncheckedCreateWithoutPoliciesInput> | ServiceStatementCreateWithoutPoliciesInput[] | ServiceStatementUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutPoliciesInput | ServiceStatementCreateOrConnectWithoutPoliciesInput[]
    connect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutPoliciesInput = {
    create?: XOR<RoleCreateWithoutPoliciesInput, RoleUncheckedCreateWithoutPoliciesInput> | RoleCreateWithoutPoliciesInput[] | RoleUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPoliciesInput | RoleCreateOrConnectWithoutPoliciesInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutPoliciesInput = {
    create?: XOR<UserCreateWithoutPoliciesInput, UserUncheckedCreateWithoutPoliciesInput> | UserCreateWithoutPoliciesInput[] | UserUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPoliciesInput | UserCreateOrConnectWithoutPoliciesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutPoliciesInput = {
    create?: XOR<GroupCreateWithoutPoliciesInput, GroupUncheckedCreateWithoutPoliciesInput> | GroupCreateWithoutPoliciesInput[] | GroupUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutPoliciesInput | GroupCreateOrConnectWithoutPoliciesInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ServiceStatementUpdateManyWithoutPoliciesNestedInput = {
    create?: XOR<ServiceStatementCreateWithoutPoliciesInput, ServiceStatementUncheckedCreateWithoutPoliciesInput> | ServiceStatementCreateWithoutPoliciesInput[] | ServiceStatementUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutPoliciesInput | ServiceStatementCreateOrConnectWithoutPoliciesInput[]
    upsert?: ServiceStatementUpsertWithWhereUniqueWithoutPoliciesInput | ServiceStatementUpsertWithWhereUniqueWithoutPoliciesInput[]
    set?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    disconnect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    delete?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    connect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    update?: ServiceStatementUpdateWithWhereUniqueWithoutPoliciesInput | ServiceStatementUpdateWithWhereUniqueWithoutPoliciesInput[]
    updateMany?: ServiceStatementUpdateManyWithWhereWithoutPoliciesInput | ServiceStatementUpdateManyWithWhereWithoutPoliciesInput[]
    deleteMany?: ServiceStatementScalarWhereInput | ServiceStatementScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutPoliciesNestedInput = {
    create?: XOR<RoleCreateWithoutPoliciesInput, RoleUncheckedCreateWithoutPoliciesInput> | RoleCreateWithoutPoliciesInput[] | RoleUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPoliciesInput | RoleCreateOrConnectWithoutPoliciesInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutPoliciesInput | RoleUpsertWithWhereUniqueWithoutPoliciesInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutPoliciesInput | RoleUpdateWithWhereUniqueWithoutPoliciesInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutPoliciesInput | RoleUpdateManyWithWhereWithoutPoliciesInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type UserUpdateManyWithoutPoliciesNestedInput = {
    create?: XOR<UserCreateWithoutPoliciesInput, UserUncheckedCreateWithoutPoliciesInput> | UserCreateWithoutPoliciesInput[] | UserUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPoliciesInput | UserCreateOrConnectWithoutPoliciesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPoliciesInput | UserUpsertWithWhereUniqueWithoutPoliciesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPoliciesInput | UserUpdateWithWhereUniqueWithoutPoliciesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPoliciesInput | UserUpdateManyWithWhereWithoutPoliciesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutPoliciesNestedInput = {
    create?: XOR<GroupCreateWithoutPoliciesInput, GroupUncheckedCreateWithoutPoliciesInput> | GroupCreateWithoutPoliciesInput[] | GroupUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutPoliciesInput | GroupCreateOrConnectWithoutPoliciesInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutPoliciesInput | GroupUpsertWithWhereUniqueWithoutPoliciesInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutPoliciesInput | GroupUpdateWithWhereUniqueWithoutPoliciesInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutPoliciesInput | GroupUpdateManyWithWhereWithoutPoliciesInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ServiceStatementUncheckedUpdateManyWithoutPoliciesNestedInput = {
    create?: XOR<ServiceStatementCreateWithoutPoliciesInput, ServiceStatementUncheckedCreateWithoutPoliciesInput> | ServiceStatementCreateWithoutPoliciesInput[] | ServiceStatementUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: ServiceStatementCreateOrConnectWithoutPoliciesInput | ServiceStatementCreateOrConnectWithoutPoliciesInput[]
    upsert?: ServiceStatementUpsertWithWhereUniqueWithoutPoliciesInput | ServiceStatementUpsertWithWhereUniqueWithoutPoliciesInput[]
    set?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    disconnect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    delete?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    connect?: ServiceStatementWhereUniqueInput | ServiceStatementWhereUniqueInput[]
    update?: ServiceStatementUpdateWithWhereUniqueWithoutPoliciesInput | ServiceStatementUpdateWithWhereUniqueWithoutPoliciesInput[]
    updateMany?: ServiceStatementUpdateManyWithWhereWithoutPoliciesInput | ServiceStatementUpdateManyWithWhereWithoutPoliciesInput[]
    deleteMany?: ServiceStatementScalarWhereInput | ServiceStatementScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutPoliciesNestedInput = {
    create?: XOR<RoleCreateWithoutPoliciesInput, RoleUncheckedCreateWithoutPoliciesInput> | RoleCreateWithoutPoliciesInput[] | RoleUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPoliciesInput | RoleCreateOrConnectWithoutPoliciesInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutPoliciesInput | RoleUpsertWithWhereUniqueWithoutPoliciesInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutPoliciesInput | RoleUpdateWithWhereUniqueWithoutPoliciesInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutPoliciesInput | RoleUpdateManyWithWhereWithoutPoliciesInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutPoliciesNestedInput = {
    create?: XOR<UserCreateWithoutPoliciesInput, UserUncheckedCreateWithoutPoliciesInput> | UserCreateWithoutPoliciesInput[] | UserUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPoliciesInput | UserCreateOrConnectWithoutPoliciesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPoliciesInput | UserUpsertWithWhereUniqueWithoutPoliciesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPoliciesInput | UserUpdateWithWhereUniqueWithoutPoliciesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPoliciesInput | UserUpdateManyWithWhereWithoutPoliciesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutPoliciesNestedInput = {
    create?: XOR<GroupCreateWithoutPoliciesInput, GroupUncheckedCreateWithoutPoliciesInput> | GroupCreateWithoutPoliciesInput[] | GroupUncheckedCreateWithoutPoliciesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutPoliciesInput | GroupCreateOrConnectWithoutPoliciesInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutPoliciesInput | GroupUpsertWithWhereUniqueWithoutPoliciesInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutPoliciesInput | GroupUpdateWithWhereUniqueWithoutPoliciesInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutPoliciesInput | GroupUpdateManyWithWhereWithoutPoliciesInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type PolicyCreateNestedManyWithoutRolesInput = {
    create?: XOR<PolicyCreateWithoutRolesInput, PolicyUncheckedCreateWithoutRolesInput> | PolicyCreateWithoutRolesInput[] | PolicyUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutRolesInput | PolicyCreateOrConnectWithoutRolesInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutRolesInput = {
    create?: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput> | GroupCreateWithoutRolesInput[] | GroupUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutRolesInput | GroupCreateOrConnectWithoutRolesInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type PolicyUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<PolicyCreateWithoutRolesInput, PolicyUncheckedCreateWithoutRolesInput> | PolicyCreateWithoutRolesInput[] | PolicyUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutRolesInput | PolicyCreateOrConnectWithoutRolesInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput> | GroupCreateWithoutRolesInput[] | GroupUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutRolesInput | GroupCreateOrConnectWithoutRolesInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type PolicyUpdateManyWithoutRolesNestedInput = {
    create?: XOR<PolicyCreateWithoutRolesInput, PolicyUncheckedCreateWithoutRolesInput> | PolicyCreateWithoutRolesInput[] | PolicyUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutRolesInput | PolicyCreateOrConnectWithoutRolesInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutRolesInput | PolicyUpsertWithWhereUniqueWithoutRolesInput[]
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutRolesInput | PolicyUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutRolesInput | PolicyUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRolesInput | UserUpsertWithWhereUniqueWithoutRolesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRolesInput | UserUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRolesInput | UserUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutRolesNestedInput = {
    create?: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput> | GroupCreateWithoutRolesInput[] | GroupUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutRolesInput | GroupCreateOrConnectWithoutRolesInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutRolesInput | GroupUpsertWithWhereUniqueWithoutRolesInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutRolesInput | GroupUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutRolesInput | GroupUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type PolicyUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<PolicyCreateWithoutRolesInput, PolicyUncheckedCreateWithoutRolesInput> | PolicyCreateWithoutRolesInput[] | PolicyUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutRolesInput | PolicyCreateOrConnectWithoutRolesInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutRolesInput | PolicyUpsertWithWhereUniqueWithoutRolesInput[]
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutRolesInput | PolicyUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutRolesInput | PolicyUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRolesInput | UserUpsertWithWhereUniqueWithoutRolesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRolesInput | UserUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRolesInput | UserUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput> | GroupCreateWithoutRolesInput[] | GroupUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutRolesInput | GroupCreateOrConnectWithoutRolesInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutRolesInput | GroupUpsertWithWhereUniqueWithoutRolesInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutRolesInput | GroupUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutRolesInput | GroupUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type AddressCreateNestedManyWithoutCountryInput = {
    create?: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput> | AddressCreateWithoutCountryInput[] | AddressUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCountryInput | AddressCreateOrConnectWithoutCountryInput[]
    createMany?: AddressCreateManyCountryInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput> | AddressCreateWithoutCountryInput[] | AddressUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCountryInput | AddressCreateOrConnectWithoutCountryInput[]
    createMany?: AddressCreateManyCountryInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput> | AddressCreateWithoutCountryInput[] | AddressUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCountryInput | AddressCreateOrConnectWithoutCountryInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCountryInput | AddressUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AddressCreateManyCountryInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCountryInput | AddressUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCountryInput | AddressUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput> | AddressCreateWithoutCountryInput[] | AddressUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCountryInput | AddressCreateOrConnectWithoutCountryInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCountryInput | AddressUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AddressCreateManyCountryInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCountryInput | AddressUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCountryInput | AddressUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CountryCreateWithoutAddressesInput, CountryUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAddressesInput
    connect?: CountryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    connect?: UserWhereUniqueInput
  }

  export type CountryUpdateOneWithoutAddressesNestedInput = {
    create?: XOR<CountryCreateWithoutAddressesInput, CountryUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAddressesInput
    upsert?: CountryUpsertWithoutAddressesInput
    disconnect?: CountryWhereInput | boolean
    delete?: CountryWhereInput | boolean
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutAddressesInput, CountryUpdateWithoutAddressesInput>, CountryUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateOneWithoutAddressNestedInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    upsert?: UserUpsertWithoutAddressInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressInput, UserUpdateWithoutAddressInput>, UserUncheckedUpdateWithoutAddressInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AddressCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    connect?: AddressWhereUniqueInput
  }

  export type PolicyCreateNestedManyWithoutUsersInput = {
    create?: XOR<PolicyCreateWithoutUsersInput, PolicyUncheckedCreateWithoutUsersInput> | PolicyCreateWithoutUsersInput[] | PolicyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutUsersInput | PolicyCreateOrConnectWithoutUsersInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput> | RoleCreateWithoutUsersInput[] | RoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput | RoleCreateOrConnectWithoutUsersInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutUsersInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput> | GroupCreateWithoutUsersInput[] | GroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput | GroupCreateOrConnectWithoutUsersInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    connect?: AccountWhereUniqueInput
  }

  export type UserSettingCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserSettingCreateWithoutUsersInput, UserSettingUncheckedCreateWithoutUsersInput> | UserSettingCreateWithoutUsersInput[] | UserSettingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUsersInput | UserSettingCreateOrConnectWithoutUsersInput[]
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
  }

  export type UserPATCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPATCreateWithoutUserInput, UserPATUncheckedCreateWithoutUserInput> | UserPATCreateWithoutUserInput[] | UserPATUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPATCreateOrConnectWithoutUserInput | UserPATCreateOrConnectWithoutUserInput[]
    createMany?: UserPATCreateManyUserInputEnvelope
    connect?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    connect?: AddressWhereUniqueInput
  }

  export type PolicyUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PolicyCreateWithoutUsersInput, PolicyUncheckedCreateWithoutUsersInput> | PolicyCreateWithoutUsersInput[] | PolicyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutUsersInput | PolicyCreateOrConnectWithoutUsersInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput> | RoleCreateWithoutUsersInput[] | RoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput | RoleCreateOrConnectWithoutUsersInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput> | GroupCreateWithoutUsersInput[] | GroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput | GroupCreateOrConnectWithoutUsersInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    connect?: AccountWhereUniqueInput
  }

  export type UserSettingUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserSettingCreateWithoutUsersInput, UserSettingUncheckedCreateWithoutUsersInput> | UserSettingCreateWithoutUsersInput[] | UserSettingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUsersInput | UserSettingCreateOrConnectWithoutUsersInput[]
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
  }

  export type UserPATUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPATCreateWithoutUserInput, UserPATUncheckedCreateWithoutUserInput> | UserPATCreateWithoutUserInput[] | UserPATUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPATCreateOrConnectWithoutUserInput | UserPATCreateOrConnectWithoutUserInput[]
    createMany?: UserPATCreateManyUserInputEnvelope
    connect?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type AddressUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    upsert?: AddressUpsertWithoutUserInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutUserInput, AddressUpdateWithoutUserInput>, AddressUncheckedUpdateWithoutUserInput>
  }

  export type PolicyUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PolicyCreateWithoutUsersInput, PolicyUncheckedCreateWithoutUsersInput> | PolicyCreateWithoutUsersInput[] | PolicyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutUsersInput | PolicyCreateOrConnectWithoutUsersInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutUsersInput | PolicyUpsertWithWhereUniqueWithoutUsersInput[]
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutUsersInput | PolicyUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutUsersInput | PolicyUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput> | RoleCreateWithoutUsersInput[] | RoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput | RoleCreateOrConnectWithoutUsersInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutUsersInput | RoleUpsertWithWhereUniqueWithoutUsersInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutUsersInput | RoleUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutUsersInput | RoleUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutUsersNestedInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput> | GroupCreateWithoutUsersInput[] | GroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput | GroupCreateOrConnectWithoutUsersInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutUsersInput | GroupUpsertWithWhereUniqueWithoutUsersInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutUsersInput | GroupUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutUsersInput | GroupUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type AccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    upsert?: AccountUpsertWithoutUserInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUserInput, AccountUpdateWithoutUserInput>, AccountUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserSettingCreateWithoutUsersInput, UserSettingUncheckedCreateWithoutUsersInput> | UserSettingCreateWithoutUsersInput[] | UserSettingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUsersInput | UserSettingCreateOrConnectWithoutUsersInput[]
    upsert?: UserSettingUpsertWithWhereUniqueWithoutUsersInput | UserSettingUpsertWithWhereUniqueWithoutUsersInput[]
    set?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    disconnect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    delete?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    update?: UserSettingUpdateWithWhereUniqueWithoutUsersInput | UserSettingUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserSettingUpdateManyWithWhereWithoutUsersInput | UserSettingUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
  }

  export type UserPATUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPATCreateWithoutUserInput, UserPATUncheckedCreateWithoutUserInput> | UserPATCreateWithoutUserInput[] | UserPATUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPATCreateOrConnectWithoutUserInput | UserPATCreateOrConnectWithoutUserInput[]
    upsert?: UserPATUpsertWithWhereUniqueWithoutUserInput | UserPATUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPATCreateManyUserInputEnvelope
    set?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
    disconnect?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
    delete?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
    connect?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
    update?: UserPATUpdateWithWhereUniqueWithoutUserInput | UserPATUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPATUpdateManyWithWhereWithoutUserInput | UserPATUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPATScalarWhereInput | UserPATScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    upsert?: AddressUpsertWithoutUserInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutUserInput, AddressUpdateWithoutUserInput>, AddressUncheckedUpdateWithoutUserInput>
  }

  export type PolicyUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PolicyCreateWithoutUsersInput, PolicyUncheckedCreateWithoutUsersInput> | PolicyCreateWithoutUsersInput[] | PolicyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutUsersInput | PolicyCreateOrConnectWithoutUsersInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutUsersInput | PolicyUpsertWithWhereUniqueWithoutUsersInput[]
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutUsersInput | PolicyUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutUsersInput | PolicyUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput> | RoleCreateWithoutUsersInput[] | RoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput | RoleCreateOrConnectWithoutUsersInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutUsersInput | RoleUpsertWithWhereUniqueWithoutUsersInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutUsersInput | RoleUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutUsersInput | RoleUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput> | GroupCreateWithoutUsersInput[] | GroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput | GroupCreateOrConnectWithoutUsersInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutUsersInput | GroupUpsertWithWhereUniqueWithoutUsersInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutUsersInput | GroupUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutUsersInput | GroupUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type AccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    upsert?: AccountUpsertWithoutUserInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUserInput, AccountUpdateWithoutUserInput>, AccountUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserSettingCreateWithoutUsersInput, UserSettingUncheckedCreateWithoutUsersInput> | UserSettingCreateWithoutUsersInput[] | UserSettingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUsersInput | UserSettingCreateOrConnectWithoutUsersInput[]
    upsert?: UserSettingUpsertWithWhereUniqueWithoutUsersInput | UserSettingUpsertWithWhereUniqueWithoutUsersInput[]
    set?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    disconnect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    delete?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    update?: UserSettingUpdateWithWhereUniqueWithoutUsersInput | UserSettingUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserSettingUpdateManyWithWhereWithoutUsersInput | UserSettingUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
  }

  export type UserPATUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPATCreateWithoutUserInput, UserPATUncheckedCreateWithoutUserInput> | UserPATCreateWithoutUserInput[] | UserPATUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPATCreateOrConnectWithoutUserInput | UserPATCreateOrConnectWithoutUserInput[]
    upsert?: UserPATUpsertWithWhereUniqueWithoutUserInput | UserPATUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPATCreateManyUserInputEnvelope
    set?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
    disconnect?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
    delete?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
    connect?: UserPATWhereUniqueInput | UserPATWhereUniqueInput[]
    update?: UserPATUpdateWithWhereUniqueWithoutUserInput | UserPATUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPATUpdateManyWithWhereWithoutUserInput | UserPATUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPATScalarWhereInput | UserPATScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPatsInput = {
    create?: XOR<UserCreateWithoutPatsInput, UserUncheckedCreateWithoutPatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumTokenStatusFieldUpdateOperationsInput = {
    set?: $Enums.TokenStatus
  }

  export type UserUpdateOneRequiredWithoutPatsNestedInput = {
    create?: XOR<UserCreateWithoutPatsInput, UserUncheckedCreateWithoutPatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatsInput
    upsert?: UserUpsertWithoutPatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatsInput, UserUpdateWithoutPatsInput>, UserUncheckedUpdateWithoutPatsInput>
  }

  export type UserCreateNestedManyWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput> | UserCreateWithoutSettingsInput[] | UserUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput | UserCreateOrConnectWithoutSettingsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput> | UserCreateWithoutSettingsInput[] | UserUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput | UserCreateOrConnectWithoutSettingsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput> | UserCreateWithoutSettingsInput[] | UserUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput | UserCreateOrConnectWithoutSettingsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSettingsInput | UserUpsertWithWhereUniqueWithoutSettingsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSettingsInput | UserUpdateWithWhereUniqueWithoutSettingsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSettingsInput | UserUpdateManyWithWhereWithoutSettingsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput> | UserCreateWithoutSettingsInput[] | UserUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput | UserCreateOrConnectWithoutSettingsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSettingsInput | UserUpsertWithWhereUniqueWithoutSettingsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSettingsInput | UserUpdateWithWhereUniqueWithoutSettingsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSettingsInput | UserUpdateManyWithWhereWithoutSettingsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PolicyCreateNestedManyWithoutGroupsInput = {
    create?: XOR<PolicyCreateWithoutGroupsInput, PolicyUncheckedCreateWithoutGroupsInput> | PolicyCreateWithoutGroupsInput[] | PolicyUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutGroupsInput | PolicyCreateOrConnectWithoutGroupsInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutGroupsInput = {
    create?: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput> | RoleCreateWithoutGroupsInput[] | RoleUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutGroupsInput | RoleCreateOrConnectWithoutGroupsInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PolicyUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<PolicyCreateWithoutGroupsInput, PolicyUncheckedCreateWithoutGroupsInput> | PolicyCreateWithoutGroupsInput[] | PolicyUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutGroupsInput | PolicyCreateOrConnectWithoutGroupsInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput> | RoleCreateWithoutGroupsInput[] | RoleUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutGroupsInput | RoleCreateOrConnectWithoutGroupsInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PolicyUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<PolicyCreateWithoutGroupsInput, PolicyUncheckedCreateWithoutGroupsInput> | PolicyCreateWithoutGroupsInput[] | PolicyUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutGroupsInput | PolicyCreateOrConnectWithoutGroupsInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutGroupsInput | PolicyUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutGroupsInput | PolicyUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutGroupsInput | PolicyUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput> | RoleCreateWithoutGroupsInput[] | RoleUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutGroupsInput | RoleCreateOrConnectWithoutGroupsInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutGroupsInput | RoleUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutGroupsInput | RoleUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutGroupsInput | RoleUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type UserUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PolicyUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<PolicyCreateWithoutGroupsInput, PolicyUncheckedCreateWithoutGroupsInput> | PolicyCreateWithoutGroupsInput[] | PolicyUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutGroupsInput | PolicyCreateOrConnectWithoutGroupsInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutGroupsInput | PolicyUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutGroupsInput | PolicyUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutGroupsInput | PolicyUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput> | RoleCreateWithoutGroupsInput[] | RoleUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutGroupsInput | RoleCreateOrConnectWithoutGroupsInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutGroupsInput | RoleUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutGroupsInput | RoleUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutGroupsInput | RoleUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutSenderAccountInput = {
    create?: XOR<TransactionCreateWithoutSenderAccountInput, TransactionUncheckedCreateWithoutSenderAccountInput> | TransactionCreateWithoutSenderAccountInput[] | TransactionUncheckedCreateWithoutSenderAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSenderAccountInput | TransactionCreateOrConnectWithoutSenderAccountInput[]
    createMany?: TransactionCreateManySenderAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutReceiverAccountInput = {
    create?: XOR<TransactionCreateWithoutReceiverAccountInput, TransactionUncheckedCreateWithoutReceiverAccountInput> | TransactionCreateWithoutReceiverAccountInput[] | TransactionUncheckedCreateWithoutReceiverAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutReceiverAccountInput | TransactionCreateOrConnectWithoutReceiverAccountInput[]
    createMany?: TransactionCreateManyReceiverAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BankAccountCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput> | BankAccountCreateWithoutAccountInput[] | BankAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutAccountInput | BankAccountCreateOrConnectWithoutAccountInput[]
    createMany?: BankAccountCreateManyAccountInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSenderAccountInput = {
    create?: XOR<TransactionCreateWithoutSenderAccountInput, TransactionUncheckedCreateWithoutSenderAccountInput> | TransactionCreateWithoutSenderAccountInput[] | TransactionUncheckedCreateWithoutSenderAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSenderAccountInput | TransactionCreateOrConnectWithoutSenderAccountInput[]
    createMany?: TransactionCreateManySenderAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutReceiverAccountInput = {
    create?: XOR<TransactionCreateWithoutReceiverAccountInput, TransactionUncheckedCreateWithoutReceiverAccountInput> | TransactionCreateWithoutReceiverAccountInput[] | TransactionUncheckedCreateWithoutReceiverAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutReceiverAccountInput | TransactionCreateOrConnectWithoutReceiverAccountInput[]
    createMany?: TransactionCreateManyReceiverAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BankAccountUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput> | BankAccountCreateWithoutAccountInput[] | BankAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutAccountInput | BankAccountCreateOrConnectWithoutAccountInput[]
    createMany?: BankAccountCreateManyAccountInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type UserUpdateOneWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountInput, UserUpdateWithoutAccountInput>, UserUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithoutSenderAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutSenderAccountInput, TransactionUncheckedCreateWithoutSenderAccountInput> | TransactionCreateWithoutSenderAccountInput[] | TransactionUncheckedCreateWithoutSenderAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSenderAccountInput | TransactionCreateOrConnectWithoutSenderAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSenderAccountInput | TransactionUpsertWithWhereUniqueWithoutSenderAccountInput[]
    createMany?: TransactionCreateManySenderAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSenderAccountInput | TransactionUpdateWithWhereUniqueWithoutSenderAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSenderAccountInput | TransactionUpdateManyWithWhereWithoutSenderAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutReceiverAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutReceiverAccountInput, TransactionUncheckedCreateWithoutReceiverAccountInput> | TransactionCreateWithoutReceiverAccountInput[] | TransactionUncheckedCreateWithoutReceiverAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutReceiverAccountInput | TransactionCreateOrConnectWithoutReceiverAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutReceiverAccountInput | TransactionUpsertWithWhereUniqueWithoutReceiverAccountInput[]
    createMany?: TransactionCreateManyReceiverAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutReceiverAccountInput | TransactionUpdateWithWhereUniqueWithoutReceiverAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutReceiverAccountInput | TransactionUpdateManyWithWhereWithoutReceiverAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BankAccountUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput> | BankAccountCreateWithoutAccountInput[] | BankAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutAccountInput | BankAccountCreateOrConnectWithoutAccountInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutAccountInput | BankAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankAccountCreateManyAccountInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutAccountInput | BankAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutAccountInput | BankAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSenderAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutSenderAccountInput, TransactionUncheckedCreateWithoutSenderAccountInput> | TransactionCreateWithoutSenderAccountInput[] | TransactionUncheckedCreateWithoutSenderAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSenderAccountInput | TransactionCreateOrConnectWithoutSenderAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSenderAccountInput | TransactionUpsertWithWhereUniqueWithoutSenderAccountInput[]
    createMany?: TransactionCreateManySenderAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSenderAccountInput | TransactionUpdateWithWhereUniqueWithoutSenderAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSenderAccountInput | TransactionUpdateManyWithWhereWithoutSenderAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutReceiverAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutReceiverAccountInput, TransactionUncheckedCreateWithoutReceiverAccountInput> | TransactionCreateWithoutReceiverAccountInput[] | TransactionUncheckedCreateWithoutReceiverAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutReceiverAccountInput | TransactionCreateOrConnectWithoutReceiverAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutReceiverAccountInput | TransactionUpsertWithWhereUniqueWithoutReceiverAccountInput[]
    createMany?: TransactionCreateManyReceiverAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutReceiverAccountInput | TransactionUpdateWithWhereUniqueWithoutReceiverAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutReceiverAccountInput | TransactionUpdateManyWithWhereWithoutReceiverAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BankAccountUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput> | BankAccountCreateWithoutAccountInput[] | BankAccountUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutAccountInput | BankAccountCreateOrConnectWithoutAccountInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutAccountInput | BankAccountUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankAccountCreateManyAccountInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutAccountInput | BankAccountUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutAccountInput | BankAccountUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type EnumAccountApplyStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountApplyStatus
  }

  export type TaskCreatefromStatusInput = {
    set: $Enums.TaskStatus[]
  }

  export type TaskCreateNestedOneWithoutSuccessorTaskInput = {
    create?: XOR<TaskCreateWithoutSuccessorTaskInput, TaskUncheckedCreateWithoutSuccessorTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSuccessorTaskInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutPredecessorTaskInput = {
    create?: XOR<TaskCreateWithoutPredecessorTaskInput, TaskUncheckedCreateWithoutPredecessorTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutPredecessorTaskInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUncheckedCreateNestedOneWithoutPredecessorTaskInput = {
    create?: XOR<TaskCreateWithoutPredecessorTaskInput, TaskUncheckedCreateWithoutPredecessorTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutPredecessorTaskInput
    connect?: TaskWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type TaskUpdatefromStatusInput = {
    set?: $Enums.TaskStatus[]
    push?: $Enums.TaskStatus | $Enums.TaskStatus[]
  }

  export type TaskUpdateOneWithoutSuccessorTaskNestedInput = {
    create?: XOR<TaskCreateWithoutSuccessorTaskInput, TaskUncheckedCreateWithoutSuccessorTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSuccessorTaskInput
    upsert?: TaskUpsertWithoutSuccessorTaskInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutSuccessorTaskInput, TaskUpdateWithoutSuccessorTaskInput>, TaskUncheckedUpdateWithoutSuccessorTaskInput>
  }

  export type TaskUpdateOneWithoutPredecessorTaskNestedInput = {
    create?: XOR<TaskCreateWithoutPredecessorTaskInput, TaskUncheckedCreateWithoutPredecessorTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutPredecessorTaskInput
    upsert?: TaskUpsertWithoutPredecessorTaskInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutPredecessorTaskInput, TaskUpdateWithoutPredecessorTaskInput>, TaskUncheckedUpdateWithoutPredecessorTaskInput>
  }

  export type TaskUncheckedUpdateOneWithoutPredecessorTaskNestedInput = {
    create?: XOR<TaskCreateWithoutPredecessorTaskInput, TaskUncheckedCreateWithoutPredecessorTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutPredecessorTaskInput
    upsert?: TaskUpsertWithoutPredecessorTaskInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutPredecessorTaskInput, TaskUpdateWithoutPredecessorTaskInput>, TaskUncheckedUpdateWithoutPredecessorTaskInput>
  }

  export type EnumOTPStatusFieldUpdateOperationsInput = {
    set?: $Enums.OTPStatus
  }

  export type NullableEnumHistoryTypeFieldUpdateOperationsInput = {
    set?: $Enums.HistoryType | null
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type EnumJobModelFieldUpdateOperationsInput = {
    set?: $Enums.JobModel
  }

  export type AccountCreateNestedOneWithoutSendertransactionsInput = {
    create?: XOR<AccountCreateWithoutSendertransactionsInput, AccountUncheckedCreateWithoutSendertransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSendertransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutReceivertransactionsInput = {
    create?: XOR<AccountCreateWithoutReceivertransactionsInput, AccountUncheckedCreateWithoutReceivertransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutReceivertransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneWithoutSendertransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutSendertransactionsInput, AccountUncheckedCreateWithoutSendertransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSendertransactionsInput
    upsert?: AccountUpsertWithoutSendertransactionsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSendertransactionsInput, AccountUpdateWithoutSendertransactionsInput>, AccountUncheckedUpdateWithoutSendertransactionsInput>
  }

  export type AccountUpdateOneWithoutReceivertransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutReceivertransactionsInput, AccountUncheckedCreateWithoutReceivertransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutReceivertransactionsInput
    upsert?: AccountUpsertWithoutReceivertransactionsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutReceivertransactionsInput, AccountUpdateWithoutReceivertransactionsInput>, AccountUncheckedUpdateWithoutReceivertransactionsInput>
  }

  export type AccountCreateNestedOneWithoutBankaccountsInput = {
    create?: XOR<AccountCreateWithoutBankaccountsInput, AccountUncheckedCreateWithoutBankaccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBankaccountsInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumIBANStatusFieldUpdateOperationsInput = {
    set?: $Enums.IBANStatus
  }

  export type AccountUpdateOneWithoutBankaccountsNestedInput = {
    create?: XOR<AccountCreateWithoutBankaccountsInput, AccountUncheckedCreateWithoutBankaccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBankaccountsInput
    upsert?: AccountUpsertWithoutBankaccountsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutBankaccountsInput, AccountUpdateWithoutBankaccountsInput>, AccountUncheckedUpdateWithoutBankaccountsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPermissionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPermissionNullableFilter<$PrismaModel> | $Enums.Permission | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumPermissionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPermissionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Permission | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPermissionNullableFilter<$PrismaModel>
    _max?: NestedEnumPermissionNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumTemplateRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateRole | EnumTemplateRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateRoleNullableFilter<$PrismaModel> | $Enums.TemplateRole | null
  }

  export type NestedEnumTemplateRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemplateRole | EnumTemplateRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemplateRole[] | ListEnumTemplateRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemplateRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.TemplateRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTemplateRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumTemplateRoleNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumTokenStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenStatus | EnumTokenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TokenStatus[] | ListEnumTokenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenStatus[] | ListEnumTokenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenStatusFilter<$PrismaModel> | $Enums.TokenStatus
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTokenStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenStatus | EnumTokenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TokenStatus[] | ListEnumTokenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenStatus[] | ListEnumTokenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenStatusWithAggregatesFilter<$PrismaModel> | $Enums.TokenStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenStatusFilter<$PrismaModel>
    _max?: NestedEnumTokenStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumAccountApplyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountApplyStatus | EnumAccountApplyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountApplyStatus[] | ListEnumAccountApplyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountApplyStatus[] | ListEnumAccountApplyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountApplyStatusFilter<$PrismaModel> | $Enums.AccountApplyStatus
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumAccountApplyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountApplyStatus | EnumAccountApplyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountApplyStatus[] | ListEnumAccountApplyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountApplyStatus[] | ListEnumAccountApplyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountApplyStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountApplyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountApplyStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountApplyStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumOTPStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPStatus | EnumOTPStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OTPStatus[] | ListEnumOTPStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPStatus[] | ListEnumOTPStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPStatusFilter<$PrismaModel> | $Enums.OTPStatus
  }

  export type NestedEnumOTPStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPStatus | EnumOTPStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OTPStatus[] | ListEnumOTPStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPStatus[] | ListEnumOTPStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPStatusWithAggregatesFilter<$PrismaModel> | $Enums.OTPStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPStatusFilter<$PrismaModel>
    _max?: NestedEnumOTPStatusFilter<$PrismaModel>
  }

  export type NestedEnumHistoryTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HistoryType | EnumHistoryTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.HistoryType[] | ListEnumHistoryTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HistoryType[] | ListEnumHistoryTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHistoryTypeNullableFilter<$PrismaModel> | $Enums.HistoryType | null
  }

  export type NestedEnumHistoryTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HistoryType | EnumHistoryTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.HistoryType[] | ListEnumHistoryTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HistoryType[] | ListEnumHistoryTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHistoryTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.HistoryType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHistoryTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumHistoryTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumJobModelFilter<$PrismaModel = never> = {
    equals?: $Enums.JobModel | EnumJobModelFieldRefInput<$PrismaModel>
    in?: $Enums.JobModel[] | ListEnumJobModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobModel[] | ListEnumJobModelFieldRefInput<$PrismaModel>
    not?: NestedEnumJobModelFilter<$PrismaModel> | $Enums.JobModel
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumJobModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobModel | EnumJobModelFieldRefInput<$PrismaModel>
    in?: $Enums.JobModel[] | ListEnumJobModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobModel[] | ListEnumJobModelFieldRefInput<$PrismaModel>
    not?: NestedEnumJobModelWithAggregatesFilter<$PrismaModel> | $Enums.JobModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobModelFilter<$PrismaModel>
    _max?: NestedEnumJobModelFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumIBANStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IBANStatus | EnumIBANStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IBANStatus[] | ListEnumIBANStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IBANStatus[] | ListEnumIBANStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIBANStatusFilter<$PrismaModel> | $Enums.IBANStatus
  }

  export type NestedEnumIBANStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IBANStatus | EnumIBANStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IBANStatus[] | ListEnumIBANStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IBANStatus[] | ListEnumIBANStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIBANStatusWithAggregatesFilter<$PrismaModel> | $Enums.IBANStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIBANStatusFilter<$PrismaModel>
    _max?: NestedEnumIBANStatusFilter<$PrismaModel>
  }

  export type ServiceActionCreateWithoutServicesInput = {
    serviceactionname: string
    serviceStatementActions?: ServiceStatementActionCreateNestedManyWithoutServiceactionInput
  }

  export type ServiceActionUncheckedCreateWithoutServicesInput = {
    id?: number
    serviceactionname: string
    serviceStatementActions?: ServiceStatementActionUncheckedCreateNestedManyWithoutServiceactionInput
  }

  export type ServiceActionCreateOrConnectWithoutServicesInput = {
    where: ServiceActionWhereUniqueInput
    create: XOR<ServiceActionCreateWithoutServicesInput, ServiceActionUncheckedCreateWithoutServicesInput>
  }

  export type ServiceStatementCreateWithoutServiceInput = {
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatementactions?: ServiceStatementActionCreateNestedManyWithoutServicestatementInput
    policies?: PolicyCreateNestedManyWithoutServicestatementsInput
  }

  export type ServiceStatementUncheckedCreateWithoutServiceInput = {
    id?: number
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatementactions?: ServiceStatementActionUncheckedCreateNestedManyWithoutServicestatementInput
    policies?: PolicyUncheckedCreateNestedManyWithoutServicestatementsInput
  }

  export type ServiceStatementCreateOrConnectWithoutServiceInput = {
    where: ServiceStatementWhereUniqueInput
    create: XOR<ServiceStatementCreateWithoutServiceInput, ServiceStatementUncheckedCreateWithoutServiceInput>
  }

  export type ServiceStatementCreateManyServiceInputEnvelope = {
    data: ServiceStatementCreateManyServiceInput | ServiceStatementCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceActionUpsertWithWhereUniqueWithoutServicesInput = {
    where: ServiceActionWhereUniqueInput
    update: XOR<ServiceActionUpdateWithoutServicesInput, ServiceActionUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceActionCreateWithoutServicesInput, ServiceActionUncheckedCreateWithoutServicesInput>
  }

  export type ServiceActionUpdateWithWhereUniqueWithoutServicesInput = {
    where: ServiceActionWhereUniqueInput
    data: XOR<ServiceActionUpdateWithoutServicesInput, ServiceActionUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceActionUpdateManyWithWhereWithoutServicesInput = {
    where: ServiceActionScalarWhereInput
    data: XOR<ServiceActionUpdateManyMutationInput, ServiceActionUncheckedUpdateManyWithoutServicesInput>
  }

  export type ServiceActionScalarWhereInput = {
    AND?: ServiceActionScalarWhereInput | ServiceActionScalarWhereInput[]
    OR?: ServiceActionScalarWhereInput[]
    NOT?: ServiceActionScalarWhereInput | ServiceActionScalarWhereInput[]
    id?: IntFilter<"ServiceAction"> | number
    serviceactionname?: StringFilter<"ServiceAction"> | string
  }

  export type ServiceStatementUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceStatementWhereUniqueInput
    update: XOR<ServiceStatementUpdateWithoutServiceInput, ServiceStatementUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceStatementCreateWithoutServiceInput, ServiceStatementUncheckedCreateWithoutServiceInput>
  }

  export type ServiceStatementUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceStatementWhereUniqueInput
    data: XOR<ServiceStatementUpdateWithoutServiceInput, ServiceStatementUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceStatementUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceStatementScalarWhereInput
    data: XOR<ServiceStatementUpdateManyMutationInput, ServiceStatementUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceStatementScalarWhereInput = {
    AND?: ServiceStatementScalarWhereInput | ServiceStatementScalarWhereInput[]
    OR?: ServiceStatementScalarWhereInput[]
    NOT?: ServiceStatementScalarWhereInput | ServiceStatementScalarWhereInput[]
    id?: IntFilter<"ServiceStatement"> | number
    ssname?: StringFilter<"ServiceStatement"> | string
    description?: StringNullableFilter<"ServiceStatement"> | string | null
    permission?: EnumPermissionNullableFilter<"ServiceStatement"> | $Enums.Permission | null
    managed?: BoolNullableFilter<"ServiceStatement"> | boolean | null
    system?: BoolNullableFilter<"ServiceStatement"> | boolean | null
    createDate?: DateTimeNullableFilter<"ServiceStatement"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"ServiceStatement"> | Date | string | null
    serviceid?: IntFilter<"ServiceStatement"> | number
  }

  export type ServiceCreateWithoutServiceactionsInput = {
    servicename: string
    servicestatements?: ServiceStatementCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceactionsInput = {
    id?: number
    servicename: string
    servicestatements?: ServiceStatementUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceactionsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceactionsInput, ServiceUncheckedCreateWithoutServiceactionsInput>
  }

  export type ServiceStatementActionCreateWithoutServiceactionInput = {
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatement: ServiceStatementCreateNestedOneWithoutServicestatementactionsInput
  }

  export type ServiceStatementActionUncheckedCreateWithoutServiceactionInput = {
    id?: number
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    statementid: number
  }

  export type ServiceStatementActionCreateOrConnectWithoutServiceactionInput = {
    where: ServiceStatementActionWhereUniqueInput
    create: XOR<ServiceStatementActionCreateWithoutServiceactionInput, ServiceStatementActionUncheckedCreateWithoutServiceactionInput>
  }

  export type ServiceStatementActionCreateManyServiceactionInputEnvelope = {
    data: ServiceStatementActionCreateManyServiceactionInput | ServiceStatementActionCreateManyServiceactionInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutServiceactionsInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutServiceactionsInput, ServiceUncheckedUpdateWithoutServiceactionsInput>
    create: XOR<ServiceCreateWithoutServiceactionsInput, ServiceUncheckedCreateWithoutServiceactionsInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutServiceactionsInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutServiceactionsInput, ServiceUncheckedUpdateWithoutServiceactionsInput>
  }

  export type ServiceUpdateManyWithWhereWithoutServiceactionsInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServiceactionsInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: IntFilter<"Service"> | number
    servicename?: StringFilter<"Service"> | string
  }

  export type ServiceStatementActionUpsertWithWhereUniqueWithoutServiceactionInput = {
    where: ServiceStatementActionWhereUniqueInput
    update: XOR<ServiceStatementActionUpdateWithoutServiceactionInput, ServiceStatementActionUncheckedUpdateWithoutServiceactionInput>
    create: XOR<ServiceStatementActionCreateWithoutServiceactionInput, ServiceStatementActionUncheckedCreateWithoutServiceactionInput>
  }

  export type ServiceStatementActionUpdateWithWhereUniqueWithoutServiceactionInput = {
    where: ServiceStatementActionWhereUniqueInput
    data: XOR<ServiceStatementActionUpdateWithoutServiceactionInput, ServiceStatementActionUncheckedUpdateWithoutServiceactionInput>
  }

  export type ServiceStatementActionUpdateManyWithWhereWithoutServiceactionInput = {
    where: ServiceStatementActionScalarWhereInput
    data: XOR<ServiceStatementActionUpdateManyMutationInput, ServiceStatementActionUncheckedUpdateManyWithoutServiceactionInput>
  }

  export type ServiceStatementActionScalarWhereInput = {
    AND?: ServiceStatementActionScalarWhereInput | ServiceStatementActionScalarWhereInput[]
    OR?: ServiceStatementActionScalarWhereInput[]
    NOT?: ServiceStatementActionScalarWhereInput | ServiceStatementActionScalarWhereInput[]
    id?: IntFilter<"ServiceStatementAction"> | number
    ssactionname?: StringFilter<"ServiceStatementAction"> | string
    createDate?: DateTimeNullableFilter<"ServiceStatementAction"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"ServiceStatementAction"> | Date | string | null
    statementid?: IntFilter<"ServiceStatementAction"> | number
    serviceactionid?: IntFilter<"ServiceStatementAction"> | number
  }

  export type ServiceStatementCreateWithoutServicestatementactionsInput = {
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    service: ServiceCreateNestedOneWithoutServicestatementsInput
    policies?: PolicyCreateNestedManyWithoutServicestatementsInput
  }

  export type ServiceStatementUncheckedCreateWithoutServicestatementactionsInput = {
    id?: number
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    serviceid: number
    policies?: PolicyUncheckedCreateNestedManyWithoutServicestatementsInput
  }

  export type ServiceStatementCreateOrConnectWithoutServicestatementactionsInput = {
    where: ServiceStatementWhereUniqueInput
    create: XOR<ServiceStatementCreateWithoutServicestatementactionsInput, ServiceStatementUncheckedCreateWithoutServicestatementactionsInput>
  }

  export type ServiceActionCreateWithoutServiceStatementActionsInput = {
    serviceactionname: string
    services?: ServiceCreateNestedManyWithoutServiceactionsInput
  }

  export type ServiceActionUncheckedCreateWithoutServiceStatementActionsInput = {
    id?: number
    serviceactionname: string
    services?: ServiceUncheckedCreateNestedManyWithoutServiceactionsInput
  }

  export type ServiceActionCreateOrConnectWithoutServiceStatementActionsInput = {
    where: ServiceActionWhereUniqueInput
    create: XOR<ServiceActionCreateWithoutServiceStatementActionsInput, ServiceActionUncheckedCreateWithoutServiceStatementActionsInput>
  }

  export type ServiceStatementUpsertWithoutServicestatementactionsInput = {
    update: XOR<ServiceStatementUpdateWithoutServicestatementactionsInput, ServiceStatementUncheckedUpdateWithoutServicestatementactionsInput>
    create: XOR<ServiceStatementCreateWithoutServicestatementactionsInput, ServiceStatementUncheckedCreateWithoutServicestatementactionsInput>
    where?: ServiceStatementWhereInput
  }

  export type ServiceStatementUpdateToOneWithWhereWithoutServicestatementactionsInput = {
    where?: ServiceStatementWhereInput
    data: XOR<ServiceStatementUpdateWithoutServicestatementactionsInput, ServiceStatementUncheckedUpdateWithoutServicestatementactionsInput>
  }

  export type ServiceStatementUpdateWithoutServicestatementactionsInput = {
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: ServiceUpdateOneRequiredWithoutServicestatementsNestedInput
    policies?: PolicyUpdateManyWithoutServicestatementsNestedInput
  }

  export type ServiceStatementUncheckedUpdateWithoutServicestatementactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceid?: IntFieldUpdateOperationsInput | number
    policies?: PolicyUncheckedUpdateManyWithoutServicestatementsNestedInput
  }

  export type ServiceActionUpsertWithoutServiceStatementActionsInput = {
    update: XOR<ServiceActionUpdateWithoutServiceStatementActionsInput, ServiceActionUncheckedUpdateWithoutServiceStatementActionsInput>
    create: XOR<ServiceActionCreateWithoutServiceStatementActionsInput, ServiceActionUncheckedCreateWithoutServiceStatementActionsInput>
    where?: ServiceActionWhereInput
  }

  export type ServiceActionUpdateToOneWithWhereWithoutServiceStatementActionsInput = {
    where?: ServiceActionWhereInput
    data: XOR<ServiceActionUpdateWithoutServiceStatementActionsInput, ServiceActionUncheckedUpdateWithoutServiceStatementActionsInput>
  }

  export type ServiceActionUpdateWithoutServiceStatementActionsInput = {
    serviceactionname?: StringFieldUpdateOperationsInput | string
    services?: ServiceUpdateManyWithoutServiceactionsNestedInput
  }

  export type ServiceActionUncheckedUpdateWithoutServiceStatementActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceactionname?: StringFieldUpdateOperationsInput | string
    services?: ServiceUncheckedUpdateManyWithoutServiceactionsNestedInput
  }

  export type ServiceCreateWithoutServicestatementsInput = {
    servicename: string
    serviceactions?: ServiceActionCreateNestedManyWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutServicestatementsInput = {
    id?: number
    servicename: string
    serviceactions?: ServiceActionUncheckedCreateNestedManyWithoutServicesInput
  }

  export type ServiceCreateOrConnectWithoutServicestatementsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServicestatementsInput, ServiceUncheckedCreateWithoutServicestatementsInput>
  }

  export type ServiceStatementActionCreateWithoutServicestatementInput = {
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    serviceaction: ServiceActionCreateNestedOneWithoutServiceStatementActionsInput
  }

  export type ServiceStatementActionUncheckedCreateWithoutServicestatementInput = {
    id?: number
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    serviceactionid: number
  }

  export type ServiceStatementActionCreateOrConnectWithoutServicestatementInput = {
    where: ServiceStatementActionWhereUniqueInput
    create: XOR<ServiceStatementActionCreateWithoutServicestatementInput, ServiceStatementActionUncheckedCreateWithoutServicestatementInput>
  }

  export type ServiceStatementActionCreateManyServicestatementInputEnvelope = {
    data: ServiceStatementActionCreateManyServicestatementInput | ServiceStatementActionCreateManyServicestatementInput[]
    skipDuplicates?: boolean
  }

  export type PolicyCreateWithoutServicestatementsInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    roles?: RoleCreateNestedManyWithoutPoliciesInput
    users?: UserCreateNestedManyWithoutPoliciesInput
    groups?: GroupCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateWithoutServicestatementsInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    roles?: RoleUncheckedCreateNestedManyWithoutPoliciesInput
    users?: UserUncheckedCreateNestedManyWithoutPoliciesInput
    groups?: GroupUncheckedCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyCreateOrConnectWithoutServicestatementsInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutServicestatementsInput, PolicyUncheckedCreateWithoutServicestatementsInput>
  }

  export type ServiceUpsertWithoutServicestatementsInput = {
    update: XOR<ServiceUpdateWithoutServicestatementsInput, ServiceUncheckedUpdateWithoutServicestatementsInput>
    create: XOR<ServiceCreateWithoutServicestatementsInput, ServiceUncheckedCreateWithoutServicestatementsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServicestatementsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServicestatementsInput, ServiceUncheckedUpdateWithoutServicestatementsInput>
  }

  export type ServiceUpdateWithoutServicestatementsInput = {
    servicename?: StringFieldUpdateOperationsInput | string
    serviceactions?: ServiceActionUpdateManyWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServicestatementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicename?: StringFieldUpdateOperationsInput | string
    serviceactions?: ServiceActionUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type ServiceStatementActionUpsertWithWhereUniqueWithoutServicestatementInput = {
    where: ServiceStatementActionWhereUniqueInput
    update: XOR<ServiceStatementActionUpdateWithoutServicestatementInput, ServiceStatementActionUncheckedUpdateWithoutServicestatementInput>
    create: XOR<ServiceStatementActionCreateWithoutServicestatementInput, ServiceStatementActionUncheckedCreateWithoutServicestatementInput>
  }

  export type ServiceStatementActionUpdateWithWhereUniqueWithoutServicestatementInput = {
    where: ServiceStatementActionWhereUniqueInput
    data: XOR<ServiceStatementActionUpdateWithoutServicestatementInput, ServiceStatementActionUncheckedUpdateWithoutServicestatementInput>
  }

  export type ServiceStatementActionUpdateManyWithWhereWithoutServicestatementInput = {
    where: ServiceStatementActionScalarWhereInput
    data: XOR<ServiceStatementActionUpdateManyMutationInput, ServiceStatementActionUncheckedUpdateManyWithoutServicestatementInput>
  }

  export type PolicyUpsertWithWhereUniqueWithoutServicestatementsInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutServicestatementsInput, PolicyUncheckedUpdateWithoutServicestatementsInput>
    create: XOR<PolicyCreateWithoutServicestatementsInput, PolicyUncheckedCreateWithoutServicestatementsInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutServicestatementsInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutServicestatementsInput, PolicyUncheckedUpdateWithoutServicestatementsInput>
  }

  export type PolicyUpdateManyWithWhereWithoutServicestatementsInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutServicestatementsInput>
  }

  export type PolicyScalarWhereInput = {
    AND?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    OR?: PolicyScalarWhereInput[]
    NOT?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    id?: IntFilter<"Policy"> | number
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    managed?: BoolNullableFilter<"Policy"> | boolean | null
    system?: BoolNullableFilter<"Policy"> | boolean | null
    createDate?: DateTimeNullableFilter<"Policy"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Policy"> | Date | string | null
  }

  export type ServiceStatementCreateWithoutPoliciesInput = {
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    service: ServiceCreateNestedOneWithoutServicestatementsInput
    servicestatementactions?: ServiceStatementActionCreateNestedManyWithoutServicestatementInput
  }

  export type ServiceStatementUncheckedCreateWithoutPoliciesInput = {
    id?: number
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    serviceid: number
    servicestatementactions?: ServiceStatementActionUncheckedCreateNestedManyWithoutServicestatementInput
  }

  export type ServiceStatementCreateOrConnectWithoutPoliciesInput = {
    where: ServiceStatementWhereUniqueInput
    create: XOR<ServiceStatementCreateWithoutPoliciesInput, ServiceStatementUncheckedCreateWithoutPoliciesInput>
  }

  export type RoleCreateWithoutPoliciesInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    users?: UserCreateNestedManyWithoutRolesInput
    groups?: GroupCreateNestedManyWithoutRolesInput
  }

  export type RoleUncheckedCreateWithoutPoliciesInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    groups?: GroupUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RoleCreateOrConnectWithoutPoliciesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPoliciesInput, RoleUncheckedCreateWithoutPoliciesInput>
  }

  export type UserCreateWithoutPoliciesInput = {
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressCreateNestedOneWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
    account?: AccountCreateNestedOneWithoutUserInput
    settings?: UserSettingCreateNestedManyWithoutUsersInput
    pats?: UserPATCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPoliciesInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingUncheckedCreateNestedManyWithoutUsersInput
    pats?: UserPATUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPoliciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPoliciesInput, UserUncheckedCreateWithoutPoliciesInput>
  }

  export type GroupCreateWithoutPoliciesInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    roles?: RoleCreateNestedManyWithoutGroupsInput
    users?: UserCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutPoliciesInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    roles?: RoleUncheckedCreateNestedManyWithoutGroupsInput
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutPoliciesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutPoliciesInput, GroupUncheckedCreateWithoutPoliciesInput>
  }

  export type ServiceStatementUpsertWithWhereUniqueWithoutPoliciesInput = {
    where: ServiceStatementWhereUniqueInput
    update: XOR<ServiceStatementUpdateWithoutPoliciesInput, ServiceStatementUncheckedUpdateWithoutPoliciesInput>
    create: XOR<ServiceStatementCreateWithoutPoliciesInput, ServiceStatementUncheckedCreateWithoutPoliciesInput>
  }

  export type ServiceStatementUpdateWithWhereUniqueWithoutPoliciesInput = {
    where: ServiceStatementWhereUniqueInput
    data: XOR<ServiceStatementUpdateWithoutPoliciesInput, ServiceStatementUncheckedUpdateWithoutPoliciesInput>
  }

  export type ServiceStatementUpdateManyWithWhereWithoutPoliciesInput = {
    where: ServiceStatementScalarWhereInput
    data: XOR<ServiceStatementUpdateManyMutationInput, ServiceStatementUncheckedUpdateManyWithoutPoliciesInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutPoliciesInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutPoliciesInput, RoleUncheckedUpdateWithoutPoliciesInput>
    create: XOR<RoleCreateWithoutPoliciesInput, RoleUncheckedCreateWithoutPoliciesInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutPoliciesInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutPoliciesInput, RoleUncheckedUpdateWithoutPoliciesInput>
  }

  export type RoleUpdateManyWithWhereWithoutPoliciesInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutPoliciesInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    managed?: BoolNullableFilter<"Role"> | boolean | null
    system?: BoolNullableFilter<"Role"> | boolean | null
    createDate?: DateTimeNullableFilter<"Role"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Role"> | Date | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutPoliciesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPoliciesInput, UserUncheckedUpdateWithoutPoliciesInput>
    create: XOR<UserCreateWithoutPoliciesInput, UserUncheckedCreateWithoutPoliciesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPoliciesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPoliciesInput, UserUncheckedUpdateWithoutPoliciesInput>
  }

  export type UserUpdateManyWithWhereWithoutPoliciesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutPoliciesInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringNullableFilter<"User"> | string | null
    lastname?: StringFilter<"User"> | string
    firstname?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    passwordless?: BoolNullableFilter<"User"> | boolean | null
    attemps?: IntNullableFilter<"User"> | number | null
    blocked?: BoolNullableFilter<"User"> | boolean | null
    managed?: BoolNullableFilter<"User"> | boolean | null
    system?: BoolNullableFilter<"User"> | boolean | null
    loggedinDate?: DateTimeNullableFilter<"User"> | Date | string | null
    type?: EnumUserTypeFilter<"User"> | $Enums.UserType
    createDate?: DateTimeNullableFilter<"User"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type GroupUpsertWithWhereUniqueWithoutPoliciesInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutPoliciesInput, GroupUncheckedUpdateWithoutPoliciesInput>
    create: XOR<GroupCreateWithoutPoliciesInput, GroupUncheckedCreateWithoutPoliciesInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutPoliciesInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutPoliciesInput, GroupUncheckedUpdateWithoutPoliciesInput>
  }

  export type GroupUpdateManyWithWhereWithoutPoliciesInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutPoliciesInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: IntFilter<"Group"> | number
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    managed?: BoolNullableFilter<"Group"> | boolean | null
    system?: BoolNullableFilter<"Group"> | boolean | null
    createDate?: DateTimeNullableFilter<"Group"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Group"> | Date | string | null
  }

  export type PolicyCreateWithoutRolesInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatements?: ServiceStatementCreateNestedManyWithoutPoliciesInput
    users?: UserCreateNestedManyWithoutPoliciesInput
    groups?: GroupCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateWithoutRolesInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatements?: ServiceStatementUncheckedCreateNestedManyWithoutPoliciesInput
    users?: UserUncheckedCreateNestedManyWithoutPoliciesInput
    groups?: GroupUncheckedCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyCreateOrConnectWithoutRolesInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutRolesInput, PolicyUncheckedCreateWithoutRolesInput>
  }

  export type UserCreateWithoutRolesInput = {
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressCreateNestedOneWithoutUserInput
    policies?: PolicyCreateNestedManyWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
    account?: AccountCreateNestedOneWithoutUserInput
    settings?: UserSettingCreateNestedManyWithoutUsersInput
    pats?: UserPATCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    policies?: PolicyUncheckedCreateNestedManyWithoutUsersInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingUncheckedCreateNestedManyWithoutUsersInput
    pats?: UserPATUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type GroupCreateWithoutRolesInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyCreateNestedManyWithoutGroupsInput
    users?: UserCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutRolesInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyUncheckedCreateNestedManyWithoutGroupsInput
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutRolesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput>
  }

  export type PolicyUpsertWithWhereUniqueWithoutRolesInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutRolesInput, PolicyUncheckedUpdateWithoutRolesInput>
    create: XOR<PolicyCreateWithoutRolesInput, PolicyUncheckedCreateWithoutRolesInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutRolesInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutRolesInput, PolicyUncheckedUpdateWithoutRolesInput>
  }

  export type PolicyUpdateManyWithWhereWithoutRolesInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutRolesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateManyWithWhereWithoutRolesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRolesInput>
  }

  export type GroupUpsertWithWhereUniqueWithoutRolesInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutRolesInput, GroupUncheckedUpdateWithoutRolesInput>
    create: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutRolesInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutRolesInput, GroupUncheckedUpdateWithoutRolesInput>
  }

  export type GroupUpdateManyWithWhereWithoutRolesInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutRolesInput>
  }

  export type AddressCreateWithoutCountryInput = {
    street?: string | null
    number?: string | null
    box?: string | null
    city?: string | null
    postalcode?: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    county?: string | null
    user?: UserCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCountryInput = {
    id?: number
    street?: string | null
    number?: string | null
    box?: string | null
    city?: string | null
    postalcode?: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    county?: string | null
    userId?: number | null
  }

  export type AddressCreateOrConnectWithoutCountryInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput>
  }

  export type AddressCreateManyCountryInputEnvelope = {
    data: AddressCreateManyCountryInput | AddressCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutCountryInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCountryInput, AddressUncheckedUpdateWithoutCountryInput>
    create: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCountryInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCountryInput, AddressUncheckedUpdateWithoutCountryInput>
  }

  export type AddressUpdateManyWithWhereWithoutCountryInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutCountryInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    street?: StringNullableFilter<"Address"> | string | null
    number?: StringNullableFilter<"Address"> | string | null
    box?: StringNullableFilter<"Address"> | string | null
    city?: StringNullableFilter<"Address"> | string | null
    postalcode?: StringFilter<"Address"> | string
    createDate?: DateTimeNullableFilter<"Address"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Address"> | Date | string | null
    county?: StringNullableFilter<"Address"> | string | null
    countryId?: IntNullableFilter<"Address"> | number | null
    userId?: IntNullableFilter<"Address"> | number | null
  }

  export type CountryCreateWithoutAddressesInput = {
    name: string
    dialCode?: string | null
    code?: string | null
    currency?: string | null
    currencycode?: string | null
    symbol?: string | null
  }

  export type CountryUncheckedCreateWithoutAddressesInput = {
    id?: number
    name: string
    dialCode?: string | null
    code?: string | null
    currency?: string | null
    currencycode?: string | null
    symbol?: string | null
  }

  export type CountryCreateOrConnectWithoutAddressesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutAddressesInput, CountryUncheckedCreateWithoutAddressesInput>
  }

  export type UserCreateWithoutAddressInput = {
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyCreateNestedManyWithoutUsersInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
    account?: AccountCreateNestedOneWithoutUserInput
    settings?: UserSettingCreateNestedManyWithoutUsersInput
    pats?: UserPATCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyUncheckedCreateNestedManyWithoutUsersInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingUncheckedCreateNestedManyWithoutUsersInput
    pats?: UserPATUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type CountryUpsertWithoutAddressesInput = {
    update: XOR<CountryUpdateWithoutAddressesInput, CountryUncheckedUpdateWithoutAddressesInput>
    create: XOR<CountryCreateWithoutAddressesInput, CountryUncheckedCreateWithoutAddressesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutAddressesInput, CountryUncheckedUpdateWithoutAddressesInput>
  }

  export type CountryUpdateWithoutAddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencycode?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dialCode?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencycode?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutAddressInput = {
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserUpdateWithoutAddressInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUpdateManyWithoutUsersNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    settings?: UserSettingUpdateManyWithoutUsersNestedInput
    pats?: UserPATUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUncheckedUpdateManyWithoutUsersNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingUncheckedUpdateManyWithoutUsersNestedInput
    pats?: UserPATUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AddressCreateWithoutUserInput = {
    street?: string | null
    number?: string | null
    box?: string | null
    city?: string | null
    postalcode?: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    county?: string | null
    country?: CountryCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: number
    street?: string | null
    number?: string | null
    box?: string | null
    city?: string | null
    postalcode?: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    county?: string | null
    countryId?: number | null
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type PolicyCreateWithoutUsersInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatements?: ServiceStatementCreateNestedManyWithoutPoliciesInput
    roles?: RoleCreateNestedManyWithoutPoliciesInput
    groups?: GroupCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatements?: ServiceStatementUncheckedCreateNestedManyWithoutPoliciesInput
    roles?: RoleUncheckedCreateNestedManyWithoutPoliciesInput
    groups?: GroupUncheckedCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyCreateOrConnectWithoutUsersInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutUsersInput, PolicyUncheckedCreateWithoutUsersInput>
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyCreateNestedManyWithoutRolesInput
    groups?: GroupCreateNestedManyWithoutRolesInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyUncheckedCreateNestedManyWithoutRolesInput
    groups?: GroupUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type GroupCreateWithoutUsersInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyCreateNestedManyWithoutGroupsInput
    roles?: RoleCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyUncheckedCreateNestedManyWithoutGroupsInput
    roles?: RoleUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutUsersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
  }

  export type AccountCreateWithoutUserInput = {
    amount: number
    status?: $Enums.AccountStatus
    createDate?: Date | string
    updateDate?: Date | string
    sendertransactions?: TransactionCreateNestedManyWithoutSenderAccountInput
    receivertransactions?: TransactionCreateNestedManyWithoutReceiverAccountInput
    bankaccounts?: BankAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    status?: $Enums.AccountStatus
    createDate?: Date | string
    updateDate?: Date | string
    sendertransactions?: TransactionUncheckedCreateNestedManyWithoutSenderAccountInput
    receivertransactions?: TransactionUncheckedCreateNestedManyWithoutReceiverAccountInput
    bankaccounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type UserSettingCreateWithoutUsersInput = {
    key: string
    value: string
  }

  export type UserSettingUncheckedCreateWithoutUsersInput = {
    id?: number
    key: string
    value: string
  }

  export type UserSettingCreateOrConnectWithoutUsersInput = {
    where: UserSettingWhereUniqueInput
    create: XOR<UserSettingCreateWithoutUsersInput, UserSettingUncheckedCreateWithoutUsersInput>
  }

  export type UserPATCreateWithoutUserInput = {
    tokenName: string
    token: string
    createDate?: Date | string | null
    expirationDate: Date | string
    tokenStatus: $Enums.TokenStatus
  }

  export type UserPATUncheckedCreateWithoutUserInput = {
    id?: number
    tokenName: string
    token: string
    createDate?: Date | string | null
    expirationDate: Date | string
    tokenStatus: $Enums.TokenStatus
  }

  export type UserPATCreateOrConnectWithoutUserInput = {
    where: UserPATWhereUniqueInput
    create: XOR<UserPATCreateWithoutUserInput, UserPATUncheckedCreateWithoutUserInput>
  }

  export type UserPATCreateManyUserInputEnvelope = {
    data: UserPATCreateManyUserInput | UserPATCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutUserInput = {
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutUserInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateWithoutUserInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PolicyUpsertWithWhereUniqueWithoutUsersInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutUsersInput, PolicyUncheckedUpdateWithoutUsersInput>
    create: XOR<PolicyCreateWithoutUsersInput, PolicyUncheckedCreateWithoutUsersInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutUsersInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutUsersInput, PolicyUncheckedUpdateWithoutUsersInput>
  }

  export type PolicyUpdateManyWithWhereWithoutUsersInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutUsersInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateManyWithWhereWithoutUsersInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutUsersInput>
  }

  export type GroupUpsertWithWhereUniqueWithoutUsersInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutUsersInput, GroupUncheckedUpdateWithoutUsersInput>
    create: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutUsersInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutUsersInput, GroupUncheckedUpdateWithoutUsersInput>
  }

  export type GroupUpdateManyWithWhereWithoutUsersInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutUsersInput>
  }

  export type AccountUpsertWithoutUserInput = {
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutUserInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendertransactions?: TransactionUpdateManyWithoutSenderAccountNestedInput
    receivertransactions?: TransactionUpdateManyWithoutReceiverAccountNestedInput
    bankaccounts?: BankAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendertransactions?: TransactionUncheckedUpdateManyWithoutSenderAccountNestedInput
    receivertransactions?: TransactionUncheckedUpdateManyWithoutReceiverAccountNestedInput
    bankaccounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserSettingUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserSettingWhereUniqueInput
    update: XOR<UserSettingUpdateWithoutUsersInput, UserSettingUncheckedUpdateWithoutUsersInput>
    create: XOR<UserSettingCreateWithoutUsersInput, UserSettingUncheckedCreateWithoutUsersInput>
  }

  export type UserSettingUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserSettingWhereUniqueInput
    data: XOR<UserSettingUpdateWithoutUsersInput, UserSettingUncheckedUpdateWithoutUsersInput>
  }

  export type UserSettingUpdateManyWithWhereWithoutUsersInput = {
    where: UserSettingScalarWhereInput
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserSettingScalarWhereInput = {
    AND?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
    OR?: UserSettingScalarWhereInput[]
    NOT?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
    id?: IntFilter<"UserSetting"> | number
    key?: StringFilter<"UserSetting"> | string
    value?: StringFilter<"UserSetting"> | string
  }

  export type UserPATUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPATWhereUniqueInput
    update: XOR<UserPATUpdateWithoutUserInput, UserPATUncheckedUpdateWithoutUserInput>
    create: XOR<UserPATCreateWithoutUserInput, UserPATUncheckedCreateWithoutUserInput>
  }

  export type UserPATUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPATWhereUniqueInput
    data: XOR<UserPATUpdateWithoutUserInput, UserPATUncheckedUpdateWithoutUserInput>
  }

  export type UserPATUpdateManyWithWhereWithoutUserInput = {
    where: UserPATScalarWhereInput
    data: XOR<UserPATUpdateManyMutationInput, UserPATUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPATScalarWhereInput = {
    AND?: UserPATScalarWhereInput | UserPATScalarWhereInput[]
    OR?: UserPATScalarWhereInput[]
    NOT?: UserPATScalarWhereInput | UserPATScalarWhereInput[]
    id?: IntFilter<"UserPAT"> | number
    tokenName?: StringFilter<"UserPAT"> | string
    token?: StringFilter<"UserPAT"> | string
    createDate?: DateTimeNullableFilter<"UserPAT"> | Date | string | null
    expirationDate?: DateTimeFilter<"UserPAT"> | Date | string
    tokenStatus?: EnumTokenStatusFilter<"UserPAT"> | $Enums.TokenStatus
    userId?: IntFilter<"UserPAT"> | number
  }

  export type UserCreateWithoutPatsInput = {
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressCreateNestedOneWithoutUserInput
    policies?: PolicyCreateNestedManyWithoutUsersInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
    account?: AccountCreateNestedOneWithoutUserInput
    settings?: UserSettingCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPatsInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    policies?: PolicyUncheckedCreateNestedManyWithoutUsersInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutPatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatsInput, UserUncheckedCreateWithoutPatsInput>
  }

  export type UserUpsertWithoutPatsInput = {
    update: XOR<UserUpdateWithoutPatsInput, UserUncheckedUpdateWithoutPatsInput>
    create: XOR<UserCreateWithoutPatsInput, UserUncheckedCreateWithoutPatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatsInput, UserUncheckedUpdateWithoutPatsInput>
  }

  export type UserUpdateWithoutPatsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    policies?: PolicyUpdateManyWithoutUsersNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    settings?: UserSettingUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutUsersNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutSettingsInput = {
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressCreateNestedOneWithoutUserInput
    policies?: PolicyCreateNestedManyWithoutUsersInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
    account?: AccountCreateNestedOneWithoutUserInput
    pats?: UserPATCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    policies?: PolicyUncheckedCreateNestedManyWithoutUsersInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    pats?: UserPATUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutSettingsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSettingsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateManyWithWhereWithoutSettingsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSettingsInput>
  }

  export type PolicyCreateWithoutGroupsInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatements?: ServiceStatementCreateNestedManyWithoutPoliciesInput
    roles?: RoleCreateNestedManyWithoutPoliciesInput
    users?: UserCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateWithoutGroupsInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    servicestatements?: ServiceStatementUncheckedCreateNestedManyWithoutPoliciesInput
    roles?: RoleUncheckedCreateNestedManyWithoutPoliciesInput
    users?: UserUncheckedCreateNestedManyWithoutPoliciesInput
  }

  export type PolicyCreateOrConnectWithoutGroupsInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutGroupsInput, PolicyUncheckedCreateWithoutGroupsInput>
  }

  export type RoleCreateWithoutGroupsInput = {
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyCreateNestedManyWithoutRolesInput
    users?: UserCreateNestedManyWithoutRolesInput
  }

  export type RoleUncheckedCreateWithoutGroupsInput = {
    id?: number
    name: string
    description?: string | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    policies?: PolicyUncheckedCreateNestedManyWithoutRolesInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RoleCreateOrConnectWithoutGroupsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput>
  }

  export type UserCreateWithoutGroupsInput = {
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressCreateNestedOneWithoutUserInput
    policies?: PolicyCreateNestedManyWithoutUsersInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    account?: AccountCreateNestedOneWithoutUserInput
    settings?: UserSettingCreateNestedManyWithoutUsersInput
    pats?: UserPATCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupsInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    policies?: PolicyUncheckedCreateNestedManyWithoutUsersInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingUncheckedCreateNestedManyWithoutUsersInput
    pats?: UserPATUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type PolicyUpsertWithWhereUniqueWithoutGroupsInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutGroupsInput, PolicyUncheckedUpdateWithoutGroupsInput>
    create: XOR<PolicyCreateWithoutGroupsInput, PolicyUncheckedCreateWithoutGroupsInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutGroupsInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutGroupsInput, PolicyUncheckedUpdateWithoutGroupsInput>
  }

  export type PolicyUpdateManyWithWhereWithoutGroupsInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutGroupsInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutGroupsInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutGroupsInput, RoleUncheckedUpdateWithoutGroupsInput>
    create: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutGroupsInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutGroupsInput, RoleUncheckedUpdateWithoutGroupsInput>
  }

  export type RoleUpdateManyWithWhereWithoutGroupsInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutGroupsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
  }

  export type UserUpdateManyWithWhereWithoutGroupsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutGroupsInput>
  }

  export type UserCreateWithoutAccountInput = {
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressCreateNestedOneWithoutUserInput
    policies?: PolicyCreateNestedManyWithoutUsersInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
    settings?: UserSettingCreateNestedManyWithoutUsersInput
    pats?: UserPATCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: number
    username?: string | null
    lastname: string
    firstname: string
    avatar?: string | null
    phone?: string | null
    email: string
    password: string
    passwordless?: boolean | null
    attemps?: number | null
    blocked?: boolean | null
    managed?: boolean | null
    system?: boolean | null
    loggedinDate?: Date | string | null
    type?: $Enums.UserType
    createDate?: Date | string | null
    updateDate?: Date | string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    policies?: PolicyUncheckedCreateNestedManyWithoutUsersInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
    settings?: UserSettingUncheckedCreateNestedManyWithoutUsersInput
    pats?: UserPATUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateWithoutSenderAccountInput = {
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    receiverAccount?: AccountCreateNestedOneWithoutReceivertransactionsInput
  }

  export type TransactionUncheckedCreateWithoutSenderAccountInput = {
    id?: number
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    receiverAccountId?: number | null
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutSenderAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSenderAccountInput, TransactionUncheckedCreateWithoutSenderAccountInput>
  }

  export type TransactionCreateManySenderAccountInputEnvelope = {
    data: TransactionCreateManySenderAccountInput | TransactionCreateManySenderAccountInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutReceiverAccountInput = {
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
    senderAccount?: AccountCreateNestedOneWithoutSendertransactionsInput
  }

  export type TransactionUncheckedCreateWithoutReceiverAccountInput = {
    id?: number
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    senderAccountId: number
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutReceiverAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutReceiverAccountInput, TransactionUncheckedCreateWithoutReceiverAccountInput>
  }

  export type TransactionCreateManyReceiverAccountInputEnvelope = {
    data: TransactionCreateManyReceiverAccountInput | TransactionCreateManyReceiverAccountInput[]
    skipDuplicates?: boolean
  }

  export type BankAccountCreateWithoutAccountInput = {
    IBAN: string
    status: $Enums.IBANStatus
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type BankAccountUncheckedCreateWithoutAccountInput = {
    id?: number
    IBAN: string
    status: $Enums.IBANStatus
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type BankAccountCreateOrConnectWithoutAccountInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput>
  }

  export type BankAccountCreateManyAccountInputEnvelope = {
    data: BankAccountCreateManyAccountInput | BankAccountCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserUpdateWithoutAccountInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    policies?: PolicyUpdateManyWithoutUsersNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
    settings?: UserSettingUpdateManyWithoutUsersNestedInput
    pats?: UserPATUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutUsersNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
    settings?: UserSettingUncheckedUpdateManyWithoutUsersNestedInput
    pats?: UserPATUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutSenderAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSenderAccountInput, TransactionUncheckedUpdateWithoutSenderAccountInput>
    create: XOR<TransactionCreateWithoutSenderAccountInput, TransactionUncheckedCreateWithoutSenderAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSenderAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSenderAccountInput, TransactionUncheckedUpdateWithoutSenderAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSenderAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSenderAccountInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    transactionid?: StringFilter<"Transaction"> | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    statusMessage?: StringFilter<"Transaction"> | string
    isBankTransaction?: BoolFilter<"Transaction"> | boolean
    senderAmount?: FloatFilter<"Transaction"> | number
    receiverAmount?: FloatNullableFilter<"Transaction"> | number | null
    senderAccountAmount?: FloatFilter<"Transaction"> | number
    receiverAccountAmount?: FloatNullableFilter<"Transaction"> | number | null
    senderAccountId?: IntFilter<"Transaction"> | number
    receiverAccountId?: IntNullableFilter<"Transaction"> | number | null
    sender?: StringNullableFilter<"Transaction"> | string | null
    receiver?: StringNullableFilter<"Transaction"> | string | null
    message?: StringNullableFilter<"Transaction"> | string | null
    createDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    updateDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutReceiverAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutReceiverAccountInput, TransactionUncheckedUpdateWithoutReceiverAccountInput>
    create: XOR<TransactionCreateWithoutReceiverAccountInput, TransactionUncheckedCreateWithoutReceiverAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutReceiverAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutReceiverAccountInput, TransactionUncheckedUpdateWithoutReceiverAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutReceiverAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutReceiverAccountInput>
  }

  export type BankAccountUpsertWithWhereUniqueWithoutAccountInput = {
    where: BankAccountWhereUniqueInput
    update: XOR<BankAccountUpdateWithoutAccountInput, BankAccountUncheckedUpdateWithoutAccountInput>
    create: XOR<BankAccountCreateWithoutAccountInput, BankAccountUncheckedCreateWithoutAccountInput>
  }

  export type BankAccountUpdateWithWhereUniqueWithoutAccountInput = {
    where: BankAccountWhereUniqueInput
    data: XOR<BankAccountUpdateWithoutAccountInput, BankAccountUncheckedUpdateWithoutAccountInput>
  }

  export type BankAccountUpdateManyWithWhereWithoutAccountInput = {
    where: BankAccountScalarWhereInput
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type BankAccountScalarWhereInput = {
    AND?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    OR?: BankAccountScalarWhereInput[]
    NOT?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    id?: IntFilter<"BankAccount"> | number
    IBAN?: StringFilter<"BankAccount"> | string
    status?: EnumIBANStatusFilter<"BankAccount"> | $Enums.IBANStatus
    createDate?: DateTimeFilter<"BankAccount"> | Date | string
    updateDate?: DateTimeFilter<"BankAccount"> | Date | string
    accountId?: IntFilter<"BankAccount"> | number
  }

  export type TaskCreateWithoutSuccessorTaskInput = {
    name: string
    description: string
    status?: $Enums.TaskStatus
    params: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskCreatefromStatusInput | $Enums.TaskStatus[]
    createDate?: Date | string | null
    updateDate?: Date | string | null
    predecessorTask?: TaskCreateNestedOneWithoutSuccessorTaskInput
  }

  export type TaskUncheckedCreateWithoutSuccessorTaskInput = {
    id?: number
    name: string
    description: string
    status?: $Enums.TaskStatus
    params: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskCreatefromStatusInput | $Enums.TaskStatus[]
    predecessorTaskId?: number | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type TaskCreateOrConnectWithoutSuccessorTaskInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSuccessorTaskInput, TaskUncheckedCreateWithoutSuccessorTaskInput>
  }

  export type TaskCreateWithoutPredecessorTaskInput = {
    name: string
    description: string
    status?: $Enums.TaskStatus
    params: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskCreatefromStatusInput | $Enums.TaskStatus[]
    createDate?: Date | string | null
    updateDate?: Date | string | null
    successorTask?: TaskCreateNestedOneWithoutPredecessorTaskInput
  }

  export type TaskUncheckedCreateWithoutPredecessorTaskInput = {
    id?: number
    name: string
    description: string
    status?: $Enums.TaskStatus
    params: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskCreatefromStatusInput | $Enums.TaskStatus[]
    createDate?: Date | string | null
    updateDate?: Date | string | null
    successorTask?: TaskUncheckedCreateNestedOneWithoutPredecessorTaskInput
  }

  export type TaskCreateOrConnectWithoutPredecessorTaskInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutPredecessorTaskInput, TaskUncheckedCreateWithoutPredecessorTaskInput>
  }

  export type TaskUpsertWithoutSuccessorTaskInput = {
    update: XOR<TaskUpdateWithoutSuccessorTaskInput, TaskUncheckedUpdateWithoutSuccessorTaskInput>
    create: XOR<TaskCreateWithoutSuccessorTaskInput, TaskUncheckedCreateWithoutSuccessorTaskInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutSuccessorTaskInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutSuccessorTaskInput, TaskUncheckedUpdateWithoutSuccessorTaskInput>
  }

  export type TaskUpdateWithoutSuccessorTaskInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    params?: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskUpdatefromStatusInput | $Enums.TaskStatus[]
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    predecessorTask?: TaskUpdateOneWithoutSuccessorTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSuccessorTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    params?: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskUpdatefromStatusInput | $Enums.TaskStatus[]
    predecessorTaskId?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUpsertWithoutPredecessorTaskInput = {
    update: XOR<TaskUpdateWithoutPredecessorTaskInput, TaskUncheckedUpdateWithoutPredecessorTaskInput>
    create: XOR<TaskCreateWithoutPredecessorTaskInput, TaskUncheckedCreateWithoutPredecessorTaskInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutPredecessorTaskInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutPredecessorTaskInput, TaskUncheckedUpdateWithoutPredecessorTaskInput>
  }

  export type TaskUpdateWithoutPredecessorTaskInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    params?: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskUpdatefromStatusInput | $Enums.TaskStatus[]
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successorTask?: TaskUpdateOneWithoutPredecessorTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutPredecessorTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    params?: JsonNullValueInput | InputJsonValue
    fromStatus?: TaskUpdatefromStatusInput | $Enums.TaskStatus[]
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successorTask?: TaskUncheckedUpdateOneWithoutPredecessorTaskNestedInput
  }

  export type AccountCreateWithoutSendertransactionsInput = {
    amount: number
    status?: $Enums.AccountStatus
    createDate?: Date | string
    updateDate?: Date | string
    user?: UserCreateNestedOneWithoutAccountInput
    receivertransactions?: TransactionCreateNestedManyWithoutReceiverAccountInput
    bankaccounts?: BankAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutSendertransactionsInput = {
    id?: number
    amount: number
    status?: $Enums.AccountStatus
    userId?: number | null
    createDate?: Date | string
    updateDate?: Date | string
    receivertransactions?: TransactionUncheckedCreateNestedManyWithoutReceiverAccountInput
    bankaccounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutSendertransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSendertransactionsInput, AccountUncheckedCreateWithoutSendertransactionsInput>
  }

  export type AccountCreateWithoutReceivertransactionsInput = {
    amount: number
    status?: $Enums.AccountStatus
    createDate?: Date | string
    updateDate?: Date | string
    user?: UserCreateNestedOneWithoutAccountInput
    sendertransactions?: TransactionCreateNestedManyWithoutSenderAccountInput
    bankaccounts?: BankAccountCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutReceivertransactionsInput = {
    id?: number
    amount: number
    status?: $Enums.AccountStatus
    userId?: number | null
    createDate?: Date | string
    updateDate?: Date | string
    sendertransactions?: TransactionUncheckedCreateNestedManyWithoutSenderAccountInput
    bankaccounts?: BankAccountUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutReceivertransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutReceivertransactionsInput, AccountUncheckedCreateWithoutReceivertransactionsInput>
  }

  export type AccountUpsertWithoutSendertransactionsInput = {
    update: XOR<AccountUpdateWithoutSendertransactionsInput, AccountUncheckedUpdateWithoutSendertransactionsInput>
    create: XOR<AccountCreateWithoutSendertransactionsInput, AccountUncheckedCreateWithoutSendertransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSendertransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSendertransactionsInput, AccountUncheckedUpdateWithoutSendertransactionsInput>
  }

  export type AccountUpdateWithoutSendertransactionsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountNestedInput
    receivertransactions?: TransactionUpdateManyWithoutReceiverAccountNestedInput
    bankaccounts?: BankAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutSendertransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivertransactions?: TransactionUncheckedUpdateManyWithoutReceiverAccountNestedInput
    bankaccounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUpsertWithoutReceivertransactionsInput = {
    update: XOR<AccountUpdateWithoutReceivertransactionsInput, AccountUncheckedUpdateWithoutReceivertransactionsInput>
    create: XOR<AccountCreateWithoutReceivertransactionsInput, AccountUncheckedCreateWithoutReceivertransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutReceivertransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutReceivertransactionsInput, AccountUncheckedUpdateWithoutReceivertransactionsInput>
  }

  export type AccountUpdateWithoutReceivertransactionsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountNestedInput
    sendertransactions?: TransactionUpdateManyWithoutSenderAccountNestedInput
    bankaccounts?: BankAccountUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutReceivertransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendertransactions?: TransactionUncheckedUpdateManyWithoutSenderAccountNestedInput
    bankaccounts?: BankAccountUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateWithoutBankaccountsInput = {
    amount: number
    status?: $Enums.AccountStatus
    createDate?: Date | string
    updateDate?: Date | string
    user?: UserCreateNestedOneWithoutAccountInput
    sendertransactions?: TransactionCreateNestedManyWithoutSenderAccountInput
    receivertransactions?: TransactionCreateNestedManyWithoutReceiverAccountInput
  }

  export type AccountUncheckedCreateWithoutBankaccountsInput = {
    id?: number
    amount: number
    status?: $Enums.AccountStatus
    userId?: number | null
    createDate?: Date | string
    updateDate?: Date | string
    sendertransactions?: TransactionUncheckedCreateNestedManyWithoutSenderAccountInput
    receivertransactions?: TransactionUncheckedCreateNestedManyWithoutReceiverAccountInput
  }

  export type AccountCreateOrConnectWithoutBankaccountsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBankaccountsInput, AccountUncheckedCreateWithoutBankaccountsInput>
  }

  export type AccountUpsertWithoutBankaccountsInput = {
    update: XOR<AccountUpdateWithoutBankaccountsInput, AccountUncheckedUpdateWithoutBankaccountsInput>
    create: XOR<AccountCreateWithoutBankaccountsInput, AccountUncheckedCreateWithoutBankaccountsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutBankaccountsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutBankaccountsInput, AccountUncheckedUpdateWithoutBankaccountsInput>
  }

  export type AccountUpdateWithoutBankaccountsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountNestedInput
    sendertransactions?: TransactionUpdateManyWithoutSenderAccountNestedInput
    receivertransactions?: TransactionUpdateManyWithoutReceiverAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutBankaccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sendertransactions?: TransactionUncheckedUpdateManyWithoutSenderAccountNestedInput
    receivertransactions?: TransactionUncheckedUpdateManyWithoutReceiverAccountNestedInput
  }

  export type ServiceStatementCreateManyServiceInput = {
    id?: number
    ssname: string
    description?: string | null
    permission?: $Enums.Permission | null
    managed?: boolean | null
    system?: boolean | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type ServiceActionUpdateWithoutServicesInput = {
    serviceactionname?: StringFieldUpdateOperationsInput | string
    serviceStatementActions?: ServiceStatementActionUpdateManyWithoutServiceactionNestedInput
  }

  export type ServiceActionUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceactionname?: StringFieldUpdateOperationsInput | string
    serviceStatementActions?: ServiceStatementActionUncheckedUpdateManyWithoutServiceactionNestedInput
  }

  export type ServiceActionUncheckedUpdateManyWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceactionname?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceStatementUpdateWithoutServiceInput = {
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatementactions?: ServiceStatementActionUpdateManyWithoutServicestatementNestedInput
    policies?: PolicyUpdateManyWithoutServicestatementsNestedInput
  }

  export type ServiceStatementUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatementactions?: ServiceStatementActionUncheckedUpdateManyWithoutServicestatementNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutServicestatementsNestedInput
  }

  export type ServiceStatementUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceStatementActionCreateManyServiceactionInput = {
    id?: number
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    statementid: number
  }

  export type ServiceUpdateWithoutServiceactionsInput = {
    servicename?: StringFieldUpdateOperationsInput | string
    servicestatements?: ServiceStatementUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicename?: StringFieldUpdateOperationsInput | string
    servicestatements?: ServiceStatementUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServiceactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicename?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceStatementActionUpdateWithoutServiceactionInput = {
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatement?: ServiceStatementUpdateOneRequiredWithoutServicestatementactionsNestedInput
  }

  export type ServiceStatementActionUncheckedUpdateWithoutServiceactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statementid?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceStatementActionUncheckedUpdateManyWithoutServiceactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statementid?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceStatementActionCreateManyServicestatementInput = {
    id?: number
    ssactionname: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    serviceactionid: number
  }

  export type ServiceStatementActionUpdateWithoutServicestatementInput = {
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceaction?: ServiceActionUpdateOneRequiredWithoutServiceStatementActionsNestedInput
  }

  export type ServiceStatementActionUncheckedUpdateWithoutServicestatementInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceactionid?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceStatementActionUncheckedUpdateManyWithoutServicestatementInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssactionname?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceactionid?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyUpdateWithoutServicestatementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUpdateManyWithoutPoliciesNestedInput
    users?: UserUpdateManyWithoutPoliciesNestedInput
    groups?: GroupUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateWithoutServicestatementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUncheckedUpdateManyWithoutPoliciesNestedInput
    users?: UserUncheckedUpdateManyWithoutPoliciesNestedInput
    groups?: GroupUncheckedUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateManyWithoutServicestatementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceStatementUpdateWithoutPoliciesInput = {
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: ServiceUpdateOneRequiredWithoutServicestatementsNestedInput
    servicestatementactions?: ServiceStatementActionUpdateManyWithoutServicestatementNestedInput
  }

  export type ServiceStatementUncheckedUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceid?: IntFieldUpdateOperationsInput | number
    servicestatementactions?: ServiceStatementActionUncheckedUpdateManyWithoutServicestatementNestedInput
  }

  export type ServiceStatementUncheckedUpdateManyWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ssname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableEnumPermissionFieldUpdateOperationsInput | $Enums.Permission | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serviceid?: IntFieldUpdateOperationsInput | number
  }

  export type RoleUpdateWithoutPoliciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutRolesNestedInput
    groups?: GroupUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    groups?: GroupUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutPoliciesInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    settings?: UserSettingUpdateManyWithoutUsersNestedInput
    pats?: UserPATUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingUncheckedUpdateManyWithoutUsersNestedInput
    pats?: UserPATUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupUpdateWithoutPoliciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUpdateManyWithoutGroupsNestedInput
    users?: UserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: RoleUncheckedUpdateManyWithoutGroupsNestedInput
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PolicyUpdateWithoutRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatements?: ServiceStatementUpdateManyWithoutPoliciesNestedInput
    users?: UserUpdateManyWithoutPoliciesNestedInput
    groups?: GroupUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatements?: ServiceStatementUncheckedUpdateManyWithoutPoliciesNestedInput
    users?: UserUncheckedUpdateManyWithoutPoliciesNestedInput
    groups?: GroupUncheckedUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutRolesInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    policies?: PolicyUpdateManyWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    settings?: UserSettingUpdateManyWithoutUsersNestedInput
    pats?: UserPATUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutUsersNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingUncheckedUpdateManyWithoutUsersNestedInput
    pats?: UserPATUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupUpdateWithoutRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUpdateManyWithoutGroupsNestedInput
    users?: UserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUncheckedUpdateManyWithoutGroupsNestedInput
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressCreateManyCountryInput = {
    id?: number
    street?: string | null
    number?: string | null
    box?: string | null
    city?: string | null
    postalcode?: string
    createDate?: Date | string | null
    updateDate?: Date | string | null
    county?: string | null
    userId?: number | null
  }

  export type AddressUpdateWithoutCountryInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AddressUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    box?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserPATCreateManyUserInput = {
    id?: number
    tokenName: string
    token: string
    createDate?: Date | string | null
    expirationDate: Date | string
    tokenStatus: $Enums.TokenStatus
  }

  export type PolicyUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatements?: ServiceStatementUpdateManyWithoutPoliciesNestedInput
    roles?: RoleUpdateManyWithoutPoliciesNestedInput
    groups?: GroupUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatements?: ServiceStatementUncheckedUpdateManyWithoutPoliciesNestedInput
    roles?: RoleUncheckedUpdateManyWithoutPoliciesNestedInput
    groups?: GroupUncheckedUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUpdateManyWithoutRolesNestedInput
    groups?: GroupUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUncheckedUpdateManyWithoutRolesNestedInput
    groups?: GroupUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUpdateManyWithoutGroupsNestedInput
    roles?: RoleUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUncheckedUpdateManyWithoutGroupsNestedInput
    roles?: RoleUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSettingUpdateWithoutUsersInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserSettingUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserSettingUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserPATUpdateWithoutUserInput = {
    tokenName?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenStatus?: EnumTokenStatusFieldUpdateOperationsInput | $Enums.TokenStatus
  }

  export type UserPATUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenName?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenStatus?: EnumTokenStatusFieldUpdateOperationsInput | $Enums.TokenStatus
  }

  export type UserPATUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenName?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenStatus?: EnumTokenStatusFieldUpdateOperationsInput | $Enums.TokenStatus
  }

  export type UserUpdateWithoutSettingsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    policies?: PolicyUpdateManyWithoutUsersNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    pats?: UserPATUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutUsersNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    pats?: UserPATUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PolicyUpdateWithoutGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatements?: ServiceStatementUpdateManyWithoutPoliciesNestedInput
    roles?: RoleUpdateManyWithoutPoliciesNestedInput
    users?: UserUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicestatements?: ServiceStatementUncheckedUpdateManyWithoutPoliciesNestedInput
    roles?: RoleUncheckedUpdateManyWithoutPoliciesNestedInput
    users?: UserUncheckedUpdateManyWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateManyWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUpdateWithoutGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUpdateManyWithoutRolesNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policies?: PolicyUncheckedUpdateManyWithoutRolesNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutGroupsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    policies?: PolicyUpdateManyWithoutUsersNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    settings?: UserSettingUpdateManyWithoutUsersNestedInput
    pats?: UserPATUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutUsersNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingUncheckedUpdateManyWithoutUsersNestedInput
    pats?: UserPATUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passwordless?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attemps?: NullableIntFieldUpdateOperationsInput | number | null
    blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    system?: NullableBoolFieldUpdateOperationsInput | boolean | null
    loggedinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManySenderAccountInput = {
    id?: number
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    receiverAccountId?: number | null
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type TransactionCreateManyReceiverAccountInput = {
    id?: number
    transactionid: string
    status?: $Enums.TransactionStatus
    statusMessage?: string
    isBankTransaction?: boolean
    senderAmount: number
    receiverAmount?: number | null
    senderAccountAmount: number
    receiverAccountAmount?: number | null
    senderAccountId: number
    sender?: string | null
    receiver?: string | null
    message?: string | null
    createDate?: Date | string | null
    updateDate?: Date | string | null
  }

  export type BankAccountCreateManyAccountInput = {
    id?: number
    IBAN: string
    status: $Enums.IBANStatus
    createDate?: Date | string
    updateDate?: Date | string
  }

  export type TransactionUpdateWithoutSenderAccountInput = {
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiverAccount?: AccountUpdateOneWithoutReceivertransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSenderAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiverAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutSenderAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiverAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUpdateWithoutReceiverAccountInput = {
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderAccount?: AccountUpdateOneWithoutSendertransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutReceiverAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountId?: IntFieldUpdateOperationsInput | number
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutReceiverAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionid?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    statusMessage?: StringFieldUpdateOperationsInput | string
    isBankTransaction?: BoolFieldUpdateOperationsInput | boolean
    senderAmount?: FloatFieldUpdateOperationsInput | number
    receiverAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountAmount?: FloatFieldUpdateOperationsInput | number
    receiverAccountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    senderAccountId?: IntFieldUpdateOperationsInput | number
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    receiver?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BankAccountUpdateWithoutAccountInput = {
    IBAN?: StringFieldUpdateOperationsInput | string
    status?: EnumIBANStatusFieldUpdateOperationsInput | $Enums.IBANStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    IBAN?: StringFieldUpdateOperationsInput | string
    status?: EnumIBANStatusFieldUpdateOperationsInput | $Enums.IBANStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    IBAN?: StringFieldUpdateOperationsInput | string
    status?: EnumIBANStatusFieldUpdateOperationsInput | $Enums.IBANStatus
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}